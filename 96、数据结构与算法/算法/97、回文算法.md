## 回文数据结构相关算法

### 一、前言

「**回文**」(Palindrome)是一种**对称的结构**，通常用于描述那些「**从前往后**」和「**从后往前**」读取都相同的序列

常见的回文数据结构

- **回文字符串**
  - 例如，`“radar”`和`“level”`都是回文字符串
- **回文数组**
  - 例如，数组 `[1, 2, 3, 2, 1]` 是一个回文数组
- **回文链表**
  - 回文链表是一种特殊的链表，其节点值从头到尾和从尾到头读取是相同的
  - 判断一个链表是否为回文链表通常需要使用双指针或栈等辅助数据结构
- **回文栈**
  - 栈是一种后进先出的数据结构
  - 如果一个栈的元素从栈底到栈顶的顺序与从栈顶到栈底的顺序相同，则称为回文栈
  - 实现回文栈的判断可以通过将栈元素存储到辅助结构中进行比较
- **回文队列**
  - 队列是一种先进先出的数据结构
  - 如果一个队列的元素从队头到队尾的顺序与从队尾到队头的顺序相同，则称为回文队列
  - 类似于回文栈，回文队列的判断也可以通过辅助结构实现
- **回文树**
  - 在某些特定情况下，树的结构也可以被视为回文
  - 例如，树的左右子树是镜像对称的
  - 判断一棵树是否为回文树通常需要递归地比较其左右子树

### 二、回文字符串和数组

回文字符串和数组是回文数据结构中最简单的形式，且十分相似，因此我们通常将它们放在一起讨论

#### 2.1、判断是否为回文字符串和数组

判断是否为回文字符串和数组通常使用双指针来实现，两个指针分别从字符串或数组的头和尾开始，向中间移动，如果两个指针指向的字符不相同，则不是回文

具体实现如下：

```javascript
function isPalindrome(str) {
  let left = 0;
  let right = str.length - 1;
  while (left < right) { // 双指针
    if (str[left] !== str[right]) { // 如果左右指针指向的字符不相同，则不是回文
      return false;
    }
    left++;
    right--;
  }
  return true;
}
```

#### 2.2、找到最长回文子串

最长回文子串是指一个字符串中，最长的回文子串，例如，对于字符串 `"babad"`，最长回文子串是 `"bab"` 或 `"aba"`

找到最长回文子串通常有以下几种方法：

- **中心扩展法**
- 动态规划法

**「中心扩展法」**的思路是：从头到尾遍历字符串，==以每个字符为中心，向两边扩展，找到以该字符为中心的最长回文子串，==然后不断的比较获取到的回文子串的长度，返回最长的那个

中心扩展法需要考虑一个问题，回文串的长度可能是奇数也可能是偶数

- 如果回文串的长度为奇数，则它有一个中心字符；
- 如果回文串的长度为偶数，则可以认为它有两个中心字符

所以我们可以先实现这样一个函数：

```javascript
/**
 * @description 找到以 s[l] 和 s[r] 为中心的最长回文子串
 * @param {*} s
 * @param {*} l
 * @param {*} r
 * @returns
 */
const palindrome = function(s, l, r) {
    // 防止索引越界
    while (l >= 0 && r < s.length && s[l] === s[r]) {
        // 向两边展开
        l--;
        r++;
    }
    // 此时 s[l+1..r-1] 就是最长回文串
    return s.substring(l + 1, r);
};
```

然后就可以实现提取最长回文子串的方法：

```javascript
const longestPalindrome = function(s) {
    let res = "";
    // 遍历字符串，以每个字符为中心，向两边扩展，找到以该字符为中心的最长回文子串
    for (let i = 0; i < s.length; i++) {
        // 以 s[i] 为中心的最长回文子串
        let s1 = palindrome(s, i, i);
        // 以 s[i] 和 s[i+1] 为中心扩展，找到以该字符为中心的最长回文子串
        let s2 = palindrome(s, i, i + 1);
        // 比较两个回文子串的长度，返回最长的那个
        res = res.length > s1.length ? res : s1;
        res = res.length > s2.length ? res : s2;
    }
    return res;
};

const result = longestPalindrome('babad')
console.log(result) // "bab" 或 "aba"
```

解析：

- 首先定义一个变量 `res` 来存储最长回文子串，初始值为空字符串
- 然后遍历字符串，以每个字符为中心，向两边扩展，找到以该字符为中心的最长回文子串
- 然后比较两个回文子串的长度，返回最长的那个
- 最后返回最长回文子串

### 三、回文链表
回文链表相比较于回文字符串和数组，需要考虑的问题更多，因为链表的节点值不能直接通过索引访问，而且无法倒着遍历

最简单的方法是将链表反转，然后与原链表进行比较，如果相同，则说明是回文链表，但这种做法需要额外的空间来存储反转后的链表

所以我们可以使用**「双指针」**来实现，具体思路如下：

- 使用快慢指针找到链表的中间节点
- 反转后半部分链表
- 比较前半部分链表和反转后的后半部分链表

具体实现如下：

```javascript
/**
 * @description 反转链表
 * @param {*} head
 * @returns
 */
function reverse(head) {
    let pre = null, cur = head;
    while (cur !== null) {
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}

/**
 * @description 判断是否为回文链表
 * @param {*} head
 * @returns
 */
const isPalindrome = function(head) {
    // 快慢指针
    let slow, fast;
    slow = fast = head;
    // 快指针走两步，慢指针走一步，当快指针走到链表末尾时，慢指针刚好走到链表中间
    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // 如果链表长度为奇数，则慢指针需要再走一步
    if (fast !== null)
        slow = slow.next;

    // 反转后半部分链表
    let left = head;
    let right = reverse(slow);
    // 比较前半部分链表和反转后的后半部分链表
    while (right !== null) {
        if (left.val !== right.val)
            return false;
        left = left.next;
        right = right.next;
    }

    return true;
};

```

解析：
- 当链表长度为奇数时，慢指针需要再走一步，因为奇数长度的链表中间节点只有一个
  - 需要反转的后半部分链表，会比前半部分链表少一个节点，因此遍历时需要判断后半部分链表的指针是否为空
- 当链表长度为偶数时，链表中间节点有两个
  - 需要反转的后半部分链表，和前面遍历的链表长度相同





