## 从输入 URL 到 Web 页面加载完成的过程

### 一、前言

#### 1.1、名词解释

- 协议栈
  - 解释：计算机网络控制软件
  - 作用：将应用信息打包并加上目的地地址等控制信息；用快递来类比，就是将快递打包然后再写上发件人和收件人信息；当然还有其他功能，如发生通信错误时重新发包、调节发送效率等
- 网卡
  - 解释：负责以太网或无线网络通信的硬件
  - 作用：将应用信息转换为电信号通过网络发出去
- Socket库
  - 解释：Socket库是用于调用网络功能的程序组件集合，是操作系统内置的网络库
  - 作用：Socket库中包含很多用于发送和接受数据的程序组件
- 套接字
  - 解释：套接字只是个概念没有实体，若一定要赋予它一个实体，那协议栈中存放的控制信息就是套接字
  - 作用：协议栈内部中存在一块内存空间，记录了用于控制通信操作的控制信息，比如：通信对象的IP地址、端口号、通信操作的进行状态等
- 描述符
  - 作用：应用程序通过”描述符“这一类似于号码牌的东西来识别套接字
- 端口号
  - 作用：识别应用程序的套接字的，客户端和服务端之间用来识别对方套接字的机制

#### 1.2、类比理解

- 包(Packet)：类似于快递中的概念，**包**相当于快递包裹，而路由器和交换机则相当于快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据这些控制信息进行分拣，然后将它们一步一步地搬运到目的地。
- 网络: 搬运网络包（数字信息）的机制加上浏览器、服务器这些网络应用程序就构成了网络的全貌
- IP地址：相当于现实中的XX号XX室一样，IP地址就是网络中的地址，”号“对应的是网络号，”室“对应的是主机号
- 子网掩码：IP地址是32比特的数字，按照8比特一组分为四组，再用十进制表示，包含了网络号和主机号，子网掩码是表示网络号和主机号的边界

### 二、浏览器解析 URL 并请求 HTML 的过程

1. ##### 解析URL生成HTTP请求信息
   1. HTTP协议定义了客户端和服务端交互的信息内容和步骤；HTTP请求消息中包含的内容是“对什么”和“进行怎么样的操作”两个部分；“对什么”部分是URI，“进行怎么样的操作”是方法；
   2. 浏览器虽然可以解析URL生成HTTP请求消息，但浏览器本身是不具备将消息发送到网络中的功能的；因此需要委托操作系统实现；在委托操作系统发送消息时，必须要提供服务端的Ip地址，所以在根据URL生成请求消息之后，下一步骤就是获取服务端IP地址；

2. ##### DNS域名解析

   1. 浏览器调用Socket库中的DNS解析器查询IP地址
      - 查询IP地址其实也是一次网络通信，是Socket库和DNS服务器的通信，DNS服务器的IP地址已经配置在系统里面了，传输层的协议使用的是UDP协议而不是TCP协议（为什么是UDP？后面再补充）
      - 查询到IP地址之后，Scoket库会将IP地址写入到浏览器提供的内存中去，服务端的IP地址是存在浏览器中的

3. ##### 委托协议栈发送消息（其实就是建立TCP连接，根据IP地址和默认80端口，和服务器建立TCP连接）

   知道了IP地址之后就可以委托操作系统内部的协议栈向这个目标IP地址发送消息了

   - 首先，客户端应用程序传递ip地址和端口给系统协议栈，协议栈中的tcp模块会将这些信息写入头部，tcp模块又委托ip模块进行消息传递；  
   -  当消息传递到服务端之后（服务端的服务进程是默认打开且待连接状态），服务端的tcp模块会根据客户端传递过来的端口号找到对应的套接字（协议栈中内存保存的控制信息）并且对应套接字会写入客户端的ip地址并修改连接状态为正在连接（默认是未连接），操作完成后服务端会返回响应给客户端，在返回头部中写入信息（ACK，用来告诉客户端收到请求的信息了）； 
   -  当客户端的tcp模块收到响应信息后会根据响应头判断是否连接成功，连接成功的话会将服务端的ip和端口等信息写入到自己的套接字中，并修改连接状态为连接完毕，并再次发送信息（还是只有头部信息，没有具体的数据）给服务端，通知服务端自己收到了刚才的响应信息

   （其实以上的过程就是TCP的三次握手，按照自己的理解去写的，有点拉胯，有单独的TCP协议笔记，比较详细）

   <!--三次握手的语义化理解就是：第一次握手：客户端向服务端发送消息说我要建立连接（SYN：1, seq:j）;第二次握手：服务端向客户端发送消息说同意进行连接（SYN：1,ACK:1,ack:j+1,seq:x）;第三次握手：客户端向服务端发送消息说连接成功了可以通信了（ACK:1, ack:x+1）其实做的事情主要是交换ack和seq，要保证后面通信的时候的数据的完整性-->
   
   
   
   <!--四次挥手的语义化理解就是：第一次挥手：客户端向服务端发送消息说我要断开连接了（FIN：M）;第二次挥手：服务端向客户端发送消息说收到了（ack: M+1）;第三次挥手：服务端向客户端发送消息说我也要断开连接了（FIN：N）; 第四次挥手：客户端向服务端发送消息说收到了（ACK：1，ack:k+1）-->
   
   ### 三、浏览器解析 HTML 的过程
   
   1. **HTML 文档的加载与解析**
         - 当浏览器请求一个 **HTML** 页面时，它会先接收到 **HTML** 文档并开始==逐行解析==
         - 这意味着 **HTML** 文档解析和其他资源（如 **CSS** 和 **JavaScript** 文件）的加载可以==并行进行，而不是等待整个 **HTML** 文档下载完成后才开始其他操作==
   
   
   2. **CSS** 文件的加载与解析
   
         - 当浏览器遇到 `<link>` 标签（通常用于加载外部 **CSS** 文件）时，会立即发出请求以获取这些 **CSS** 文件
   
         - 浏览器会==继续解析== **HTML**，但会==阻塞渲染==（即不会立即显示页面），直到所有的 **CSS** 文件加载并解析完成
           - 这是因为 **CSS** 文件可能会影响页面的布局和样式，浏览器需要等它们加载完成后才能正确渲染页面
   
   
   3. **JavaScript** 文件的加载与执行
         - 当浏览器遇到 `<script>` 标签（用于加载或内联 **JavaScript**）时，行为取决于脚本的类型和属性：
           - 默认情况下：浏览器会==暂停 **HTML** 文档的解析==，==等待 **JavaScript** 文件加载完成并执行==，这可能会==阻塞页面的渲染==，直到脚本执行完毕
           - `async` 属性：浏览器会==继续解析== **HTML**，同时==异步加载== **JavaScript** 文件，一旦文件==加载完成==，浏览器会==立即暂停解析并执行该脚本==
           - `defer` 属性：浏览器会==继续解析== **HTML**，直到==文档解析完成才会执行== **defer** 脚本，这种方式==不会阻塞==页面的渲染，并且多个 **defer** 脚本会按照它们在 **HTML** 中的顺序执行
   
   
   4. **DOM** 树的构建
      - 在解析 **HTML** 的过程中，浏览器逐步构建 **DOM** 树
      - 如果遇到阻塞的 **JavaScript**（即没有 `async` 或 `defer` 属性的 `<script>` 标签），**DOM** 构建会暂停，直到脚本执行完毕
      
   5. **DOMContentLoaded** 事件
      - 当整个 **HTML** 文档被完全解析且所有的 **DOM** 元素都已生成，但外部资源（如图片和样式表）还可能没有完全加载时，浏览器会触发 **DOMContentLoaded** 事件
      - 这意味着此时 **DOM** 树已经完整，但页面可能还在等待其他资源加载
      
   6. **Load** 事件
   - 当所有资源（包括图片、**CSS**、**JavaScript**等）都已加载完毕，浏览器会触发 **load** 事件，这表示页面及其所有依赖资源已经完全加载并准备就绪
   
   **总结**
   
   - **HTML** 文档：逐行解析并构建 **DOM** 树
   - **CSS**：**CSS** 的加载和解析会阻塞页面的渲染
   - **JavaScript**：如果是默认加载，**JavaScript** 的加载和执行会阻塞 **DOM** 的构建和页面的渲染，如果使用 `defer` 或 `async`，则不会阻塞
   - **DOMContentLoaded** 事件：**DOM** 树构建完成时触发
   - **Load** 事件：页面及所有资源加载完成时触发
   
   







