## 栈/队列相关算法

### 一、栈

**「栈」**主要考察**「先进后出**」特点的运用，比如表达式运算、括号合法性检测等问题

### 1.1、简化路径

**描述：**给定一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），将其转化为更加简洁的规范路径

**示例：**

```markdown
输入：path = "/a/./b/../../c/"
输出："/c"
```

**题解：**

```javascript
var simplifyPath = function(path) {
  // 维护一个路径栈
  const stk = [];
  // 将路径以 “/” 分割成数组
  const parts = path.split("/");

  // 借助栈计算最终的文件夹路径
  for (const part of parts) {
    // 如果当前路径为空或者当前路径为 “.” 无需操作跳过本次遍历，继续遍历下一个路径
    if (part === "" || part === ".") {
        continue;
    }

    // 如果当前路径为 “..” 则需要回退到上一级目录，如果栈不为空则弹出栈顶元素
    if (part === "..") {
        if (stk.length > 0) stk.pop();
        continue;
    }

    // 将当前路径压入栈中
    stk.push(part);
  }

  // 栈中存储的文件夹组成路径
  const newPath = `/${arr.join('/')}`
  return newPath === "" ? "/" : newPath
};
```

**解析：**

- 遇到空路径或“.” 则直接跳过
- 遇到“..”，则需要将路径栈栈顶元素弹出

### 1.2、括号匹配问题

**描述：**给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合
2. 左括号必须以正确的顺序闭合
3. 每个右括号都有一个对应的相同类型的左括号

**示例：**

```markdown
输入：s = "()[]{}"
输出：true

输入：s = "(]"
输出：false
```

**题解：**

```javascript
var isValid = function(str) {
  // 维护一个左括号栈
  let left = [];
  // 遍历字符串
  for (let c of str) {
    if (c === '(' || c === '{' || c === '[') {
      // 字符 c 是左括号，入栈
      left.push(c);
    } else {
      if (left.length !== 0 && leftOf(c) === left.at(-1)) {
        // 如果栈不为空且栈顶元素与当前字符匹配，则说明括号是匹配的，弹出栈顶元素
        left.pop();
      } else {
        // 如果栈为空或栈顶元素与当前字符不匹配，则返回 false
        return false;
      }
    }
  }

  // 是否所有的左括号都被匹配了
  return left.length === 0;
};

var leftOf = function(c) {
  if (c === '}') return '{';
  if (c === ')') return '(';
  return '[';
};
```

**解析：**

- 遇到左括号，则将左括号入栈
- 遇到右括号，则判断栈顶元素是否与当前字符匹配，如果匹配则弹出栈顶元素，否则返回 false
- 最后判断栈是否为空，如果为空则返回 true，否则返回 false

### 1.3、逆波兰表达式求值

**描述：**根据 逆波兰表示法，求表达式的值，有效的算符包括 `+`、`-`、`*`、`/` 每个运算对象可以是整数，也可以是另一个逆波兰表达式

**示例：**

```markdown
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**题解：**

```javascript
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  let res
  // 维护一个栈，用于存储数字
  const arr = []

  // 遍历 tokens 数组
  for(let i = 0; i < tokens.length; i++) {
    const token = tokens[i]

    // 如果 token 是运算符，则弹出栈顶两个元素，进行运算，将结果压入栈中
    if(['+', '-', '*', '/'].includes(token)) {
      let b = Number(arr.pop())
      let a = Number(arr.pop())
      // 根据运算符进行运算
      switch (token) {
        case '+': {
          res = a + b
          break;
        }
        case '-' : {
          res = a - b
          break
        }
        case '*' : {
          res = a * b
          break
        }
        case '/' : {
          // 两个整数之间的除法只保留整数部分
          res = Math.trunc(a / b)
          break
        }
      }
      // 将运算结果压入栈
      arr.push(res)
    } else {
      // 若是数字则直接压入栈
      arr.push(token)
    }
  }
  return Number(arr[0])
};
```

**解析：**

- 遍历 tokens 数组，如果 token 是运算符，则弹出栈顶两个元素，进行运算，将结果压入栈中
- 如果 token 是数字，则直接压入栈
- 最后返回栈顶元素

### 1.4、文件的最长绝对路径

**描述：**假设文件系统存储在单层文件系统中，简化路径需遵循下述规则：

1. 绝对路径 `root` 在根文件系统下，因此以 `/` 开头
2. 任意两个文件名用 `'/'` 隔开
3. 至多一个 `'.'` ，表示当前目录本身
4. 至多一个 `'..'` ，表示将返回至上一级目录
5. 所有路径为绝对路径，即不以 `'/'` 开头

**示例：**

```markdown
输入：input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
输出：32
解释：存在两个文件：
"dir/subdir1/file.ext" ，路径长度 21
"dir/subdir2/subsubdir2/file.ext" ，路径长度 32

输入：input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
输出：32
解释：存在两个文件：
"dir/subdir1/file.ext" ，路径长度 21
"dir/subdir2/subsubdir2/file.ext" ，路径长度 32
```

**题解：**

```javascript
/**
 * @param {string} input
 * @return {number}
 */
var lengthLongestPath = function(input) {
  // 维护一个栈，用于存储当前目录的父路径
  let stack = [];
  // 维护一个变量，用于存储最长路径长度
  let maxLen = 0;

  // 将输入字符串按 “\n” 分割成数组
  let parts = input.split("\n");

  // 遍历 parts 数组
  for (let part of parts) {
      // 获取当前目录的层级，有多少个 “\t” 就有多少级
      let level = part.lastIndexOf("\t") + 1;

      // 让栈中只保留当前目录的父路径
      while (level <= stack.length - 1) {
        // 如果当前目录的层级小于栈顶目录的层级，则弹出栈顶目录
          stack.pop();
      }

      // 将当前目录压入栈
      stack.push(part.substring(level));

      // 如果是文件，就计算路径长度
      if (part.includes(".")) {
          let sum = stack.reduce((acc, val) => acc + val.length, 0);
          // 加上父路径的分隔符
          sum += stack.length - 1;
          maxLen = Math.max(maxLen, sum);
      }
  }
  return maxLen;
};
```

**解析：**

- 将输入字符串按 “\n” 分割成数组，遍历 `parts` 数组，获取当前目录的层级，有多少个 “\t” 就有多少级
- 如果当前目录的层级小于栈顶目录的层级，则弹出栈顶目录，让栈中只保留当前目录的父路径
- 将当前目录压入栈
- 如果是文件，就计算路径长度，加上父路径的分隔符，更新最长路径长度
- 最后返回最长路径长度

### 1.5、单调栈

**「单调栈」**是一种特殊用途的栈，要求栈内元素必须保持 **单调递增** 或 **单调递减** 的顺序

单调栈的本质：

- 维护一个单调序列（递增 / 递减）
- 每次新元素来临时，根据单调性，把不可能再影响答案的元素弹出
- 栈顶就代表了“离自己最近、还可能约束自己”的元素

**代码模板：**

```javascript
// nextGreaterRight: 返回每个元素右侧第一个更大元素（不存在用 -1）
function nextGreaterRight(nums) {
  const n = nums.length;
  const res = new Array(n).fill(-1);
  const stack = []; // 存储索引，保持 nums[stack[i]] 单调递减（栈底→栈顶）

  for (let i = 0; i < n; i++) {
    while (stack.length && nums[i] > nums[stack[stack.length - 1]]) {
      const idx = stack.pop();
      res[idx] = nums[i];
    }
    stack.push(i);
  }

  return res;
}

// 用例
console.log(nextGreaterRight([2,1,2,4,3])); // [4,2,4,-1,-1]

```



#### 1.5.1、
