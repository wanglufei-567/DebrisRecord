

## Vue3源码剖析（四）— Vue3响应式原理

### 一、前言

#### 1.1、Vue3与Vue2的区别

##### 1.1.1、响应式实现上的不同

- 在Vue2的时候使用`defineProperty`来进行数据的劫持, 需要对属性进行重写添加`getter`及`setter` **性能差**
- 当新增属性和删除属性时无法监控变化。需要通过`$set`、`$delete`实现
- 数组不采用`defineProperty`来进行劫持 （浪费性能，对所有索引进行劫持会造成性能浪费）需要对数组单独进行处理

Vue3中使用`Proxy`来实现响应式数据变化，从而解决了上述问题

##### 1.1.2、CompositionAPI与OptionsAPI

- 在Vue2中采用的是OptionsAPI, 用户提供的`data`,`props`,`methods`,`computed`,`watch`等属性 (用户编写复杂业务逻辑会出现反复横跳问题)
- Vue2中所有的属性都是通过`this`访问，`this`存在指向明确问题
- Vue2中很多未使用方法或属性依旧会被打包，并且所有全局API都在Vue对象上公开。Composition API对 `tree-shaking` 更加友好，代码也更容易压缩。
- 组件逻辑共享问题， Vue2 采用`mixins` 实现组件之间的逻辑共享； 但是会有数据来源不明确，命名冲突等问题。 Vue3采用CompositionAPI 提取公共逻辑非常方便

简单的组件仍然可以采用OptionsAPI进行编写，compositionAPI在复杂的逻辑中有着明显的优势。 `reactivity`模块中就包含了很多我们经常使用到的`API` 例如：`computed`、`reactive`、`ref`、`effect`等

### 二、reactive与effect

### 2.1、reactivity模块基本使用

```html
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: 'zf', age: 13, address: { num: 30 }, flag: true }

    // reactive() 会对属性进行劫持 proxy， 监听用户的获取操作和设置操作
    // reactive() 只能传入对象， 因为proxy 只支持对象格式
    const state = reactive(obj);

    // effect 函数默认会执行一次， 后续数据变化了会重新执行effect函数
    effect(() => {
      app.body.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
    })

    setTimeout(() => {
      state.age++
    }, 1000)
  </script>
</body>
```

`reactive`方法会将对象变成proxy对象， `effect`中在使用`reactive`对象时会进行依赖收集，稍后属性变化时会重新执行`effect`函数~

### 2.2、reactive方法实现

#### 2.2.1、Ploxy和Reflect中的receiver

`Reflect.get(target, name, receiver)`

如果`name`属性设置了`getter`、`setter`方法，则方法中的`this`指向`receiver`

```js
var target = {
  c: 1,
  get a() { return this.c }
}

Reflect.get(target, 'a', { c: 2 }) // 2
```

`Ploxy`中的`get(target, propKey, receiver)`与`set(target, propKey, value, receiver)`

 `receiver` 指向 `proxy` 本身或者继承它的对象

下面是`Proxy`和`Reflect`结合使用的例子👇

```js
var target = {
  get a() {
    return this.b
  }
}

var p = new Proxy(target, {
  get(target, key, receiver) {
     if (key === 'b') { return 3 }
     return Reflect.get(target, key)
  }
})

p.a // undefined, target 本身没有 b 这个属性，所以访问到的是 undefined
```

```js
var p = new Proxy(target, {
  get(target, key, receiver) {
     if (key === 'b') { return 3 }
     return Reflect.get(p, key)
  }
})

p.a // 这样会死循环, get中会再次触发get
```

```js
var p = new Proxy(target, {
  get(target, key, receiver) {
     if (key === 'b') { return 3 }
     return Reflect.get(target, key, receiver)
  }
})

p.a // 3, 通过设置target中get a()中的this指向proxy本身，从而能够走到proxy中的get()中
```

#### 2.2.2、WeakMap使用

`WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合。

```javascript
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = {foo: 1};
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
wm2.get(k2) // "bar"
```

`WeakMap`与`Map`的区别有两点。

- `WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。

- `WeakMap`的键名所指向的对象，不计入垃圾回收机制。

`WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用

```javascript
const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [
  [e1, 'foo 元素'],
  [e2, 'bar 元素'],
];
```

上面代码中，`e1`和`e2`是两个对象，我们通过`arr`数组对这两个对象添加一些文字说明。这就形成了`arr`对`e1`和`e2`的引用。

一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用的内存。

```javascript
// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr [0] = null;
arr [1] = null;
```

上面这样的写法显然很不方便，一旦忘了写，就会造成内存泄露。

`WeakMap` 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

#### 2.2.3、reactive方法具体实现

> `reactive(target)`的接受参数必须是一个对象类型。否则没有任何效果
>
> `reactive(target)`实现的核心就是利用`proxy`对`target`进行代理

```typescript
// packages/reactivity/src/reactive.ts
import { isObject } from '@vue/shared';
import { mutableHandlers } from './baseHandlers';

function createReactiveObject(target: object) {
  // 只接受对象做代理
  if (!isObject(target)) {
    return target;
  }

  // 对target进行代理
  const proxy = new Proxy(target, mutableHandlers);
  return proxy;
}

// 常用的就是reactive方法
export function reactive(target: object) {
  return createReactiveObject(target, false);
}

```

```typescript
// packages/reactivity/src/baseHandlers.ts
export const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    // 等会谁来取值就做依赖收集
    const res = Reflect.get(target, key, receiver);
    return res;
  },
  set(target, key, value, receiver) {
    // 等会赋值的时候可以重新触发effect执行
    const result = Reflect.set(target, key, value, receiver);
    return result;
  }
};
```

`isObject()`的路径及实现

```typescript
// packages/shared/src/index.ts
export const isObject = (value) =>{
  return typeof value === 'object' && value !== null
}
```

以上就是`Reactive(target)`主要核心代码，很简单的代理实现

上面的`Reactive(target)`已经可以直接使用了，但是还有些特殊情况需要进行兜底逻辑处理

两个特殊情况：

- `Reactive(target)`中的`target`已经被代理过了，如果再次创建一个新的代理对象，未免有点浪费内存和性能，所以需要进行缓存处理，若`target`已经被代理过了，则直接返回代理对象
- `Reactive(target)`中的`target`已经是一个代理对象了，那完全没有必要对一个代理对象进行再次代理，所以需要增加判断`target`是否是代理对象的逻辑

完整代码如下👇

```typescript
// packages/reactivity/src/reactive.ts
import { isObject } from '@vue/shared';
import { ReactiveFlags, mutableHandlers } from './baseHandlers';

// 缓存列表，使用要代理的对象作key
const reactiveMap = new WeakMap();

function createReactiveObject(target: object, isReadonly: boolean) {
  // 只接受对象做代理
  if (!isObject(target)) {
    return target;
  }

  /**
   * 在进行对象代理前先进行取值，看是否已经是代理对象了
   * 若不是代理对象则target[ReactiveFlags.IS_REACTIVE]为undefined
   * 若是已经代理过的对象，则会走到mutableHandlers.get()中，返回值为true
   * 即target[ReactiveFlags.IS_REACTIVE]===true表示target已经被代理过了
   */
  if (target[ReactiveFlags.IS_REACTIVE]) {
    return target;
  }

  // 如果已经代理过则直接返回代理后的对象
  const existingProxy = reactiveMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }

  // 对target进行代理
  const proxy = new Proxy(target, mutableHandlers);
  // 缓存已经代理的对象
  reactiveMap.set(target, proxy);

  return proxy;
}

// 常用的就是reactive方法
export function reactive(target: object) {
  return createReactiveObject(target, false);
}
```

```typescript
// packages/reactivity/src/baseHandlers.ts
export const enum ReactiveFlags {
  IS_REACTIVE = '__v_isReactive'
}

export const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    // 在get中增加标识，当获取IS_REACTIVE时返回true
    if (key === ReactiveFlags.IS_REACTIVE) {
      console.log('IS_REACTIVE', target)
      return true;
    }
    // 等会谁来取值就做依赖收集
    const res = Reflect.get(target, key, receiver);
    console.log('get', target, res)
    return res;
  },
  set(target, key, value, receiver) {
    // 等会赋值的时候可以重新触发effect执行
    const result = Reflect.set(target, key, value, receiver);
    return result;
  }
};
```

使用效果

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="./reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: 'zf', age: 13, address: { num: 30 }, flag: true }

    const state = reactive(obj);
    console.log(state) // Proxy {name: 'zf', age: 13, address: {…}, flag: true}
    
    const state2 = reactive(obj);
    console.log(state === state2) // true

    const state3 = reactive(state);
    console.log(state === state3) // true
  </script>
</body>

</html>
```

### 2.3、effect方法实现

`effect(fn)`中的`fn`，首先默认执行一次，后续若`fn`中依赖到的`reactiveObject`的属性发生变化，则`fn`会再次执行；Vue3中的`effect()`相当于Vue2中的`watcher`，都是属性数据变化之后执行相应的回调；说到这里，其实就应该想到**观察者模式**和**发布订阅模式**；在Vue2中使用到的便是**观察者模式**，`reactiveObject`的属性的`set()`中调用`watcher`的`update()`完成回调的执行；在Vue3中使用到的事**发布订阅模式**，`reactiveObject`的属性的`set()`中调用`ReactiveEffect`（调度中心）的`trigger()`方法，`trigger()`方法会将`ReactiveEffect`（调度中心）中的维护的回调队列中（其实是`ReactiveEffect`实例，实例上的`run()`才是`effect(fn)`中的fn）的回调拿出来一一执行

#### 2.3.1、effect()函数

```js
// packages/reactivity/src/effect.ts
export let activeEffect = undefined;// 当前正在执行的effect

class ReactiveEffect {
    deps = []; // 收集effect中使用到的属性
    constructor(public fn) { }
    run() {
        // 设置成正在激活的是当前effect
        activeEffect = this;
        return this.fn();
    }
}
export function effect(fn) {
    const _effect = new ReactiveEffect(fn); // 创建响应式effect
    _effect.run(); // 让响应式effect默认执行
}
```

其中`activeEffect`是个全局变量，记录的是当前正在执行的`effect`（是`ReactiveEffect`实例），所以在`reactive.ts`中是可以直接拿到并直接使用的，后续的依赖收集就是使用这个`activeEffect`全局变量，在`Proxy`的`get()`中完成的

```js
export let activeEffect = undefined;
```

每一个`effect(fn)`方法的执行都会创建一个`ReactiveEffect`实例，为什么要单独实例化一个`ReactiveEffect`来执行`fn`，那是因为`ReactiveEffect`上实现了`effect`依赖的属性、激活状态等很多属性及`effect`失活等方法（这些后面会用到）

```js
export function effect(fn) {
    const _effect = new ReactiveEffect(fn); // 创建响应式effect
    _effect.run(); // 让响应式effect默认执行
}
```

#### 2.3.2、依赖收集`track()`方法

所谓**依赖收集**就是在`effect(fn)`中`fn`默认执行（第一次执行）时，对`fn`中依赖到的`reactiveObject`的`attr`

进行收集，实现如下👇

```js
// packages/reactivity/src/effect.ts

// 记录依赖关系，数据格式{target: { attr: [effect, effect]}}
const targetMap = new WeakMap();
export function track(target, key) {
  if (activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }
    // 依赖收集的存储操作
    trackEffects(deps);
  }
}

export function trackEffects(deps) {
  /**
   * 若是当前attr已经记录了此activeEffect
   * 则不再次收集
   */
  let shouldTrack = !deps.has(activeEffect);
  if (shouldTrack) {
    // attr 记录 effect
    deps.add(activeEffect);
    // effect 记录 attr 放的是set
    activeEffect.deps.push(deps);
  }
}
```

```js
// packages/reactivity/src/baseHandlers.ts

import { track } from './effect';
export const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    ...
    // 让当前的属性和 正在激活的effect关联起来
    track(target, key);

    const res = Reflect.get(target, key, receiver);
    ...
    return res;
  }
};
```

整个流程是这样的：`effect(fn)` :arrow_right:`_effect.run()`:arrow_right: `proxy get()`:arrow_right:`track()`

依赖收集是发生在`proxy get()`中，这个也是为什么要对原对象进行代理的一个原因，后面`attr`的变化引起的回调执行，也是要在代理对象`reactiveObject`的`proxy set()`实现；

实际上依赖收集是双向的，`effect`要收集`attr`，`attr`也要收集`effect`；

- `attr`收集`effect` 

  上面实现中的`targetMap`是用来存储有依赖到`reactiveObject`的属性的`effect`

  ```js
  // 记录依赖关系，数据格式{target: { attr: [effect, effect]}}
  const targetMap = new WeakMap();
  ```

  `targetMap`的数据格式是`{target: { attr: [effect, effect]}}`，其中`target`是`proxy`中的`target`（也就是`reactiveObject`），`attr`就是`fn`中依赖到属性，`[effect, effect]`是个`set`，放的是不同的`effect`（一个`attr`可能被好几个`effect`依赖）

  ```js
  export const mutableHandlers: ProxyHandler<object> = {
    get(target, key, receiver) {
      ...
      // 让当前的属性和 正在激活的effect关联起来
      track(target, key);
      ...
    }
  };
  ```

  ```js
   export function track(target, key) {
     ...
     let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()));
      }
      let deps = depsMap.get(key);
      if (!deps) {
        depsMap.set(key, (deps = new Set()));
      }
     ...
     // 依赖收集的存储操作
    trackEffects(deps);
   }
     
   export function trackEffects(deps) {
     ...
     // attr 记录 effect
    deps.add(activeEffect);
     ...
  }
  ```

  `deps.add(activeEffect)`这里的 `deps`就是对应`key`的`set`，`activeEffect`则是当前正在活跃的`effect`

  试想下，有两个`effect`（`e1`、`e2`）都依赖了属性`a`，那么`e1`的回调默认执行时，`a`便会收集到`e1`，此时的`targetMap`便是这样的：`{target: { a: [e1]}}`；当`e2`的回调默认执行时，`a`同样会收集`e2`，此时的`targetMap`便是这样的：`{target: { a: [e1，e2]}}`；这样便完成了`attr`收集`effect` 

- `effect`收集`attr`

  同样的，`effect`也是要收集`attr`的，维护在`effect.deps`中， `deps`是个数组，因为一个`effect`可能会依赖到多个`attr`

  ```js
   export function trackEffects(deps) {
     ...
    // effect 记录 attr 放的是set
    activeEffect.deps.push(deps);
     ...
  }
  ```

  看到这行代码可能会有这样的疑问： `activeEffect.deps`中收集的不应该是`attr`的`key`值，为什么收集的是`attr`的`effect`，这个问题可以暂时留着，待到后面实现`attr`变化引起的响应式变化时，再去理解；

  试想下，有两个`effect`（`e1`、`e2`）都依赖了属性`a`、`b`，那么`targetMap`应该是这样的：`{target: { a: [e1,e2], b:[e1,e2]}}`，而`effect.deps`( `activeEffect.deps`)应该是这样的：`[[e1,e2],[e1,e2]]`，关于`effect.deps`这里不妨就先记着是这样的，接着往下看

#### 2.3.3、触发更新`trigger()`方法

触发更新就是指`reactiveObject`的`attr`发生变化时，`attr`收集到`effect`会相应的再次执行，实现如下👇

```typescript
// packages/reactivity/src/effect.ts

export function trigger(target, key, value) {
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    return; // 属性没有依赖任何的effect
  }
  let effects = depsMap.get(key);
  triggerEffects(effects);
}

export function triggerEffects(effects) {
  if (effects) {
    effects.forEach(effect => {
     /**
       * 保证要执行的effect不是当前的effect
       * 避免effect中直接改动attr引起的effect再次执行的死循环
       * 因为attr只要变化便会触发trigger
       * 这里做逻辑判断就是阻断掉effect中直接改动attr引起的trigger
       */
      if (effect !== activeEffect) {
        // 数据变化了，找到对应的effect 重新执行
        effect.run();
        }
      }
    });
  }
}
```

```typescript
// packages/reactivity/src/baseHandlers.ts

import { trigger } from './effect';
export const mutableHandlers: ProxyHandler<object> = {
    set(target, key, value, receiver) {
    let oldValue = target[key];
    if (oldValue !== value) {
      // 重新赋值时，若新值和老值不同则触发effect
      trigger(target, key, value);
      let result = Reflect.set(target, key, value, receiver);
      return result;
    }
  }
};
```

整个流程是这样的：`reactiveObject`的`attr`发生变化:arrow_right: `proxy set()`​ :arrow_right: `trigger()`​ :arrow_right: `effect.run()`​ :arrow_right: `effect(fn)`中的`fn`再次执行

上面实现中有段特殊逻辑：

```typescript
/**
 * 保证要执行的effect不是当前的effect
 * 避免effect中直接改动attr引起的effect再次执行的死循环
 * 因为attr只要变化便会触发trigger
 * 这里做逻辑判断就是阻断掉effect中直接改动attr引起的trigger
 */
if (effect !== activeEffect) {
  // 数据变化了，找到对应的effect 重新执行
 effect.run();
  }
}
```

是为了解决这种场景：

```js
// 缓存代理结果 require()
const {effect ,reactive} = VueReactivity;
const state = reactive({ age: 30 })
effect(() => { 
   if(age>30) age++;
});
age = 31;
```

直接在`effect(fn)`中对`reactiveObject`的`attr`重新赋值

试想下，若是没有上面那段判断逻辑，`age = 31` :arrow_right: `trigger()` :arrow_right:  `effect.run()` :arrow_right: `fn`再次执行 :arrow_right: `age`变化......便会陷入死循环；

那这段特殊逻辑是怎么避免了死循环的呢？是否还记得 `effect.run()`的实现

```typescript
run() {
    // 设置成正在激活的是当前effect
    activeEffect = this;
    return this.fn();
}
```

每次`effect.run()`执行时，便会将全局变量`activeEffect`置为当前的`effect`，那当`attr`发生变化引起的`trigger()`时，只要将当前的`effect`从`attr`收集到的`effect`中过滤掉不执行`effect.run()`便可以避免死循环；

那么上面的案例的流程就变成了这样：`age = 31` :arrow_right: `trigger()` :arrow_right:  `effect.run()` :arrow_right: `fn`再次执行 :arrow_right: `activeEffect = this` :arrow_right: `age++` :arrow_right: `trigger()` :arrow_right: `effect !== activeEffect`为`false` :arrow_right: 结束，`effect.run`不执行

#### 2.3.4、实现效果

以上就是Vue3响应式变化的基本实现，下面👇看下实现效果

```html
<!--  -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="./reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: '张三', age: 13, address: { num: 30 }, flag: true }
    const state = reactive(obj);

    effect(() => {
      app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
    })

    setTimeout(() => {
      state.age++
    }, 1000)
  </script>
</body>

</html>
```

运行结果

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220603181116115-20220603181158295.png" style="zoom:50%;" />

一秒之后

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220603181219615.png" alt="image-20220603181219615" style="zoom:50%;" />



### 2.4、响应式中的一些特殊逻辑

#### 2.4.1、嵌套`effect`的处理逻辑

先看下嵌套`effect`的具体场景

```js
  const obj = { name: '张三', age: 13, flag: false }
  const state = reactive(obj);

  effect(() => { // e1
    state.name
    effect(() => { // e2
      state.age
    })
    state.flag
  })
```

```typescript
// packages/reactivity/src/effect.ts
export let activeEffect = undefined;// 当前正在执行的effect

class ReactiveEffect {
    ...
    run() {
        // 设置成正在激活的是当前effect
        activeEffect = this;
        return this.fn();
    }
  ...
}
```

这里有两个`effect`：`e1`、`e2`，`e2`嵌套在`e1`中，在`e1`初次执行到`state.name`这一行时，全局变量`activeEffect`指向的是`e1`，但接下来执行`e2`的时候，`activeEffect`指向的就变成了`e2`；

到这里其实一切都还没问题，但当`e2`执行完成，再去执行`state.flag`时，此时的`activeEffect`指向的还是`e2`，这就有问题了，明明`flag`是`e1`依赖的属性，怎么能和`e2`绑定呢

所以这里应该有这样一段逻辑，当`e2`执行完成时，`activeEffect`指向应该由`e2`变回`e1`

因此需要对`activeEffect`的指向进行改造，改造之后的逻辑如下👇

```typescript
// packages/reactivity/src/effect.ts
export let activeEffect = undefined;// 当前正在执行的effect

class ReactiveEffect {
   public parent = undefined;
    ...
run() {
    try {
      // 将activeEffect设置为当前ReactiveEffect实例的父effect，用作记录存储
      this.parent = activeEffect;
      // 再将当前ReactiveEffect实例设置为activeEffect
      activeEffect = this;
      return this.fn();
    } finally {
      /**
       * 执行完毕后还原activeEffect，
       * 也就是当前的ReactiveEffect实例只对出现在自己fn方法中的属性进行依赖收集操作
       * 若不执行这一步，每一次响应式对象中有get()操作时都会将属性收集到activeEffect中
       */
      activeEffect = this.parent;
      this.parent = undefined;
    }
  }
  ...
}
```

#### 2.4.2、依赖更新与`cleanup`

先看下这个场景

```js
const {effect ,reactive} = VueReactivity;

const state = reactive({ flag: true, name: '张三', age: 30 })
effect(() => {
    document.body.innerHTML = state.flag ? state.name : state.age
});
setTimeout(() => {
    state.flag = false;
    setTimeout(() => {
        console.log('修改name，原则上不更新')
        state.name = '李四'
    }, 1000);
}, 1000)
```

当`state.flag`为`true`时，`effect`依赖的是`name`属性，但当`state.flag`为`false`时，`effect`就不再依赖`name`属性，而是依赖`age`属性；因此，当`name`改变时，`effect`应该不再次执行，但目前的响应式变化`trigger`中并没有将`name`属性进行依赖移除的逻辑，所以当`name`改变时，`effect`会再次执行

依赖更新是由`trigger`触发的，但是具体逻辑却是在`effect.run()`处理的

改造逻辑如下👇

```typescript
export function trigger(target, key, value) {
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    return; // 属性没有依赖任何的effect
  }
  let effects = depsMap.get(key);
  triggerEffects(effects);
}

export function triggerEffects(effects) {
  if (effects) {
    /**
     * 注意：这里的attr收集的effects在effect的deps中也有保存
     * 所以需要将effects复制一份，再进行操作，
     * 避免effect.run()中清理effect时的死循环
     */
    effects = new Set(effects);
    effects.forEach(effect => {
      if (effect !== activeEffect) {
        effect.run(); // 数据变化了，找到对应的effect 重新执行
      }
    });
  }
}
```

```typescript
class ReactiveEffect {
  ...
  run() {
    try {
      ...
      /**
       * 清理当前ReactiveEffect实例中的deps
       * 在下面的fn()执行时会再次收集
       * 也就是先清理在收集，为什么这么处理
       * 是因为当前ReactiveEffect实例依赖的attr可能会发生变化
       * 这样做是为了更新effect依赖的attr
       */
      cleanEffect(this);
      return this.fn();
    } finally {
      activeEffect = this.parent;
      this.parent = undefined;
    }
  }
  
/**
 * 清理effect收集的attr的deps(set集合, set存放的是effect)
 * set中存放的是attr收集的effect(是所有的effect，不只是当前的effect)
 * 这里只是从attr收集的所有effect中删除当前的effect
 * 所以这里有两步逻辑
 * 1、从attr收集的所有effect中删除当前的effect
 * 2、将当前effect的deps清空
 * 既清理了attr的依赖又清理了effect的依赖
 */
function cleanEffect(effect) {
  let deps = effect.deps;
  for (let i = 0; i < deps.length; i++) {
    deps[i].delete(effect);
  }
  effect.deps.length = 0;
}
```

依赖更新的实现其实是每次`trigger`的执行，就会先清理依赖，之后再重新进行收集

整个流程是这样的：`attr`变化 :arrow_right: `proxy set()` :arrow_right: `trigger()` :arrow_right: `effect.run()` :arrow_right: `cleanEffect()`清理依赖   :arrow_right: `this.fn()` :arrow_right: `proxy get()` :arrow_right: `track()`重新收集依赖

其中 `cleanEffect()`清理依赖的逻辑可能有点难理解

```typescript
function cleanEffect(effect) {
  let deps = effect.deps;
  for (let i = 0; i < deps.length; i++) {
    deps[i].delete(effect);
  }
  effect.deps.length = 0;
}
```

应该还记得`effect.deps`中收集的不是`atrr`的`key`，而是`attr`依赖的`effect`(是所有的`effect`，不只是当前的一个`effect`)，所以`cleanEffect()`中做了两件事

- 从`attr`收集的所有`effect`中删除当前的`effect`
- 将当前`effect`的`deps`清空(length = 0会直接将数组清空)

#### 2.4.3、effect停止依赖收集

 `effect`中在使用`reactive`对象时会进行依赖收集，之后属性变化时会重新执行`effect`函数，但若是想要在某一时刻想要取消这种响应式变化，如何处理呢？

所以应该有这样一个功能，提供一个控制`effect`激活状态的`api`由调用方自行决定什么时候进行响应式变化

改造逻辑如下👇

```typescript
// packages/reactivity/src/effect.ts

class ReactiveEffect {
  ...
  /**
   * 失活操作
   * 停止收集依赖
   */
  stop() {
    if (this.active) {
      this.active = false;
      cleanEffect(this);
    }
  }
}

export function effect(fn, options?) {
  // 将外部传递进来的函数设置为响应式的effect
  const _effect = new ReactiveEffect(fn);
  // 让响应式effect默认执行一次
  _effect.run();
  // 更改runner中的this
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect; // 暴露effect的实例
  // effect返回runner的目的是让用户可以自己控制渲染逻辑
  return runner; // 用户可以手动调用runner重新执行
}
```

给`ReactiveEffect`实例上增加`stop`方法，`stop`方法中会将`effect`置为失活状态并进行依赖清理，之后再通过将`effect`暴露出去的方式，让用户可以自行调用`runner()和`runner.effect.stop()`进行`effect`失活与激活状态的切换

#### 2.4.4、调度执行（实现批量更新）

先看下这个👇场景，猜测下`effect`共执行几次

```html
<!--  -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="./reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: '张三', age: 13, address: { num: 30 }, flag: false }
    const state = reactive(obj);

    const runner = effect(() => {
      console.log('runner')
      app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
    })

    setTimeout(() => {
      state.name = '李四'
      state.age++
      state.address.num ++
    }, 5000)
  </script>
</body>

</html>
```

打印结果是4次，除去第一次默认执行，还执行了3次，也就是说`reactiveObject`的`attr`每变化一次，就会`trigger()`一次，`effect(fn)`的`fn`就会执行一次，`html`就会重新渲染一次,这样未免太浪费性能了，所以期望有一个批量更新的逻辑，可以实现多次变化只执行一次渲染

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220608232301142.png" alt="image-20220608232301142" style="zoom:50%;" />

改造逻辑如下👇

首先实现`scheduler`（调度）功能，支持用户自定义`trigger()`之后的执行逻辑（默认是执行`effect(fn)`中的`fn`）

```typescript
// packages/reactivity/src/effect.ts
class ReactiveEffect {
  ...
  // 传递的fn、scheduler挂到this上
  constructor(public fn, public scheduler?) {}
  ...
}

export function effect(fn, options = {} as any) {
  ...
  /**
   * 将外部传递进来的函数设置为响应式的effect
   * options为用户自定义的配置项
   */
  const _effect = new ReactiveEffect(fn, options?.scheduler);
  ...                                   
}

export function triggerEffects(effects) {
  if (effects) {
    effects = new Set(effects);
    effects.forEach(effect => {
      if (effect !== activeEffect) {
        if (effect.scheduler) {
          effect.scheduler(); // 可以提供一个调度函数，用户实现自己的逻辑
        } else {
          effect.run(); // 数据变化了，找到对应的effect 重新执行
        }
      }
    });
  }
}
```

上面改造的逻辑可以让用户在使用`effect(fn, [options])`方法时，通过配置项传入自定义的`scheduler`，指定`trigger`触发时执行的逻辑；

上面的逻辑中关键的是这里，用户若配置了`scheduler`则不再执行`effect.run()`也就是`fn`，而是执行`scheduler`

```typescript
if (effect.scheduler) {
  effect.scheduler(); // 可以提供一个调度函数，用户实现自己的逻辑
} else {
  effect.run(); // 数据变化了，找到对应的effect 重新执行
}
```

那有了`scheduler`，用户便可以自己自己决定`trigger`触发时，副作用函数执行的时机、次数、及执行方式，从而实现批量更新的效果

注意：`scheduler`实现的仅仅是自定义副作用函数，也就是说每次`trigger`之后，`scheduler`都会执行一次，Vue本身并没有做响应式变化的批量更新逻辑，但是通过`scheduler`我们是能够实现批量更新的

批量更新使用如下👇

```js
<script src="./reactivity.global.js"></script>
<div id="app"></div>
<script>
  const { effect, reactive } = VueReactivity;

  const obj = { name: '张三', age: 13, address: { num: 30 }, flag: false }
  const state = reactive(obj);

  let waiting = false;
  const runner = effect(() => {
    console.log('runner')
    app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
  }, {
    scheduler() { // 调度函数
      console.log('scheduler')
      if (!waiting) {
        waiting = true
        Promise.resolve().then(() => {
          runner();
          waiting = false;
        })
      }
    }
  })

  setTimeout(() => {
    state.name = '李四'
    state.age++
    state.address.num++
  }, 1000)
</script>
```

上面👆批量更新的关键在于`Promise.resolve().then()`的使用，我们应当明确的一点是，Vue的`tragger`都是同步逻辑，那当我们在一次`scheduler`中使用了`promise`之后，产生的异步逻辑，就会在所有的同步逻辑执行完之后才会执行，也就是说，每次`tragger`都会触发`scheduler`,但`scheduler`中的异步逻辑要等到所有的`tragger`都触发之后才更新；那利用这个特性，我们便可以实现同步更新操作；

实现效果如下👇

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220609001337257.png" alt="image-20220609001337257" style="zoom:50%;" />

### 2.5、`computed`实现

同Vue2的`computed`计算属性一样，Vue3的`computed`计算属性也是将几个`reactiveObject`的属性(`attr1`、`attr2`...)整合成一个新的`reactiveObject`的属性(`attr`)，当`attr1`、`attr2`...改变时，`attr`也会相应的改变

`computed`的使用如下👇

```js
const attr = computed(() => {
...
return attr1 + attr2
})
// 或者
const attr = computed({
  get(){
    ...
    return attr1 + attr2
  },
  set(val){
   attr1 = val;
  }
})
```

实现如下👇

```typescript
// packages/reactivity/src/computed.ts

import { isFunction } from '@vue/shared';
import {
  activeEffect,
  ReactiveEffect,
  trackEffects,
  triggerEffects
} from './effect';

export function computed(getterOrOptions) {
  // 判断传进来的是get方法还是配置项
  let isGetter = isFunction(getterOrOptions);

  // 赋值get和set方法
  let getter;
  let setter;
  const fn = () => console.warn('computed is readonly ');
  if (isGetter) {
    getter = getterOrOptions;
    setter = fn;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set || fn;
  }

  // 返回ComputedRefImpl实例
  return new ComputedRefImpl(getter, setter);
}

/**
 * ComputedRefImpl类
 * 内部封装了ReactiveEffect的实例化
 * 负责依赖收集的工作
 */
class ComputedRefImpl {
  private _value; // 用来存储计算属性的结果
  private _dirty = true; // 用来判断是否缓存，即是否重新计算
  public effect; // 计算属性对应的effect
  public deps; // 用于收集依赖当前计算属性的effect(注意：和计算属性对应effect区分开)
  constructor(getter, public setter) {

    // effect.deps 存的是属性对应的set集合
    this.effect = new ReactiveEffect(getter, () => {
      /**
       * effect 的 scheduler，
       * 这里自定义 当前计算属性依赖的 attr 发生变化后的更新逻辑
       */
      if (!this._dirty) {
        /**
         * 这里的更新逻辑是
         * 当计算属性被使用后，_dirty就会为false，使用的便是缓存值了
         * 也只有计算属性被使用后，才需要走这段更新逻辑
         */
        this._dirty = true;
        // 通知依赖当前计算属性的effect更新
        triggerEffects(this.deps);
      }
    });
  }

  get value() {
    /**
     * 有effect依赖当前计算属性的话，就将其收集到当前计算属性的deps中
     * 注意：只有当effect的副作用函数执行时，activeEffect才有值，
     * 若是当前计算属性value在被使用时，activeEffect有值的话
     * 就说明了此activeEffect时依赖当前计算属性的
     */
    if (activeEffect) {
      trackEffects(this.deps || (this.deps = new Set()));
    }

    /**
     * 只有当_dirty为true时
     * 即当前计算属性依赖的 attr 发生变化后
     * 才走计算属性的getter逻辑并更新_value
     * 否则就不更新_value直接返回（也就是缓存值）
     */
    if (this._dirty) {
      // 将_dirty置为false，表明接下来计算属性返回的是缓存值
      this._dirty = false;
      this._value = this.effect.run();
    }
    return this._value;
  }

  /**
   * 直接执行用户配置的set
   * 在set中可以直接修改 reactiveObj 的 attr
   */
  set value(newValues) {
    this.setter(newValues);
  }
}

```

`computed`的实现中，有两个核心的点

- `computed`缓存值的实现
- `computed`本身就是个`effect`，但其又收集了其他使用`computed`自己本身的`effect`，用作响应式更新

### 2.6、`watch`实现

`watch`的核心就是观测一个响应式数据，当数据变化时通知并执行回调 （那也就是说它本身就是一个`effect`）

```js
watch(state,(oldValue,newValue)=>{ // 监测一个响应式值的变化
    console.log(oldValue,newValue)
})
// 或者
watch(state => stae[key],(oldValue,newValue)=>{ // 监测一个响应式值的变化
    console.log(oldValue,newValue)
})
```

`watch`的使用有几个关键主要注意：

- `watch`如果监控的是一个对象那么，对象是无法拿到老值的，`oldValue`内的数据会是更新之后的（vue2也是一样) ，这个是因为对象是引用类型的，`oldValue`,`newValue`指向的是同一个对象
- vue3 中`watch`监控的是一个对象的时候默认会深度监控，对象内的所有属性都会被监控，所以尽量不要采用这种直接监控对象的方式 （默认会递归访问对象的属性，所以不建议用）
- 如果监控的是某个属性的话 需要写成函数的格式

`watch`的实现如下

```typescript
// packages/reactivity/src/baseHandler.ts
export function isReactive(value) {
  return value && value[ReactiveFlags.IS_REACTIVE];
}
```

```typescript
import { ReactiveEffect } from './effect';
import { isReactive } from './baseHandler';
import { isFunction, isObject } from '@vue/shared';

/**
 * 用来递归访问对象属性
 * set用来存放已经迭代过的对象
 */
function traversal(value, set = new Set()) {
  if (!isObject(value)) {
    return value;
  }

  if (set.has(value)) {
    // 此对象已经被迭代过了
    return value;
  }
  set.add(value);

  for (let key in value) {
    // 递归逻辑，value[key] 访问所有属性
    traversal(value[key], set);
  }

  return value;
}

export function watch(source, cb, { immediate } = {} as any) {
  let get; // 用来存放要监控的对象，函数形式
  let oldValue; // 存放老值
  let cleanup; // 用于清理上一次watch操作的

  if (isReactive(source)) {
    /**
     * 若是传进来的是个ReactiveObj,
     * 则生成一个遍历访问的fn,供后续new ReactiveEffect(fn, scheduler)使用
     * 创建一个effect，让这个effect收集source中的所有属性
     */
    get = () => traversal(source);
  } else if (isFunction(source)) {
    // 若传进来的是一个函数则直接使用、
    get = source;
  }

  /**
   * onCleanup(fn),接收用户传入的方法作为参数，并赋值给cleanup
   */
  const onCleanup = fn => {
    cleanup = fn;
  };

  /**
   * scheduler方法，数据变化后调用
   */
  const job = () => {
    /**
     * 第一次执行时cleanup是undefined
     * 如果cleanup有值，则是上一次赋值的
     * 所以这里的cleanup是上一次的，利用了的闭包原理
     */
    cleanup && cleanup();

    // 数据变化后重新调用effect.run函数，会获得最新的值
    let newValue = effect.run();

    // 执行用户传进来的回调，并传入参数
    cb(newValue, oldValue, onCleanup);

    // 回调执行完之后，将这一次执行的新值赋值给oldValue
    oldValue = newValue;
  };

  const effect = new ReactiveEffect(get, job);

  if (immediate) {
    // 需要立即执行，则立刻执行任务
    job();
  }

  // 默认调用run方法会执行get函数，此时source作为了第一次的老值（get的返回值是source）
  oldValue = effect.run();
}

```

`watch`实现的核心在于利用了`effect`的实现原理

```typescript
 const effect = new ReactiveEffect(get, job);
```

创建了一个`effect`，完成对`watch`中使用到的`attir`依赖收集，并对用户传入的回调进行封装，封装后的方法作为`scheduler`方法，用于数据变化后调用

上面实现中还有一个关键的地方，`cleanup`的实现

可以看下`cleanup`的使用场景

<!--连续触发watch时需要清理之前的watch操作-->

```js
const state = reactive({ age: 30 })
let i = 2000;
function getData(timer){
    return new Promise((resolve,reject)=>{
        setTimeout(() => {
            resolve(timer)
        }, timer);
    })
}
watch(()=>state.age,async (newValue,oldValue,onCleanup)=>{
    let clear = false;
    onCleanup(()=>{
        clear = true;
    })
    i-=1000;
    let r =  await getData(i); // 第一次执行1s后渲染1000， 第二次执行0s后渲染0， 最终应该是0
    if(!clear){document.body.innerHTML = r;}
 
},{flush:'sync'});

state.age = 31;
state.age = 32;
```

用户传入的`onCleanup`是在下一次`watch`触发时才执行的，所以可以利用`onCleanup`完成一些取消上一次请求结果等类似的操作

### 2.7、`ref`的实现

`ref`接受一个参数值并返回一个响应式且可改变的 `ref` **对象**，`ref` **对象**拥有一个指向内部值的单一属性 `value`

```html
// packages/reactivity/dist/09、ref使用.html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="../../../node_modules/@vue/reactivity/dist/reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, ref } = VueReactivity;

    // 基本类型，不具备响应式能力, 用ref将基本类型变成对象类型，具备响应式能力
    let flag = ref(false);
    let obj = ref({ name: '张三' })

    effect(() => {
      console.log('runner')
      app.innerHTML = flag.value + obj.value.name
    })

    setTimeout(() => {
     // 改value的时候可以触发effect重新执行
      flag.value = true;
      obj.value.name = '李四'
    }, 1000)

  </script>
</body>

</html>
```

`ref` 跟 `reactive` 都是响应系统的核心方法，作为整个系统的入口

可以将 `ref` 看成 `reactive` 的一个变形版本，这是由于 `reactive` 内部采用 `Proxy` 来实现，而 `Proxy` 只接受对象作为入参，这才有了 `ref` 来解决基础类型的数据响应，如果传入 `ref` 的是一个对象，内部也会调用 `reactive` 方法进行深层响应转换

#### 2.7.1、`ref`实现

`ref`的实现如下👇

```typescript
// packages/reactivity/src/ref.ts

import { isObject } from '@vue/shared';
import { activeEffect, trackEffects, triggerEffects } from './effect';
import { reactive } from './reactive';

/**
 * 用于将对象转换成ReactiveObj
 */
export function toReactive(value) {
  return isObject(value) ? reactive(value) : value;
}

/**
 * 对传入进来的基础类型数据、对象进行代理到value属性上
 * (用到的其实是defineProperty方法)
 * (es6 class中的get、set编译成es5的话就是defineProperty)
 * 并对value属性设置响应式逻辑
 * get时收集依赖 trackEffects
 * set时触发更新 triggerEffects
 */
class RefImpl {
  private _value;
  private dep;
  private __v_isRef = true;
  constructor(public rawValue, public _shallow) {
    // 浅ref不需要再次代理
    this._value = _shallow ? rawValue : toReactive(rawValue);
  }

  get value() {
    if (activeEffect) {
      trackEffects(this.dep || (this.dep = new Set())); // 收集依赖
    }
    return this._value;
  }

  set value(newVal) {
    if (newVal !== this.rawValue) {
      this.rawValue = newVal; // rawValue为原始数据，会保留在ref对象上
      this._value = this._shallow ? newVal : toReactive(newVal);
      triggerEffects(this.dep); // 触发更新
    }
  }
}

/**
 * 将原始数据进行装包，转变成响应式数据
 */
function createRef(rawValue, shallow) {
  return new RefImpl(rawValue, shallow);
}

/**
 * 将原始类型包装成对象, 同时也可以包装对象 进行深层代理
 */
export function ref(value) {
  return createRef(value, false);
}

/**
 * 创建浅ref 不会进行深层代理
 */
export function shallowRef(value) {
  return createRef(value, true);
}
```

`ref`的实现中核心逻辑是将用户传入的`rawValue`，挂在`ref`对象(`RefImpl`实例)的`value`属性上，并在`value`属性的`get`、`set`上完成响应式的逻辑

<!--ref的作用就是将不是响应式的数据变成响应式的-->

#### 2.7.2、 `toRef` & `toRefs`实现

先看一个响应式丢失现象

```js
const { effect, reactive } = VueReactivity;
const state = reactive({name: '张三', age: 30 })
let person = {...state}
effect(()=>{
    document.body.innerHTML = person.name +'今年' + person.age +'岁了'
})
setTimeout(()=>{
    person.age = 31;
},1000)
```

如果对`ReacttiveObj`进行解构操作则会丢失响应式的特性，这是因为对对响应式对象进行解构，相当于是进行了浅拷贝，那在`effect`中使用浅拷贝的对象时是走不到`ReacttiveObj`的`get`中的，那也就不会进行依赖收集（其实不光没有收集，修改数据之后也不会走到`set`，也就是不会走`trigger`）

> <!--解构时浅拷贝，所以嵌套的对象依然具备响应式特性-->
>
> ```js
> const { effect, reactive } = VueReactivity;
> 
> const state = reactive({ address: { num: 199 } })
> let person = { ...state }
> 
> effect(() => {
>   document.body.innerHTML = person.address.num
> })
> 
> setTimeout(() => {
>   person.address.num = 888 // 会触发更新，重新执行effect
> }, 1000)
> ```

为了解决这一问题，Vue提供`toRef` & `toRefs`这两个api，下面看下具体实现👇

```typescript
// packages/reactivity/src/ref.ts

/**
 * 对传入进来的ReactiveObj进行代理,将ReactiveObj[key]挂到value属性上
 * 这里不需要做响应式逻辑，因为ReactiveObj[key]本身就有响应式特性
 * 这里只是完成对ReactiveObj 的 attr的使用而已
 * 会走到ReactiveObj Proxy中的get和set
 */
class ObjectRefImpl {
  private __v_isRef = true;
  constructor(public object, public key) {}
  get value() {
    return this.object[this.key];
  }
  set value(newValue) {
    this.object[this.key] = newValue;
  }
}

export function toRef(object, key) {
  return new ObjectRefImpl(object, key);
}

/**
 * 遍历object，每个属性都生成一个ref
 */
export function toRefs(object) {
  let result = {};
  for (let key in object) {
    result[key] = toRef(object, key);
  }
  return result;
}
```

实现的逻辑很简单，响应式丢失是因为使用的是新变量，没有直接使用`ReactiveObj`，那做一层代理，通过`ref.value`直接访问`ReactiveObj`便可以了

有了 `toRef` & `toRefs`便可以随意使用结构操作了

#### 2.7.3、`proxyRefs`实现

以上三个API`ref`、 `toRef` 、 `toRefs`，在使用`ref`对象时，都需要这样使用`ref.value`，这样未免有些不够直观，若是能够直接`ref[key]`岂不是更好，看下面👇实现

```typescript
/**
 * 做一层代理，若是ref对象，则直接使用value属性
 */
export function proxyRefs(object) {
  return new Proxy(object, {
    get(target, key, receiver) {
      let r = Reflect.get(target, key, receiver);
      return r.__v_isRef ? r.value : r;
    },
    set(target, key, value, receiver) {
      if (target[key].__v_isRef) {
        target[key].value = value;
        return true;
      }
      return Reflect.set(target, key, value, receiver);
    }
  });
}
```

实现很简单，就是帮我们省掉访问`value`这一步

看使用效果

```js
const { effect, reactive, ref, toRef, proxyRefs } = VueReactivity;

const state = reactive({ name: '张三', age: 30 })
let nameRef = toRef(state, 'name') // 使用value访问

let ageRef = proxyRefs({ age: toRef(state, 'age') }) // 使用key访问


effect(() => {
  console.log('runner')
  document.body.innerHTML = nameRef.value + '今年' + ageRef.age + '岁了'
})

setTimeout(() => {
  nameRef.value = '李四'
  ageRef.age = 31;
}, 1000)
```

### 三、Vue3响应式原理总结

- `reactive`适用于对象的响应式处理，非对象不能使用，因为不是对象的不能被proxy代理
- `ref` 、`toRef` 、`toRefs` 适用于非对象类型数据的响应式处理（对象也可以），取值要使用`ref.value`的形式， 若不想使用`ref.value`可以采用`proxyRefs`代理取值.
- `computed` 、 `watch` 都是基于`ReactiveEffect`
  - `computed`中是具备缓存的`dirty`, 依赖的值变化了会执行`effect`并更新`dirty`属性（ 计算属性会收集依赖）
  - `watch` 就是数据变化了触发内部的`scheduler`，提供`onCleanup`可以用来清理上次`watch`操作

