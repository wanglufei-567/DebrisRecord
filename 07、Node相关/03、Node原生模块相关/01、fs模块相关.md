## Node基本使用—fs模块

### 一、概述

**Node.js** 中的 `fs` 模块（**File System** 模块）是==用于文件系统操作==的核心模块之一

`fs` 模块提供了一系列的方法，可以用于执行文件的==读取==、==写入==、==删除==、==修改==、==重命名==等操作

通过 `fs` 模块，可以直接与文件系统进行交互，读写文件内容，以及处理文件和目录

### 二、基础使用

#### 2.1、文件读取和写入

- 文件读取

  - **「异步读取」**文件的内容：

    语法：

    ```javascript
    fs.readFile(path[, options], callback)
    ```

    示例：

    ```javascript
    let fs = require("fs");
    // 通过回调处理读取结果
    fs.readFile("1.txt",(err,data)=>{
        if(err){
            return console.log(err);
        }
        console.log(data.toString());
    })
    ```

  - **「同步读取」**文件的内容：

    语法：

    ```js
    fs.readFileSync(path[, options])
    ```

    示例：

    ```js
    let fs = require("fs");
    // 
    let res = fs.readFileSync("1.txt");
    console.log(res.toString());
    ```

- 文件写入

  - **「异步写入」**文件的内容：

    语法：

    ```javascript
    fs.writeFile(file, data[, options], callback)
    ```

    示例：

    ```js
    let fs = require("fs");
    
    // flag配置  
    // "a":追加写入
    // "w":写入
    // "r":读取
    fs.writeFile("2.txt", "我是要写入的内容", {flag:"w"}, err=>{
        if(err){
            return console.log(err);
        }
        console.log("写入成功");   
    })
    ```

  - **「同步写入」**文件的内容：

    语法：
    
    ```javascript
    fs.writeFileSync(file, data[, options])
    ```
    
    示例：
    
    ```js
    //复制文件：先读取文件再写入文件
    function mycopy(src, target){
       fs.writeFileSync(target, fs.readFileSync(src));
    }
    mycopy("1.txt","4.txt");
    ```

需要注意 ⚠️ 的是，`fs` 模块中的==绝大多数方法都有**「异步」**和**「同步」**两种版本==

- **异步方法使用回调函数来处理结果**
- **同步方法直接返回结果**

<!--通常建议使用异步方法，以避免阻塞主线程-->

#### 2.2、删除文件和目录

- **「异步删除」**文件或目录

  语法：

  ```javascript
  fs.rm(path[, options], callback)
  ```

  - `path`  ：要删除的文件或目录路径

  - `options` (对象，可选)：
    - `recursive` (布尔值)：用于指定是否递归删除目录及其内容
      - 设置为 `false` 或不设置，将仅删除空目录
      - 设置为 `true` 时，递归删除目录及其所有子目录和文件
    - `force` (布尔值)：强制删除，即使没有足够的权限（类似于 `rm -f` 命令）
  - `callback` (函数)：一个回调函数，回调有两个参数：`err` 和 `stats`（删除操作完成后）

  示例：删除文件

  ```javascript
  const fs = require('fs');
  
  fs.rm('/path/to/file.txt', (err) => {
    if (err) {
      console.error('删除文件失败:', err);
    } else {
      console.log('文件已删除');
    }
  });
  ```

  示例：删除目录

  ```javascript
  const fs = require('fs');
  
  // 删除空目录
  fs.rm('/path/to/empty-directory', (err) => {
    if (err) {
      console.error('删除空目录失败:', err);
    } else {
      console.log('空目录已删除');
    }
  });
  
  // 删除非空目录（递归删除）
  fs.rm('/path/to/non-empty-directory', { recursive: true }, (err) => {
    if (err) {
      console.error('删除非空目录失败:', err);
    } else {
      console.log('非空目录及其内容已删除');
    }
  });
  ```

- **「同步删除」**文件或目录

  语法：

  ```javascript
  fs.rmSync(path[, options])
  ```

  - `path`  ：要删除的文件或目录路径

  - `options` (对象，可选)：
    - `recursive` (布尔值)：用于指定是否递归删除目录及其内容
      - 设置为 `false` 或不设置，将仅删除空目录
      - 设置为 `true` 时，递归删除目录及其所有子目录和文件
    - `force` (布尔值)：强制删除，即使没有足够的权限（类似于 `rm -f` 命令）

  示例：删除文件

  ```javascript
  const fs = require('fs');
  
  try {
    fs.rmSync('/path/to/file.txt');
    console.log('文件已删除');
  } catch (err) {
    console.error('删除文件失败:', err);
  }
  ```

  示例：删除目录

  ```javascript
  const fs = require('fs');
  
  try {
    fs.rmSync('/path/to/directory', { recursive: true });
    console.log('目录及其内容已删除');
  } catch (err) {
    console.error('删除目录失败:', err);
  }
  ```

#### 2.3、重命名或移动文件

- **「异步」**重命名或移动文件

  语法：

  ```javascript
  fs.rename(oldPath, newPath, callback)
  ```

  示例：

  ```js
  fs.rename("1.txt","5.txt",function (err) {
      if(err){
          console.log(err);
      }else{
          console.log("修改成功");
      }
  });
  ```

- **「同步」**重命名或移动文件

  语法：

  ```
  fs.renameSync(oldPath, newPath)
  ```

#### 2.4、其他操作

- 创建目录

  - 异步创建目录：`fs.mkdir(path[, options], callback)`


  - 同步创建目录：`fs.mkdirSync(path[, options])`


- 检查文件或目录是否存在
  - 检查文件或目录是否可访问：`fs.access(path, mode, callback)`
  
  - 同步地检查文件或目录是否可访问：`fs.accessSync(path, mode)`
  
- `fs.watchFile(filename[, options], listener)`：监视文件的变化
- `fs.unwatchFile(filename[, listener])`：停止监视文件的变化

### 三、文件读取写入与可读流可写流

「读取」和「写入」整个文件的方法 `fs.readFile` 和 `fs.writeFile` 与创建「可读流」和「可写流」的方法 `fs.createReadStream` 和 `fs.createWriteStream `都可以进行文件的**读写操作**

它们的区别如下👇：

- **读取、写入文件的方法 fs.readFile 和 fs.writeFile：**
- `fs.readFile(path[, options], callback)`：用于异步读取「整个文件」的内容并将其返回
    - 适用于**小型文件**，因为它将整个文件加载到内存中，并在读取完成后通过回调函数返回文件内容
  
  - `fs.writeFile(file, data[, options], callback)`：用于异步地将数据写入文件
  - 适用于**小型文件**，因为它将整个数据写入文件
    - 如果文件已经存在，会覆盖文件内容

- **创建可读流、可写流的方法 fs.createReadStream 和 fs.createWriteStream：**
- `fs.createReadStream(path[, options])`：创建一个可读流，用于从文件中读取数据
    - 适用于**大型文件**，**以「块」的形式「读取」数据**
  
  - `fs.createWriteStream(path[, options])`：创建一个可写流，用于向文件中写入数据
- 适用于**大型文件**，**以「块」的形式「写入」数据**

#### 3.1、可读/写流的特点

- **大文件读取/写入：** 当需要读取/写入大型文件时，使用可读流/可写流能够分块读取/写入文件内容，==避免将整个文件加载到内存中，从而节省内存资源==

- **高效性：** 由于可读/可写流以块的形式读取文件内容，能够更加高效地处理大型文件，尤其在网络传输或处理日志等场景下表现优秀

- **流式处理：** 可读/可写流可以与其他流（如`pipe`）配合使用，实现流式数据处理，使代码更易于理解和维护

- **异步处理：** 可读/可写流是基于事件的异步模式，可以利用回调或async/await 风格来处理读取的数据

  基本用法如下👇：

  ```js
  const fs = require('fs');
  
  // 输入文件路径
  const inputFilePath = 'input.txt';
  
  // 输出文件路径
  const outputFilePath = 'output.txt';
  
  // 创建可读流
  const readableStream = fs.createReadStream(inputFilePath);
  
  // 创建可写流
  const writableStream = fs.createWriteStream(outputFilePath);
  
  // 将读取到的数据块写入到输出文件
  readableStream.on('data', (chunk) => {
    writableStream.write(chunk);
  });
  
  // 当可读流结束时，关闭可写流
  readableStream.on('end', () => {
    writableStream.end();
  });
  
  // 处理错误
  readableStream.on('error', (err) => {
    console.error('Error while reading file:', err);
  });
  
  writableStream.on('error', (err) => {
    console.error('Error while writing file:', err);
  });
  ```

  或者👇

  ```js
  const fs = require('fs');
  
  // 异步函数，用于读取大型文件
  async function processLargeFile(filePath) {
    const readableStream = fs.createReadStream(filePath);
  
    // 使用 Buffer 临时存储数据
    const chunks = [];
    let totalSize = 0;
  
    // 使用 Promise 来等待数据读取完成
    await new Promise((resolve, reject) => {
      readableStream.on('data', (chunk) => {
        chunks.push(chunk);
        totalSize += chunk.length;
      });
  
      readableStream.on('end', () => {
        resolve(); // 数据读取完成时，解析 Promise
      });
  
      readableStream.on('error', (err) => {
        reject(err); // 处理错误时，拒绝 Promise
      });
    });
  
    // 将所有数据块拼接成一个完整的 Buffer
    const fileContentBuffer = Buffer.concat(chunks, totalSize);
  
    // 在此处可进行对文件内容的后续处理
    console.log(fileContentBuffer.toString());
    return fileContentBuffer;
  }
  
  // 使用 async/await 调用 processLargeFile
  (async () => {
    try {
      const filePath = 'largeFile.txt';
      const fileContentBuffer = await processLargeFile(filePath);
      // 可以继续在此处进行对 fileContentBuffer 的处理
    } catch (err) {
      console.error('Error while processing large file:', err);
    }
  })();
  ```

  

