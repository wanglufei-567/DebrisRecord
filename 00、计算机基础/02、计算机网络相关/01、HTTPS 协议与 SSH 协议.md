## HTTPS 协议与 SSH 协议

### 一、前言

- **SSH ** （**安全外壳协议**）是一种**加密**的**网络传输协议**，可在不安全的网络中网络服务提供安全的传输环境，它通过在网络中创建安全隧道来实现 **SSH 客户端**和**服务器**之间的连接
  
  - [深入了解SSH](https://blog.haojunyu.com/post/deep_ssh) 这篇文章写的比较详细
- **HTTPS**（**Hypertext Transfer Protocol Secure**）是 **HTTP 协议**的安全版本，它通过在 **HTTP** 协议上加入 **SSL/TLS** 协议，为数据传输提供加密和身份验证
  
  > **SSL**（**Secure Sockets Layer**）和 **TLS**（**Transport Layer Security**）是用于在计算机网络上提供安全通信的协议
  >
  > **TLS** 是 **SSL** 的升级版本，主要用于加密数据传输，确保数据的机密性和完整性
  >
  > **HTTPS（HyperText Transfer Protocol Secure）= HTTP + TLS/SSL 加密协议**，而在这个加密机制中，**CA 证书是实现 HTTPS 安全通信的核心组成部分之一**
  >
  > - **CA 证书**是由权威机构签发的数字证书，用于验证网站身份并提供加密所需的公钥
  > - **HTTPS** 通过使用 **CA 证书**，建立起客户端与服务器之间的加密通信和信任关系
  > - 没有合法的 **CA 证书**，**HTTPS** 无法被浏览器信任，通信也不安全
  
  - 通过 **HTTPS** 传输的数据是加密的，能够防止被窃听或篡改，从而确保数据的机密性和完整性

**SSH** 同 **HTTPS** 一样是一种协议，整个通信过程都是加密的，但二者存在一定的联系与区别

- **联系**
  1. **加密技术**：两者都使用加密技术来保护数据的传输安全
     - **SSH** 使用对称加密和非对称加密的结合
     - **HTTPS** 则使用 **SSL/TLS** 协议来实现加密
  2. **身份验证**：两者都提供身份验证机制
     - **SSH** 使用公钥和私钥进行身份验证
     - **HTTPS** 使用数字证书来验证服务器的身份 <!--CA 证书-->

- **区别**
  1. **应用场景**：
     - **SSH**：主要用于**远程登录**和**安全文件传输**，它允许用户在不安全的网络上安全地访问远程服务器，并执行命令行操作或文件传输
     - **HTTPS**：主要用于 **Web** 浏览器和 **Web** 服务器之间的安全通信，确保用户与网站之间的数据传输的机密性和完整性
  2. **协议层级**：
     - **SSH**：是一个独立的协议，直接在传输层上工作
     - **HTTPS**：是在 **HTTP** 协议上加入 **SSL/TLS** 加密层，工作在应用层
  3. 功能重点：
     - **SSH**：重点在于提供远程访问和文件传输的安全性
     - **HTTPS**：重点在于保护 **Web** 数据的机密性和完整性，防止中间人攻击

### 二、原理介绍

#### 2.1、对称加密

对称加密就是加密或解密使用的是**同一个秘钥**

![](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20220517084842.png)

对称加密的优缺点：

- 优点是加解密效率高，速度快

- 缺点是秘钥的管理和分发比较困难，不安全

#### 2.2、非对称加密

非对称加密需要**一对秘钥**来进行加密和解密，公开的秘钥叫公钥，私有的秘钥叫私钥

公钥加密的信息**只有**私钥才能解开（加密/解密过程），同样私钥加密的信息**只有**公钥才能解开（签名/验证过程）

![ssh_asymmetric](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/ssh_asymmetric.png)

非对称加密的优点是安全性更高，秘钥管理比较方便，每个服务器只要维护一对公私钥即可。缺点是加解密耗时长，速度慢

#### 2.3、加密/解密和签名/验证

非对称加密系统中的两个主要过程：

- **加密/解密**：

  - **加密**：==**发送方**使用**接收方**的**公钥加密**消息==，只有对应的私钥可以解密这个消息
- **解密**：==**接收方**使用**自己的私钥解密**消息==
  - **举例**：
  - 「客户端」想发送一条机密信息给 「服务端」
      - 「客户端」 使用 「服务端」 的公钥加密消息
      - 「服务端」 使用自己的私钥解密消息，读取内容
  
   <!-- 单项 https 认证的场景中，客户端就是用这个过程将自己的随机密钥（对称密钥）提供给服务端用于后续的对称加密-->

- **签名/验证**：

  - **签名**：==**发送方**使用**自己的私钥**对消息进行**签名**==，这创建了一个独特的签名，证明消息确实来自发送方，并且未被篡改

  - **验证**：==**接收方**使用**发送方**的**公钥验证签名**==，确保消息的真实性和完整性

    - **示例**：
      - **「服务端」 生成签名**：
        - 原始消息：`"Hello, Bob"`

        - 哈希处理后得到的消息摘要（假设是）：`h1`

        - 使用 「服务端」 的私钥加密 `h1`，得到数字签名 `s`

        - 「服务端」 发送的内容包括原始消息 `"Hello, Bob"` 和签名 `s`

      - **「客户端」 验证签名**：
        - 「客户端」 收到消息 `"Hello, Bob"` 和签名 `s`
  
        - 「客户端」 使用 「服务端」 的公钥解密 `s`，得到解密后的消息摘要 `h1`
  
        - 「客户端」 对收到的原始消息 `"Hello, Bob"` 进行哈希处理，得到消息摘要 `h2`
  
        - 比较 `h1` 和 `h2`，如果相同，说明消息未被篡改，且确实来自 「服务端」
  

    <!--单项 https 认证的场景中，服务端就是利用这个过程将自己的私钥签名提供给客户端，客户端通过 CA 证书的公钥进行解密，从而确认服务端是可信任的-->

  - **关键点**：
  
    - **公钥解密签名**：这是为了确保签名确实是用对应的私钥生成的，因为只有 「服务端」 的私钥能生成能被 「服务端」 的公钥正确解密的签名
    - **消息哈希比较**：这是为了确保消息未被篡改，因为哈希函数的任何微小改变都会导致完全不同的哈希值

#### 2.4、中间人攻击

中间人攻击（**Man-in-the-Middle Attack**，**MITM**）是一种网络攻击形式，指==攻击者与通讯的两端分别创建独立的联系==，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制

在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）

其具体的时序图如下：

![ssh_mitm.png](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240608084126.png)

### 三、为何 HTTPS 能够防止中间人攻击

**HTTPS** 通过以下几个步骤来防止中间人攻击：

1. **数字证书和身份验证**：
   - 服务器在与客户端建立连接时，会提供一个由受信任的证书颁发机构（**CA**）签发的数字证书
   - **客户端**会**验证**这个**证书的有效性**，确保连接的是合法的服务器，而不是中间人
   - 中间人无法伪造受信任的证书，因为只有受信任的 **CA** 才能签发有效的证书
2. **SSL/TLS 握手过程**：
   - 在握手过程中，客户端和服务器会协商生成一个对称密钥，用于后续的数据加密传输 <!--非对称加密交换对称加密的密钥-->
   - 这个对称密钥是通过非对称加密安全地交换的，中间人无法解密这个密钥
3. **数据加密和完整性**：
   - ==一旦握手完成，所有的数据传输都会使用**对称加密**进行加密==，确保数据在传输过程中不会被窃听
   - 同时 **HTTPS** 使用消息认证码（**MAC**）来确保数据的完整性，防止数据被篡改

```markdown
示例：客户端加密消息给服务器（典型 HTTPS 初期流程）

1. 客户端只需要知道 **服务器公钥**（通过证书获取）
2. 客户端用服务器公钥加密随机密钥（对称密钥）
3. 服务器用私钥解密得到随机密钥
4. 后续数据使用对称加密

结论：客户端只需要服务器公钥，服务器不需要客户端公钥
```

#### 3.1、TCP 三次握手和SSL/TLS 握手过程

**TCP 三次握手**是建立 **TCP** 连接的过程，确保客户端和服务器之间的连接是可靠的

具体步骤如下：

1. **SYN**：客户端发送一个 **SYN**（同步）包给服务器，表示请求建立连接
2. **SYN-ACK**：服务器收到 **SYN** 包后，回复一个 **SYN-ACK**（同步-确认）包，表示同意建立连接
3. **ACK**：客户端收到 **SYN-ACK** 包后，发送一个 **ACK**（确认）包，表示连接建立成功

**SSL/TLS 握手过程**是在 **TCP** 连接建立之后进行的，用于建立安全的加密通信通道

<!-- SSL/TLS 整个加密协商过程就是一次 SSL/TLS  握手，不会称为多次握手-->

具体步骤如下：

1. **客户端问候**：客户端发送一个 **ClientHello** 消息，包含**支持的**加密算法和随机数
2. **服务器问候**：服务器回复一个 **ServerHello** 消息，包含**选择的**加密算法和随机数
3. **服务器证书**：服务器发送其**数字证书**，客户端验证证书的有效性
4. **密钥交换**：客户端生成一个随机的对称密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器
5. **完成握手**：服务器使用私钥解密得到对称密钥，双方使用这个对称密钥进行加密通信

**关系和区别：**

- **关系**：**SSL/TLS** 握手过程是在 **TCP** 三次握手之后进行的
  - 也就是说，首先通过 **TCP** 三次握手建立可靠的连接，然后再通过 **SSL/TLS** 握手建立安全的加密通道

- 区别：

  - **目的不同**：**TCP** 三次握手的目的是建立可靠的连接，而 **SSL/TLS** 握手的目的是建立安全的加密通信通道
  - **步骤不同**：**TCP** 三次握手只有三个步骤，而 **SSL/TLS** 握手过程更复杂，涉及**加密算法协商**、**证书验证**和**密钥交换**等多个步骤

<!--写在后面，就目前的了解，我认为SSH协议和HTTPS协议在建立网络会话这里的流程是一致的，都是先协商协议版本和加密算法的类型，之后就是非对称加密和对称加密，整个通话过程都是采用对称加密的方式进行数据交换。当然以上的认知肯定是片面的，这两种协议必然是在某一些细节处是不一样的，现在知道就有HTTPS有CA证书认证环节。网络相关的知识的深入学习任重道远，当下先囫囵吞枣的学下，后面再有针对性的系统学习下，学到什么程度呢？有个不错的标准，就是计算机考研的专业课的程度-->

