## 状态机

### 一、什么是状态机

现实中事物是有不同「状态」的，例如一个自动门，就有 **「open」** 和 **「closed」** 两种「状态」

我们通常所说的**「状态机」**是**「有限状态机」**，也就是==被描述的事物的状态的数量是有限个==

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20230412141512329.png" alt="image-20230412141512329" style="zoom:40%;" />

**状态机（State Machine**），也被称为**有限状态自动机（Finite-state automaton简称FSA）**，是一种数学模型，用于描述系统或程序在离散时间内==从一个状态转移到另一个状态==的行为，它由一组**「状态」**、**「转移规则」**和**「可能的输入」**组成，可以用来描述复杂的逻辑和控制流程

**「自动」**两个字也是包含重要含义的，给定一个状态机，同时给定它的**「当前状态」**以及**「输入」**，那么**「输出状态」**是可以明确的运算出来的，例如：对于自动门，给定初始状态 **closed** ，给定输入"**开门**"，那么**下一个状态**是可以运算出来的

### 二、状态机的组成

**状态机**一般由以下几个部分组成：

1. **状态（States**）： <!--状态集合：系统可能处于的所有状态的集合-->
   - 状态是系统或程序在**特定时刻**的某种状态或条件

   - 状态可以是离散的
     - 例如 "开始"、"进行中"、"完成" 等，也可以是连续的
     - 例如温度、速度等。状态通常用字符串、枚举、数值等方式进行表示

2. **转移规则（Transitions**）：
   - 转移规则描述了在不同状态之间的**转移条件和动作**
      - 它定义了==在特定条件下从一个状态切换到另一个状态的行为==
        - 转移规则可以是简单的 `if/else` 逻辑，也可以是复杂的条件逻辑、事件触发等

3. **输入（Inputs）**：
   - 输入是触发状态转移的**外部事件**、**信号或条件**
      - 输入可以来自用户输入、传感器信号、网络消息等
      - 状态机通过输入来触发不同的状态转移规则，从而改变系统的状态

4. **动作（Actions）**：
   - ==动作是**状态转移过程**中执行的**具体操作或行为**==
      - 动作可以是更新状态、调用函数、发送消息等
      - 动作通常与转移规则相结合，定义了状态转移时应该执行的具体操作

5. **初始状态（Initial State）**：
   - 初始状态是状态机的起始状态，它表示系统或程序在开始时的初始状态
   - 状态机从初始状态开始，并通过输入和转移规则来不断改变当前状态
6. **终止状态（Final State）**：
   - 终止状态是状态机的结束状态，它表示系统或程序在某个条件下终止或结束的状态
   - 状态机可以在终止状态下停止运行或等待新的输入

这些部分一起构成了状态机的基本组成，并通过**状态**、**转移规则**、**输入**和**动作**之间的交互来描述系统或程序的行为

状态机可以用于建模和管理复杂的逻辑和控制流程，并在编程中实现各种应用场景，例如游戏、业务流程、协议处理等

### 三、具体实现

在 **JavaScript** 中，状态机可以通过对象和函数来实现

#### 3.1、简单状态机实现 - 交通信号灯

下面是一个简单的状态机示例，用于模拟一个交通信号灯的状态：

```js
// 定义一个交通信号灯状态机
const TrafficLightStateMachine = {
  currentState: "red",  // 初始状态为红灯
  transition: function() {  // 转移函数
    switch (this.currentState) {
      case "red":
        console.log("红灯，停车");
        this.currentState = "green";
        break;
      case "green":
        console.log("绿灯，行驶");
        this.currentState = "yellow";
        break;
      case "yellow":
        console.log("黄灯，准备停车");
        this.currentState = "red";
        break;
      default:
        console.log("无效状态");
    }
  },
  changeState: function() {  // 改变状态的方法
    this.transition();
  }
};

// 使用状态机模拟交通信号灯的行为
TrafficLightStateMachine.changeState();  // 输出：红灯，停车
TrafficLightStateMachine.changeState();  // 输出：绿灯，行驶
TrafficLightStateMachine.changeState();  // 输出：黄灯，准备停车
```

在这个例子中，`TrafficLightStateMachine` 对象表示了一个交通信号灯的状态机，包含了当前状态和转移函数。

- 状态机的**「初始状态」**为红灯，通过调用 `changeState` 方法，可以模拟交通信号灯的状态转移行为，输出对应的状态信息

- **「转移函数」**使用 `switch` 语句根据当前状态判断下一个状态，并更新当前状态

  <!--这个很关键，这也是为什么状态机被称为有限状态自动机的精髓，有了当前状态和输入，状态机器会自动更新当前状态为下一状态-->

#### 3.2、标准状态机实现 - 订单处理系统

下面是一个更加标准和经典的状态机实现，用于模拟电商订单的处理流程：

**通用状态机框架实现：**

```javascript
// 标准状态机类的实现
class StateMachine {
  constructor(initialState, states, transitions) {
    this.currentState = initialState;
    this.states = states;           // 状态定义
    this.transitions = transitions; // 转移规则
    this.history = [];              // 状态历史记录
  }

  // 获取当前状态
  getCurrentState() {
    return this.currentState;
  }

  // 获取当前状态的信息
  getStateInfo() {
    return this.states[this.currentState];
  }

  // 处理输入事件，触发状态转移
  handleEvent(event, payload = {}) {
    const currentStateTransitions = this.transitions[this.currentState];

    if (!currentStateTransitions || !currentStateTransitions[event]) {
      console.warn(`无效的状态转移: ${this.currentState} -> ${event}`);
      return false;
    }

    const transition = currentStateTransitions[event];
    const previousState = this.currentState;

    // 执行转移前的动作（可选）
    if (transition.beforeAction) {
      transition.beforeAction(payload);
    }

    // 状态转移
    this.currentState = transition.to;

    // 记录状态历史
    this.history.push({
      from: previousState,
      to: this.currentState,
      event: event,
      timestamp: new Date(),
      payload: payload
    });

    // 执行转移后的动作（可选）
    if (transition.afterAction) {
      transition.afterAction(payload);
    }

    // 执行进入新状态的动作
    if (this.states[this.currentState].onEnter) {
      this.states[this.currentState].onEnter(payload);
    }

    console.log(`状态转移: ${previousState} --[${event}]--> ${this.currentState}`);
    return true;
  }

  // 获取可用的事件
  getAvailableEvents() {
    const currentStateTransitions = this.transitions[this.currentState];
    return currentStateTransitions ? Object.keys(currentStateTransitions) : [];
  }

  // 获取状态历史
  getHistory() {
    return this.history;
  }
}
```

**订单状态机实现：**

```js
// 订单状态机的具体实现
class OrderStateMachine extends StateMachine {
  constructor(orderId) {
    // 定义所有可能的状态
    const states = {
      'pending': {
        name: '待支付',
        description: '订单已创建，等待用户支付',
        onEnter: (payload) => console.log(`订单 ${orderId} 创建成功，等待支付`)
      },
      'paid': {
        name: '已支付',
        description: '订单已支付，等待发货',
        onEnter: (payload) => console.log(`订单 ${orderId} 支付成功，金额：￥${payload.amount || 0}`)
      },
      'shipped': {
        name: '已发货',
        description: '订单已发货，等待收货',
        onEnter: (payload) => console.log(`订单 ${orderId} 已发货，快递单号：${payload.trackingNumber || 'N/A'}`)
      },
      'delivered': {
        name: '已送达',
        description: '订单已送达，等待确认收货',
        onEnter: (payload) => console.log(`订单 ${orderId} 已送达`)
      },
      'completed': {
        name: '已完成',
        description: '订单已完成',
        onEnter: (payload) => console.log(`订单 ${orderId} 交易完成`)
      },
      'cancelled': {
        name: '已取消',
        description: '订单已取消',
        onEnter: (payload) => console.log(`订单 ${orderId} 已取消，原因：${payload.reason || '用户取消'}`)
      },
      'refunded': {
        name: '已退款',
        description: '订单已退款',
        onEnter: (payload) => console.log(`订单 ${orderId} 已退款，金额：￥${payload.refundAmount || 0}`)
      }
    };

    // 定义状态转移规则
    const transitions = {
      'pending': {
        'pay': {
          to: 'paid',
          beforeAction: (payload) => console.log('正在处理支付...'),
          afterAction: (payload) => console.log('支付处理完成')
        },
        'cancel': {
          to: 'cancelled',
          beforeAction: (payload) => console.log('正在取消订单...')
        }
      },
      'paid': {
        'ship': {
          to: 'shipped',
          beforeAction: (payload) => console.log('正在安排发货...'),
          afterAction: (payload) => console.log('发货安排完成')
        },
        'refund': {
          to: 'refunded',
          beforeAction: (payload) => console.log('正在处理退款...')
        }
      },
      'shipped': {
        'deliver': {
          to: 'delivered',
          beforeAction: (payload) => console.log('货物送达中...')
        }
      },
      'delivered': {
        'confirm': {
          to: 'completed',
          beforeAction: (payload) => console.log('用户确认收货...')
        },
        'return': {
          to: 'refunded',
          beforeAction: (payload) => console.log('处理退货申请...')
        }
      }
    };

    // 调用父类构造函数，初始状态为 'pending'
    super('pending', states, transitions);
    this.orderId = orderId;
  }

  // 订单特有的方法
  getOrderStatus() {
    const stateInfo = this.getStateInfo();
    return {
      orderId: this.orderId,
      currentState: this.getCurrentState(),
      stateName: stateInfo.name,
      description: stateInfo.description,
      availableActions: this.getAvailableEvents()
    };
  }

  // 检查是否可以执行某个操作
  canPerformAction(action) {
    return this.getAvailableEvents().includes(action);
  }
}
```

**使用示例：**

```javascript
// 使用示例
console.log('=== 订单状态机演示 ===');

// 创建一个订单状态机实例
const order = new OrderStateMachine('ORD-20231201-001');

// 查看初始状态
console.log('\n1. 初始状态：');
console.log(order.getOrderStatus());

// 模拟订单处理流程
console.log('\n2. 用户支付：');
order.handleEvent('pay', { amount: 299.99, paymentMethod: '支付宝' });

console.log('\n3. 商家发货：');
order.handleEvent('ship', { trackingNumber: 'SF1234567890' });

console.log('\n4. 快递送达：');
order.handleEvent('deliver');

console.log('\n5. 用户确认收货：');
order.handleEvent('confirm');

console.log('\n6. 最终状态：');
console.log(order.getOrderStatus());

console.log('\n7. 状态转移历史：');
console.log(order.getHistory());

// 演示错误处理
console.log('\n8. 尝试无效操作：');
order.handleEvent('cancel'); // 这会失败，因为已完成的订单不能取消

// 额外测试：创建另一个订单进行退款流程测试
console.log('\n\n=== 退款流程测试 ===');
const order2 = new OrderStateMachine('ORD-20231201-002');

console.log('\n1. 支付订单：');
order2.handleEvent('pay', { amount: 199.99, paymentMethod: '微信支付' });

console.log('\n2. 申请退款：');
order2.handleEvent('refund', { refundAmount: 199.99, reason: '不喜欢' });

console.log('\n3. 退款订单最终状态：');
console.log(order2.getOrderStatus());

```

打印结果：

```markdown
=== 订单状态机演示 ===

1. 初始状态：
{
  orderId: 'ORD-20231201-001',
  currentState: 'pending',
  stateName: '待支付',
  description: '订单已创建，等待用户支付',
  availableActions: [ 'pay', 'cancel' ]
}

2. 用户支付：
正在处理支付...
支付处理完成
订单 ORD-20231201-001 支付成功，金额：￥299.99
状态转移: pending --[pay]--> paid

3. 商家发货：
正在安排发货...
发货安排完成
订单 ORD-20231201-001 已发货，快递单号：SF1234567890
状态转移: paid --[ship]--> shipped

4. 快递送达：
货物送达中...
订单 ORD-20231201-001 已送达
状态转移: shipped --[deliver]--> delivered

5. 用户确认收货：
用户确认收货...
订单 ORD-20231201-001 交易完成
状态转移: delivered --[confirm]--> completed

6. 最终状态：
{
  orderId: 'ORD-20231201-001',
  currentState: 'completed',
  stateName: '已完成',
  description: '订单已完成',
  availableActions: []
}

7. 状态转移历史：
[
  {
    from: 'pending',
    to: 'paid',
    event: 'pay',
    timestamp: 2025-06-27T01:56:25.675Z,
    payload: { amount: 299.99, paymentMethod: '支付宝' }
  },
  {
    from: 'paid',
    to: 'shipped',
    event: 'ship',
    timestamp: 2025-06-27T01:56:25.676Z,
    payload: { trackingNumber: 'SF1234567890' }
  },
  {
    from: 'shipped',
    to: 'delivered',
    event: 'deliver',
    timestamp: 2025-06-27T01:56:25.676Z,
    payload: {}
  },
  {
    from: 'delivered',
    to: 'completed',
    event: 'confirm',
    timestamp: 2025-06-27T01:56:25.676Z,
    payload: {}
  }
]

8. 尝试无效操作：
无效的状态转移: completed -> cancel


=== 退款流程测试 ===

1. 支付订单：
正在处理支付...
支付处理完成
订单 ORD-20231201-002 支付成功，金额：￥199.99
状态转移: pending --[pay]--> paid

2. 申请退款：
正在处理退款...
订单 ORD-20231201-002 已退款，金额：￥199.99
状态转移: paid --[refund]--> refunded

3. 退款订单最终状态：
{
  orderId: 'ORD-20231201-002',
  currentState: 'refunded',
  stateName: '已退款',
  description: '订单已退款',
  availableActions: []
}
```

这个标准状态机实现展示了状态机的所有核心概念：

1. **完整的状态定义**：

   - 每个状态都有名称、描述和进入时的动作
   - 状态信息结构化存储

2. **详细的转移规则**：

   - 定义了从每个状态可以转移到哪些状态

   - 包含转移前后的动作执行

   - 支持传递参数给动作函数

3. **事件驱动的输入处理**：

   - 通过 `handleEvent` 方法处理外部输入
   - 自动验证状态转移的合法性
   - 支持携带额外数据

4. **动作执行机制**：

   - `beforeAction`：转移前执行的动作
   - `afterAction`：转移后执行的动作
   - `onEnter`：进入新状态时执行的动作

5. **状态历史记录**：

   - 记录每次状态转移的详细信息
   - 包含时间戳和传递的参数
   - 便于调试和审计

6. **辅助功能**：

   - 获取当前可用的操作
   - 检查特定操作是否可执行
   - 获取状态详细信息


这个实现遵循了状态机的经典设计原则，具有良好的**封装性**、**可扩展性**和**可维护性**，是工业级状态机实现的标准范例

### 四、**策略模式**和**状态模式**的区别

- **策略模式**和**状态模式**都有**==上下文==**，**有环境类或者状态类**，上下文把这些请求委托给这些类来执行
  - 策略模式是由上下文来选择执行何种策略 <!--上下文类-->
  - 状态模式是由上下文来决定下一状态和执行何种行为动作 <!--转移规则-->
- 策略模式中各个类是**「平等」**的，没有关系，客户端需要知道算法**「主动切换」**
  - 每个策略是独立的，不同策略之间是没有关系的
- 状态模式中，**状态的切换和行为被封装好了，会「自动切换和执行」**，客户不需要了解细节
  - 状态之间是关联的，状态的转移是需要上一状态+输入信号才能完成
