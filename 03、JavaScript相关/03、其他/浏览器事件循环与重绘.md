## 浏览器事件循环与重绘

在浏览器中，「一帧」的时间（通常为 `16.67ms`，基于 `60fps` 的刷新率）内会发生许多操作，理解这些操作对于优化网页性能至关重要

以下是浏览器「事件循环」、「渲染阶段」（包括计算样式、布局和重绘），以及 `requestAnimationFrame` 和 `requestIdleCallback` 等 **API** 在浏览器「一帧」内的执行时机的详细描述

### 1、浏览器事件循环与重绘的总体概述
浏览器的事件循环可以分为以下几个阶段：
   - **宏任务（Macro Task）队列**：包括用户交互事件、网络请求、`setTimeout` 和 `setInterval` 等异步任务，任务执行完毕后可能会触发 **DOM** 操作
   - **微任务（Micro Task）队列**：通常==在每个宏任务完成后立即执行==，微任务通常包括 `Promise.then`、`MutationObserver` 等
   - **渲染（Rendering）阶段**：浏览器在每帧的「渲染阶段」执行一系列绘制操作，包括样式计算、布局（**Layout**）、绘制（**Paint**）等

浏览器会在完成一个宏任务队列的执行后，清空微任务队列，并开始渲染阶段

- 如果渲染需要更新（例如有 **DOM** 操作或样式变化）则进入「渲染阶段」
  - 如果某些步骤在一帧内不能完成，浏览器可能会跳过这「一帧」，以维持平稳的帧率

- 如果一次宏任务和微任务中都没有引起 **DOM** 改变，也没有触发任何页面更新（如样式或布局的修改），浏览器将**==跳过渲染阶段==**，直接从宏任务队列中取出下一个宏任务执行

  - **执行宏任务**：从宏任务队列中取出并执行一个宏任务
    - 如果该宏任务没有导致 **DOM** 变动或样式修改，浏览器不会标记页面为「需要更新」

  - **执行微任务**：宏任务结束后，立即清空微任务队列
    - 如果微任务中同样没有引起 **DOM** 修改或样式变动，浏览器依然不会进入渲染阶段

  - **跳过渲染，继续执行宏任务**：由于页面不需要更新，==浏览器会直接回到事件循环==，从宏任务队列中取出下一个宏任务执行

### 2、浏览器的渲染流水线
浏览器在一帧内的渲染流水线主要包括以下几个步骤：

   - **样式计算（Style Calculation）**：浏览器会根据 **CSS** 样式表和 **DOM** 树计算每个元素的最终样式
   - **布局（Layout）**：根据样式计算的结果，将 **DOM** 元素按照层级结构进行定位和大小计算，生成布局树
   - **绘制（Paint）**：将布局树中的元素绘制到屏幕上，包含颜色、边框、阴影等视觉效果
   - **合成（Composite）**：将不同的图层合并到一起并输出到屏幕

如果在 **JavaScript** 中直接更改 **DOM** 或样式，会触发回流（**reflow**）或重绘（**repaint**），这些操作会在下一次渲染阶段反映在页面上

### 3、浏览器的渲染帧

- **无变化的帧**：假设当前帧内没有 **DOM** 变动、样式修改或动画，==浏览器会跳过渲染阶段==，进入下一帧，这种情况下可以节省 **CPU** 和 **GPU** 资源

- **有变化的帧**：如果在某一帧内，**JavaScript** 代码修改了 **DOM** 或样式，那么浏览器会在「该帧」或「下一帧」的渲染阶段进行样式计算、布局和绘制操作

  - 浏览器**可能会在下一帧**而不是当前帧进行样式计算、布局和绘制操作，这主要是因为浏览器渲染引擎采用了一种「**批处理**」和「**延迟渲染**」的策略，以减少多次重复渲染带来的性能开销，确保每一帧内任务的执行效率和渲染流畅度

    - 浏览器的批处理策略

      - 浏览器通常会延迟、「批量处理」多个样式和布局的更改，而不是立即执行计算
      - 批处理策略允许浏览器==收集多个 DOM 和样式的更改==，然后在==下一帧一起计算和绘制==，从而减少重复的渲染步骤
        - 例如，如果 **JavaScript** 在当前帧多次修改 **DOM** 或样式，浏览器可以在当前帧内收集所有这些更改，等待进入下一帧时再执行统一的样式计算和布局，从而降低计算和重绘的次数

    - 避免重复布局和重绘

      - 如果每次 **DOM** 操作或样式变动都立即触发渲染阶段，浏览器可能会陷入频繁的样式重计算和布局（称为 **reflow**）以及重绘（**repaint**），造成性能开销和卡顿
      - 通过延迟渲染，浏览器可以**合并多个变化**，在下一帧集中进行一次计算和绘制，避免不必要的多次重复渲染。

    - 帧内任务的时间限制

      - 浏览器需要在 `16.67ms`（`60fps`）内完成所有任务，以保证页面的流畅性

      - 如果在当前帧执行了复杂的 **JavaScript** 任务或较多的 **DOM** 操作，可能会耗尽这一帧的时间预算，导致没有足够时间完成渲染阶段

      - 在这种情况下，浏览器会将渲染阶段延迟到下一帧，以便优先完成 **JavaScript** 执行，确保页面交互响应速度，同时避免当前帧因渲染超时而「跳帧」

        > - **跳帧**：通常指浏览器或渲染引擎在**有意地跳过某些帧**的渲染，以便保证整体的帧率和流畅度
        >   - 这通常是一种**优化策略**，并不总是导致明显的卡顿或不流畅
        >
        > - **掉帧：通常是由于计算量超出了系统的处理能力，导致帧率**降低**或**不稳定**，
        >   - 表现为明显的卡顿、画面不流畅

    - **requestAnimationFrame** 的应用场景

      - `requestAnimationFrame` 的设计就是利用这种延迟渲染的特性，让开发者在浏览器即将开始渲染之前执行动画或 **DOM** 更新，这样可以确保变化集中在一帧内完成，避免重复重排和重绘
      - `requestAnimationFrame` 回调会在帧开始之前被调用，确保当帧渲染时所有样式计算和布局都已准备完毕，从而使动画更流畅

### 4、requestAnimationFrame 与 requestIdleCallback 的执行时机

   - **`requestAnimationFrame`**：`requestAnimationFrame` 是一个优化动画的 **API**，用于==在每帧开始之前执行指定的回调函数==，通常用于在下一帧渲染前更新 **DOM** 操作
      - 执行时机：`requestAnimationFrame` 的回调函数会在下一帧渲染阶段开始前调用
           - 浏览器会尽量在当前刷新频率的下一帧执行 `requestAnimationFrame` 回调，以保持流畅的动画效果
      - 主要作用：适合更新动画帧的 **DOM** 操作或样式修改，因为它能使操作与浏览器的刷新同步，避免丢帧
      
   - **`requestIdleCallback`**：`requestIdleCallback` 是一个利用空闲时间的 **API**，它适合执行那些优先级低且不会影响页面流畅性的任务，如数据预加载、分析等
      - 执行时机：`requestIdleCallback` 回调函数会在当前帧的所有必要工作完成后，以及下一帧到来前的空闲时间执行
        - 当浏览器处于繁忙状态（如低帧率）时，`requestIdleCallback` 的回调可能==会延迟或跳过==
      - 主要作用：适合延后执行的低优先级任务
        - 它可以接受一个 `timeout` 参数，指定任务必须在一定时间内完成，确保关键任务不会无限延迟

### 5、浏览器渲染帧的完整流程示例
在一帧的时间内，浏览器的事件循环大致如下：

1. **处理事件**：完成用户事件、网络响应、`setTimeout` 等宏任务
2. **执行微任务**：在宏任务完成后，执行微任务队列的所有任务（如 **Promise** 回调）
3. **执行 requestAnimationFrame**：开始渲染阶段前调用所有 `requestAnimationFrame` 的回调，更新动画的状态
4. **渲染阶段**：
   - **样式计算**：计算元素的最终样式
   - **布局计算**：计算元素的尺寸、位置和层级
   - **绘制和合成**：将页面绘制到屏幕
5. **执行 requestIdleCallback**：如果渲染后帧内仍有时间，调用 `requestIdleCallback` 的回调

### 6、示例代码展示 API 的使用

```javascript
// Example for requestAnimationFrame
function animate() {
  // Animation logic here, e.g., updating DOM style
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// Example for requestIdleCallback
function performLowPriorityTask(deadline) {
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    const task = tasks.shift();
    // Execute low-priority task
  }
}
requestIdleCallback(performLowPriorityTask, { timeout: 2000 });
```

### 总结

1. **事件循环**：负责在帧间管理任务调度，按顺序执行宏任务、微任务，确保渲染阶段的到来
2. **渲染阶段**：每帧内完成样式计算、布局、绘制等操作
3. **API 执行时机**：`requestAnimationFrame` 在渲染阶段开始前执行，而 `requestIdleCallback` 在渲染完成后且帧内有剩余时间时执行