## 微前端相关

### 一、概述

#### 1.1、什么是微前端

**「微前端」**（**Micro Frontends**）这一概念最早由 **ThoughtWorks** 在 **2016 年的《Technology Radar》** 中正式提出，从思想演化角度来看「微前端」的核心理念源自 **后端的微服务架构（Microservices Architecture）**

它是将**「微服务」**的思想——即 “==将**单体系统**拆分为**可独立开发**、**部署**、**运行**的**小型模块**==”——引入到前端工程化领域的产物

> 「微前端」和「微服务」的本质都是**去耦合**，只有当应用程序达到一定规模时，这才开始变得更有意义

**「微前端」**是一种**将==单体前端应用拆分为多个独立、自治的小型前端应用==**（子应用、micro-apps）的**架构思想**与**工程实践**；每个子应用负责自己的一片业务，拥有独立的技术栈、开发、测试与部署流水线，但在运行时能够被组装成一个完整的应用

#### 1.2、微前端出现的背景

- **业务规模扩大**  <!--主要原因-->
  - 一个单体前端应用随着业务的增长，应用体量也变得庞大，问题也随之出现，代码耦合严重，构建、测试、部署变慢，**以致缺乏灵活性，难以维护**，从而**影响了迭代速度 ** 
  - 多团队协作开发时，单体应用会频繁出现代码冲突、依赖协调成本高、PR 审查/CI 时间长的问题

- **部署与发布独立性需求**：
  - 业务模块希望**独立发布/回滚**，避免紧耦合导致一次小改动影响整个系统
  - 需要支持不同业务模块的组合方案
- **维护成本与可靠性**：需要将风险隔离，降低某块出错影响整个应用的概率，
- **技术栈多样化诉求**：不同团队可能有不同的技术偏好（React、Vue、Angular）

以上既是微前端出现的背景，也是微前端需要解决问题，也是微前端出现的目的

#### 1.3、微前端的优缺点

首先说明下「微前端」的技术特点：

- **独立性**：子应用之间可以独立开发、构建、部署、测试、发布、回滚
- **组合性**：可以将子应用自由组合挂载到主应用中，由主应用进行编排和管理
- **共享能力**：可通过**运行时**共享机制复用**公共模块**
- **隔离性**：尽量隔离样式、全局变量与副作用，避免“冲突污染”

基于以上的技术特点，「微前端」具备以下优点：

- **更快的业务交付**：更短的开发周期，业务模块可以独立发布，减少协调等待
- **更高的容错性**：单个子应用异常不会导致整个系统崩溃，可实现部分降级或独立恢复
- **减少重复开发**：可以共享公共模块，避免重复造轮子
- **业务上的灵活性**：可以定义不同的业务模块的组合方案，同时不引入多余的复杂性

这个世界上并不存在银弹，所有的架构都是取舍和权衡，**「微前端」**和**「微服务」**一样也存在他的弊端，单体架构未必就差，接下来说说**「微前端」**的缺点：

- **运行时复杂度上升**：路由、状态共享、样式冲突、事件冒泡等需额外设计与治理
- **共享依赖与版本管理难**：不同子应用对同一依赖的版本冲突需要解决，可以降级、适配或锁定版本
- **性能问题**：如果每个子应用都有自己的框架依赖，可能造成重复加载、首屏变慢
- **运维成本增加**：更多的流水线、部署点、监控与日志聚合需求

按照不同维度对「微前端」的优缺点进行总结

| 维度     | 优点                   | 缺点                 |
| -------- | ---------------------- | -------------------- |
| 架构     | 模块化、低耦合、易扩展 | 系统边界复杂         |
| 团队协作 | 独立开发部署、快速迭代 | 管理和集成成本高     |
| 技术选型 | 技术栈自由、渐进升级   | 依赖重复、打包体积大 |
| 运维     | 部分容错能力           | 监控与调试复杂       |

#### 1.4、微前端的一些误区

- 「微前端」不是一门具体的技术，==而是一种架构思想==
  - 可能会以脚手架、配套工具和规范约束等等**成体系**的形式综合呈现
  - 这种架构目前有多种方案，各有利弊，==但只要适用业务场景的就是好方案==

- 「微前端」本身并没有技术栈的约束，==支持多种技术栈并不是其必要条件==
  - 每一套微前端方案的设计，都是基于实际需求出发
  - 如果是多团队统一使用了 **React** 技术栈，可能对微前端方案的跨技术栈使用并没有要求
  - 如果是多团队同时使用了 **React** 和 **Vue** 技术栈，可能就对微前端的跨技术栈要求比较高

- 「微前端」要求各个应用能**独立开发、测试、部署**，==但并不要求各个应用能独立运行==
  - 也就是说，微前端的**粒度**不一定是应用级的，也有可能是页面级，甚至组件级

#### 1.5、小结

**==微前端不是一个库，是一种前端架构的设计思路，本质上就是在运行时远程加载应用==**

适用于大型、多团队、长期演进的前端系统，但对于中小型或单团队项目，其所带来的复杂度与所带来的收益相比，往往得不偿失

### 二、不同的微前端实现方式

### 2.1、iframe

**原理：**

主应用通过 `<iframe>` 加载子应用页面，每个子应用在自己的浏览器上下文中独立运行

**特点：**

- **浏览器原生支持**，无额外框架依赖
- **完全隔离**（DOM、CSS、JS、运行环境互不干扰）
- 子应用可使用任意技术栈，无需主应用参与构建

**优点**：

- 隔离性最强，不存在样式或脚本污染问题
- 实现成本低，接入简单
- 安全性高

**缺点：**

- 隔离性太强
  - 路由与通信困难（cookie 的数据的同步，需 postMessage）
  - 主子应用交互受限（滚动、弹窗、跨域问题）

- 用户体验差（页面切换白屏、状态无法共享）
  - 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程

#### 2.2、single-spa

**原理：**

通过统一的路由调度机制（single-spa core）在同一页面中注册、加载和卸载多个前端应用

每个应用暴露三个生命周期钩子：`bootstrap`、`mount`、`unmount`。

**特点：**

- 以 **路由为核心** 的微前端框架
- 强调子应用独立构建与独立生命周期管理
- 可支持多框架（React/Vue/Angular 等）共存

**优点**：

- 生态早、理念成熟，社区文档完善

**缺点：**

- 样式与 JS 无隔离
- 子应用加载切换期间可能出现闪烁

#### 2.3、Qiankun（基于 Single-SPA 的增强版）

**qiankun** 是蚂蚁金服2018 年开源的

**原理：**

在 **Single-SPA** 基础上封装运行时沙箱与样式隔离机制，主应用与子应用之间通过 **JS 沙箱**、**CSS 隔离**实现真正的运行时独立

**特点：**

- 基于 **Single-SPA**，二次封装增强可用性
- 内置 **JS 沙箱（Proxy 实现）** 与 **样式隔离（Scoped CSS）**
- 主要面向 **Webpack** 构建体系

**优点**：

- 极大降低微前端接入复杂度
-  支持应用级热插拔与独立运行
- 性能与体验较平衡
- 社区成熟、中文资料丰富

**缺点：**

- 改造成本较大，构建体系、路由体系、全局状态体系需要做适配
-  2022 年后，核心更新频率明显下降，主仓库主要以社区 PR 为主
  -  部分 issue 长期未解决，意味着未来维护风险上升

#### 2.4、Wujie

**Wujie** 是 腾讯**2022 年8 月**开源的

**原理：**

通过 **iframe 的原生隔离能力 + 主子应用 DOM 同步渲染技术** 实现“高隔离 + 高性能”的折中方案

它在 **iframe** 中运行子应用的 JS，但将渲染输出同步到主页面 **DOM** 中（非纯 **iframe** 界面渲染）

**wujie渲染子应用的流程：**

1. 解析入口 **HTML** ，分别得到**script**、**css**、模版**html**
2. 创建一个纯净的 **iframe**
3. **iframe **内插入 **js**，将抽离出来的 **script** 脚本，插到 **iframe** 中去，在 **iframe** 中执行子应用的 **js**
4. 创建 **web component**，id为子应用id，将抽离出来的 **html** 插入
5. 由于 **iframe** 内的 js 有可能操作 **dom**，但是 **iframe** 内没有 **dom**，
   - **wujie** 框架内对 **iframe** 拦截 **document** 对象，统一将 **dom** 指向 **shadowRoot**
   - 此时比如新建元素、弹窗或者冒泡组件就可以正常约束在 **shadowRoot** 内部

**特点：**

- 利用 **iframe** 提供的安全隔离，但避免其白屏与通信问题
- 提供更轻量的沙箱机制

**优点**：

- 接入简单，可以以组件的方式引入子应用
- 纯净无污染，子应用真正“无侵入”接入
  - 无界利用 **iframe** 和 **webcomponent** 来搭建天然的 **js 隔离沙箱**和 **css 隔离沙箱**
  - 副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本
- 支持应用保活，子应用状态保留
  - 由于是独立在 **iframe** 中的，而切换应用时不会移除 **iframe**，所以子应用的状态会被保留在原来的**iframe** 中
  - 当主应用再次渲染子应用 **dom** 时，会显示之前的状态

**缺点：**

- 原理较复杂，学习成本高
-  生态相对 **Qiankun** 较小
- 调试难度略高

#### 2.5、Micro App（新兴轻量方案）

**Mirco App** 是京东2021年开源的一款微前端框架

**原理：**

基于 **Web Components** 技术，通过自定义元素（**Custom Element**）实现子应用生命周期管理与资源隔离。

**特点：**

- 使用浏览器原生标准（**CustomElement** + **ShadowDOM**）
- 支持沙箱隔离与样式封装
- 不依赖 **Single-SPA**

**优点**：

- 原生化方案、框架无关
- 对现代浏览器兼容性好
- 无需 polyfill 或重度封装
- 支持预加载、缓存、保活等特性

**缺点：**

-  生态相对较新，生产验证不足
-  **ShadowDOM** 存在样式穿透限制（需要额外封装）

#### 2.6、Webpack 5 Module Federation

> Module Federation 的理念是：“让多个独立构建的项目，在运行时共享同一个运行环境。”

**原理：**

- **Webpack 5** 的 **Module Federation** 允许**不同前端应用在运行时动态共享模块和依赖**
- 主应用（**Host**）可以在运行时加载远程子应用（**Remote**）的模块，而无需提前打包进主应用
- 核心思想：**运行时模块分发 + 动态依赖管理**，无需 **iframe** 或沙箱

**特点：**

- 基于构建时和运行时的模块联邦机制
- 支持版本控制和共享依赖（**Singleton** 模式）
- 子应用保持独立构建，但共享依赖库可减少重复加载
- 不依赖 **Single-SPA** 或其他微前端框架，可和 **React/Vue** 等配合使用 <!--这个是其关键特点-->

**优点**：

- **零运行时框架依赖**，直接利用 **Webpack 5** 打包机制 <!--关键-->
-  支持 **依赖共享**，避免重复加载 **React/Vue** 等大型库
-  **性能优化**：首次加载后，模块可缓存，子应用可按需加载
- 运行时模块动态加载，支持按需更新和渐进式迁移 <!--关键-->

**缺点：**<!--和微前端框架相比的不足之处-->

-  **隔离性弱**：主应用和子应用共享全局环境，样式与全局变量可能冲突
-  **路由与生命周期**：**Module Federation** 本身只解决模块加载，不处理路由管理和生命周期 <!--这里需要自己实现支持-->

##### 2.6.1、Module Federation 与其他微前端方案的区别

1. **零额外框架依赖**

   - **Module Federation**  完全内嵌在 **Webpack 5** 构建体系中，不依赖外部框架

2. **构建时解耦**

   - 所有微前端方案都支持「独立构建」但只有 **Module Federation** 实现了“构建时声明依赖，运行时共享模块”的真正**构建时解耦**

     - 其他方案解决的是「前端页面的组合问题」

     - **Module Federation** 解决的是「前端模块的协作问题」

       这使得它能实现：

       - 模块热插拔
       - 部分替换
       - 灰度发布（仅更新某个组件或功能）

     <!--模块间解耦，但同时也决定了其不能支持 JS 和 CSS 隔离上的缺陷-->

3. **模块共享能力**

   - **Module Federation**  能让多个应用在运行时**共享依赖库（如 React、Vue、lodash）**，避免重复加载
   - 这是其他方案（如 qiankun、iframe）在架构上无法直接做到的

##### 2.6.2、Module Federation 适用场景

1. **大型前端工程内部模块拆分**
   - **同一技术栈**（例如多个 React 子系统）
   - **希望按功能模块解耦**
   - **各模块间需要共享状态或组件库**
2. **渐进式重构旧系统**
   - 老系统仍使用 **Webpack**，逐步替换部分模块为新框架
   - **Module Federation** 可在旧系统中直接加载新模块，逐步迁移而非推倒重来

### 三、微前端的技术基石

#### 3.1、Web Components

**Web Components** 是浏览器原生支持的组件化标准，允许创建**可复用、封装良好、框架无关的 HTML 标签**

它的核心特点：

1. **自定义元素（Custom Elements）**：可以定义自己的标签，如 `<user-card>`
2. **影子 DOM（Shadow DOM）**：组件内部 **DOM** 与样式封装，避免外部干扰
3. **模板（HTML Templates）**：定义可复用的 **HTML** 结构

> 核心价值：**写一次组件，任何项目、任何框架都能用，且组件内部样式和逻辑互不干扰**

**示例：**用户信息卡片 `<user-card>`

```js
class UserCard extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'open' });
    const name = this.getAttribute('name') || '匿名';
    shadow.innerHTML = `
      <style>
        p { color: blue; font-weight: bold; }
        div { border: 1px solid #ccc; padding: 8px; border-radius: 4px; }
      </style>
      <div><p>${name}</p></div>
    `;
  }
}

customElements.define('user-card', UserCard);
```

**HTML 使用方式：**

```html
<script type="module" src="./user-card.js"></script>

<user-card name="Alice"></user-card>
<user-card name="Bob"></user-card>
```

- 每个 `<user-card>` 都是独立的组件，内部样式不会被外部影响
- 在任何项目中都可以直接使用，框架无关





