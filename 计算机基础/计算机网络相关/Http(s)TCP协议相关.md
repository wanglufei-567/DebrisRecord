## Http(s)/TCP协议学习笔记

### 写在前面

#### 名词解释

- 协议栈
  - 解释：计算机网络控制软件
  - 作用：将应用信息打包并加上目的地地址等控制信息；拿快递来比较就是将快递打包然后再写上发件人和收件人信息；当然还有其他功能，如发生通信错误时重新发包、调节发送效率等
- 网卡
  - 解释：负责以太网或无线网络通信的硬件
  - 作用：将应用信息转换为电信号通过网络发出去
- Socket库
  - 解释：Socket库是用于调用网络功能的程序组件集合，是操作系统内置的网络库
  - 作用：Socket库中包含很多用于发送和接受数据的程序组件
- 套接字
  - 解释：套接字只是个概念没有实体，若一定要赋予它一个实体，那协议栈中存放的控制信息就是套接字
  - 作用：协议栈内部中存在一块内存空间，记录了用于控制通信操作的控制信息，比如：通信对象的IP地址、端口号、通信操作的进行状态等
- 描述符
  - 作用：应用程序通过”描述符“这一类似于号码牌的东西来识别套接字
- 端口号
  - 作用：识别应用程序的套接字的，客户端和服务端之间用来识别对方套接字的机制

#### 类比理解

- 包(Packet)：类似于快递中的概念，**包**相当于快递包裹，而路由器和交换机则相当于快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据这些控制信息进行分拣，然后将它们一步一步地搬运到目的地。
- 网络: 搬运网络包（数字信息）的机制加上浏览器、服务器这些网络应用程序就构成了网络的全貌
- IP地址：相当于现实中的XX号XX室一样，IP地址就是网络中的地址，”号“对应的是网络号，”室“对应的是主机号
- 子网掩码：IP地址是32比特的数字，按照8比特一组分为四组，再用十进制表示，包含了网络号和主机号，子网掩码是表示网络号和主机号的边界

------

### 从在浏览器输入URL到页面加载内容

1. ##### 解析URL生成HTTP请求信息
   1. HTTP协议定义了客户端和服务端交互的信息内容和步骤；HTTP请求消息中包含的内容是“对什么”和“进行怎么样的操作”两个部分；“对什么”部分是URI，“进行怎么样的操作”是方法；
   2. 浏览器虽然可以解析URL生成HTTP请求消息，但浏览器本身是不具备将消息发送到网络中的功能的；因此需要委托操作系统实现；在委托操作系统发送消息时，必须要提供服务端的Ip地址，所以在根据URL生成请求消息之后，下一步骤就是获取服务端IP地址；

2. ##### DNS域名解析

   1. 浏览器调用Socket库中的DNS解析器查询IP地址
      - 查询IP地址其实也是一次网络通信，是Socket库和DNS服务器的通信，**DNS服务器的IP地址已经配置在系统里面了**，传输层的协议使用的是UDP协议而不是TCP协议（*为什么是UDP？后面再补充*）
      - 查询到IP地址之后，Scoket库会将IP地址写入到浏览器提供的内存中去，**服务端的IP地址是存在浏览器中的**

3. ##### 委托协议栈发送消息（其实就是建立TCP连接，根据IP地址和默认80端口，和服务器建立TCP连接）

   知道了IP地址之后就可以委托操作系统内部的协议栈向这个目标IP地址发送消息了

   - 首先，客户端应用程序传递ip地址和端口给系统协议栈，协议栈中的tcp模块会将这些信息写入头部，tcp模块又委托ip模块进行消息传递；  
   -  当消息传递到服务端之后（服务端的服务进程是默认打开且待连接状态），服务端的tcp模块会根据客户端传递过来的端口号找到对应的套接字（协议栈中内存保存的控制信息）并且对应套接字会写入客户端的ip地址并修改连接状态为正在连接（默认是未连接），操作完成后服务端会返回响应给客户端，在返回头部中写入信息（ACK，用来告诉客户端收到请求的信息了）； 
   -  当客户端的tcp模块收到响应信息后会根据响应头判断是否连接成功，连接成功的话会将服务端的ip和端口等信息写入到自己的套接字中，并修改连接状态为连接完毕，并再次发送信息（还是只有头部信息，没有具体的数据）给服务端，通知服务端自己收到了刚才的响应信息

   （其实以上的过程就是TCP的三次握手，按照自己的理解去写的，有点拉胯，下面是摘抄的，比较详细）

   ------

   ##### TCP三次握手

   所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：

   ![img](https://upload-images.jianshu.io/upload_images/2964446-aa923712d5218eeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/517/format/webp)

   （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

   （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

   （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

   简单来说，就是

   1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认

   2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态

   3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。

   ##### TCP可靠性的体现：seq和ack机制

   顺序号seq：用来标识从TCP源端向TCP目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。理解起来就是TCP用顺序号对每个字节进行计数。由上图TCP报文格式中可以看出序号是 32bit 的无符号数，序号到达 后又重新开始计数。当建立一个新的连接时，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ），也就是说seq并不一定是从0开始的，所以刚在画TCP三次握手的时候，写的seq=x，即使还没有数据传输，seq包含了ISN后就成了一个随机数，并不是0。

   确认号ack：理解起来就一句话，所期望收到的下一个顺序号seq。

   TCP为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输，也就是说服务端和客户端都可能成为数据接收或者数据发送的一端。

   数据发送端在发送TCP报文时，计算在本次seq计数内，之前所有发送的报文中数据长度之和是多少，也就是计数记到哪里了，这就是seq。然后再计算之前所有收到的报文中收到的数据长度之和是多少，这就是ack。需要注意的是seq和ack是分开计数的。需要注意的是，SYN和FIN的TCP报文传输虽然没有数据，但是数据长度算1，ACK的传输，数据长度算0。

   数据接收端收到TCP报文后，将这次报文中的seq取出来，和自己最后一次发送的ack对比，如果一致，则代表数据没有丢失，理解起来就是这次的顺序号和上次自己期望的顺序号一致嘛。如果不一致就说明有丢包发生。其实就是TCP用0~对每个字节进行计数

   **三个过程：**

   A在发送某个TCP报文前，发现此时自己这边的seq计数已经到了x，那这次的报文中seq=x，也就是在一次seq计数内，该端之前所有发送的报文中数据长度之和为x。然后这次又在这个报文中携带了长度为100bit的数据。

   B在收到这个报文后，拿到报文中的seq=x，又拿到了长度为100bit的数据，然后回包的时候ack=x+100。意思是告诉B你已经发了x+100位的数据了，下次发包的时候别忘了把seq改成x+100。

   A收到B回的数据包后，拿到报文中的ack=x+100，然后和自己这边的计数着的seq一比对，如果一样，说明A发的B都收到了没问题，如果不一样，假如A一看自己这边的seq已经等于y了，也就是自己计数着的已经发送y位的数据了，可是听B的意思它才收到x+100位数据，丢包了呗。然后就是重发什么的是TCP的另外一些机制。

   ------

   






