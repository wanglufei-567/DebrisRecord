## 链表的双指针算法

### 一、概念介绍

**双指针算法**（**Two Pointers**）是一种在链表中使用两个「指针」来解决问题的算法技巧，通过控制两个指针的移动速度和方向，可以高效地解决许多链表相关的问题

在链表中，这两个指针可以：

- 指向不同的链表（如**「归并指针」**）
- 以不同的速度移动（如**「快慢指针」**）
- 从不同的起始位置开始（如**「前后指针」**）

**双指针的优势**：

- **时间效率**：大多数情况下只需要一次遍历
- **空间效率**：只需要常数级别的额外空间

**「双指针算法」**特别适用于以下场景：

- 需要同时访问链表中的多个位置
- 需要比较链表中不同位置的元素
- 需要在一次遍历中完成复杂的操作

### 二、算法原理

**核心思想：**

- 使用两个指针
- 根据具体问题调整两个指针的移动策略
- 通过指针的相对位置关系来解决问题

**基本工作原理：**

- **指针初始化**

  - 根据问题需求，将两个指针初始化到合适的位置

  - 可能都指向链表头部，也可能指向不同的位置


- **指针移动策略**

  - **同步移动**：两个指针以相同速度移动，保持固定距离

  - **异步移动**：两个指针以不同速度移动，产生相对位移

  - **条件移动**：根据特定条件决定哪个指针移动


- **终止条件**：

  - 当某个指针到达链表末尾

  - 当两个指针相遇

  - 当满足特定的业务条件


#### 2. 数学原理

**快慢指针的数学基础**：

- 设链表长度为 `n`，环的长度为 `c`
- 快指针速度为 `2`，慢指针速度为 `1`
- 如果存在环，快指针会在 `c` 步内追上慢指针
- 相遇点到环起点的距离等于链表头到环起点的距离

### 三、链表的合并与拆分

#### 3.1、合并有序链表

**描述**：

- 将两个升序链表合并为一个新的**升序**链表并返回
- 新链表是通过拼接给定的两个链表的所有节点组成的

**示例：**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/merge_ex1.jpg)

> ```
> 输入：l1 = [1,2,4],  l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]
> ```

**题解：**

```javascript
// 链表节点
function ListNode(val, next) {
  this.val = (val===undefined ? 0 : val)
  this.next = (next===undefined ? null : next)
}

// 合并有序链表
function mergeTwoLists(list1, list2) {
    // 创建一个新的链表，其表头是虚拟链表头（为了操作方便，创建的临时节点，最后会被丢弃）
    // dummy 占位的意思
    let dummy = new ListNode(0);

    // 创建一个指针指向新链表的表头
    let current = dummy;

    // 创建两个指针分别指向需要合并的链表的表头
    let p1 = list1;
    let p2 = list2;

    // 比较两个链表的节点值
    while (p1 && p2) {
      // 比较 p1 和 p2 两个指针
      // 将值较小的的节点接到 current 指针
        if (p1.val <= p2.val) {
            current.next = p1;
            p1 = p1.next;
        } else {
            current.next = p2;
            p2 = p2.next;
        }

        // current 指针不断前进
        current = current.next;
    }

    // 若 p1或 p2 链表已到达末尾，则直接连接剩余节点
    current.next = p1 || p2;

    // dummy 节点被丢弃，返回的是其后的链表
    return dummy.next;
}
```

**解析：** 这道题可以通过**「递归」**和**「双指针」**两种方式来解决

**「递归」**的逻辑：

- 比较两个链表的头节点，将较小的节点取出，作为结果链表的头节点

- 再递归比较两个链表的剩余部分，直到某一个链表为空

- 将另一个链表剩余的节点接到结果链表的末尾

- 返回结果链表

  > ```javascript
  > function mergeTwoListsRecursive(list1, list2) {
  >   // 递归终止条件
  >   if (!list1) return list2;
  >   if (!list2) return list1;
  >
  >   // 递归处理
  >   if (list1.val <= list2.val) {
  >       list1.next = mergeTwoListsRecursive(list1.next, list2);
  >       return list1;
  >   } else {
  >       list2.next = mergeTwoListsRecursive(list1, list2.next);
  >       return list2;
  >   }
  > }
  > ```

**「双指针」**的逻辑：

- 创建一个虚拟头节点，用于存储合并后的链表
- 创建两个指针，分别指向两个链表的头部
- 比较两个指针指向的节点值，将值较小的节点接到虚拟头节点后面
- 移动指针，继续比较
- 当其中一个链表到达末尾时，将另一个链表剩余的节点接到虚拟头节点后面
- 返回虚拟头节点后面的链表

相比较与「递归」，「双指针」的逻辑更加直观，更容易理解，并且空间复杂度更低

#### 3.2、分隔链表

**描述：**

- 给一个链表的头节点 `head` 和一个特定值 `x` ，对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前
- 应当 **保留** 两个分区中每个节点的初始相对位置

**示例：**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/partition.jpg)

> ```markdown
> 输入：head = [1,4,3,2,5,2], x = 3
> 输出：[1,2,2,4,3,5]
> ```

**题解：**

```javascript
var partition = function(head, x) {
  // 创建新链表，存储比 x 小的节点
    let dummy1 = new ListNode(-1)
    // dummy1 链表的指针
    let p1 = dummy1
    // 创建新链表，存储 >= x 的节点
    let dummy2 = new ListNode(-1)
    // dummy2 链表的指针
    let p2 = dummy2

    // 创建一个指针，指向原链表的头部
    let current = head

    // 遍历原链表
    while(current !== null) {
      if(current.val < x) {
        // 如果当前节点的值小于 x，则将当前节点添加到 dummy1 链表中
        p1.next = current
        p1 = p1.next
      } else {
        // 如果当前节点的值 >= x，则将当前节点添加到 dummy2 链表中
        p2.next = current
        p2 = p2.next
      }
      // 移动原链表的指针
      current = current.next
    }
    // 将 dummy1 链表的尾部指向 dummy2 链表的头部
    p1.next = dummy2.next
    // 将 dummy2 链表的尾部指向 null
    p2.next = null
    // 返回 dummy1 链表的头部
    return dummy1.next
};
```

**解析：** 这个链表分隔问题的解法采用了双链表构建策略，核心思路如下

- 创建两个虚拟头节点：

  - `dummy1`：收集所有值小于 x 的节点

  - `dummy2`：收集所有值大于等于 x 的节点

- 使用三个指针：

  - `p1`：维护小于 x 的链表尾部

  - `p2`：维护大于等于 x 的链表尾部

  - `current`：遍历原链表

- 遍历分类：

  - 一次遍历原链表，根据节点值与 `x` 的比较结果

  - 将节点分别添加到对应的链表中

  - 保持原有的相对位置顺序

- 连接合并：

  - 将小于 `x` 的链表尾部连接到大于等于 `x` 的链表头部

  - 确保最终链表的尾部指向 `null`

**算法优势：**

- 时间复杂度：`O(n)`，只需一次遍历

- 空间复杂度：`O(1)`，只使用了常数个额外指针

- 保持顺序：完美保留了原链表中节点的相对位置

这种方法简洁高效，通过「**分而治之**」的思想将复杂的链表重排问题转化为两个简单的链表构建问题

#### 3.3、合并 K 个升序链表

**描述：**

- 给定一个链表数组，每个链表都已经按升序排列
- 将所有链表合并到一个升序链表中，返回合并后的链表

**示例：**

> ```markdown
> 输入：lists = [[1,4,5],[1,3,4],[2,6]]
> 输出：[1,1,2,3,4,4,5,6]
> 
> 解释：链表数组如下：
> [
>   1->4->5,
>   1->3->4,
>   2->6
> ]
> 
> 将它们合并到一个有序链表中得到
> 1->1->2->3->4->4->5->6
> ```

**题解：**

```javascript
// 实现一个最小堆
class MinHeap {
  constructor(compareFn) {
    this.heap = []
    this.compareFn = compareFn
  }

  size() {
    return this.heap.length
  }

  getLeftIndex(index) {
    return index*2 + 1
  }

  getRightIndex(index){
    return index*2 +2
  }

  getParentIndex(index) {
    return Math.floor((index -1) / 2)
  }

  swap(index1, index2) {
    [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]]
  }

  shiftUp(index) {
    const parentIndex = this.getParentIndex(index)
    // 和父节点比较，为 true 则互换位置，同时继续上移
    if(parentIndex >= 0 && this.compareFn(this.heap[index], this.heap[parentIndex])) {
      this.swap(index, parentIndex)
      this.shiftUp(parentIndex)
    }
  }

  insert(item) {
    if (!item) return

    this.heap.push(item)
    this.shiftUp(this.heap.length - 1)
  }

  shiftDown(index) {
    const size = this.size()
    const leftIndex = this.getLeftIndex(index)
    const rightIndex = this.getRightIndex(index)

    let current = index

    // 比较 左子节点 和 current，为 true，则标记 左子节点 current
    if(leftIndex < size && this.compareFn(this.heap[leftIndex], this.heap[current])) {
      current = leftIndex
    }

    // 比较 右子节点 和 current，为 true，则标记 右子节点 current
    if(rightIndex < size && this.compareFn(this.heap[rightIndex], this.heap[current])) {
      current = rightIndex
    }

    // current 不等于 index 时说明需要交换位置
    if(current !== index) {
      this.swap(index, current)
      // 继续下移
      this.shiftDown(current)
    }
  }

  extract() {
    if(this.size() === 0 ) return null
    if(this.size() === 1) return this.heap.pop()

    // 堆顶元素出堆
    const removedValue = this.heap[0]

    // 从堆低取出元素放在堆顶
    this.heap[0] = this.heap.pop()

    // 堆顶元素不断下移
    this.shiftDown(0)

    return removedValue
  }
}
```

```javascript
// 合并链表
var mergeKLists = function(lists) {
  if(lists.length <= 0) return null
  // 创建虚拟头节点
  const dummy = new ListNode(-1)
  let p = dummy

  // 创建最小堆
  const compareFn = (node1, node2) => node1.val < node2.val
  const minHeap = new MinHeap(compareFn)

  // 遍历链表组，将每个链表头加入到最小堆中
  lists.forEach(list => {
    if(list !== null) {
      minHeap.insert(list)
    }
  });

  // 遍历最小堆，直到最小堆中没有值
  while(minHeap.size() > 0) {
    // 取出最小堆的堆顶元素
    const node = minHeap.extract()
    p.next = node
    // 若是取出来的元素的还有子节点，则将其加入到最小堆
    if(node.next !== null) {
      minHeap.insert(node.next)
    }
    // 指针往前移动
    p = p.next
  }

  return dummy.next
};
```

**解析：**这道题的思路很简单，只需不断比较所有链表的头节点，找出最小的那个节点，将其取出并添加到新链表中

如何找到最小节点有很多种方式：

- 将所有链表头节点放到一个数组中，利用 **JS** 数组的 `sort` 方法进行排序，获取最小的节点
- 利用最小堆这种数据结构可以更加节省时间，不断的将链表的头节点 `insert` 到最小堆中，堆顶元素自然就是最小的那个节点



### 三、常见的双指针策略

- **快慢指针（Floyd 判圈算法）**

  - **快指针**：每次移动两步

  - **慢指针**：每次移动一步

  - **应用场景**：检测链表是否有环、找到链表的中点


- **前后指针**

  - **前指针**：先移动 n 步

  - **后指针**：然后两个指针同时移动

  - **应用场景**：找到链表的倒数第 k 个节点


- **头尾指针**

  - **左指针**：从头开始

  - **右指针**：从尾开始（或预先定位）

  - **应用场景**：回文链表判断、链表反转


### 四、主要应用场景
