## 链表的双指针算法

### 一、概念介绍

**双指针算法**（**Two Pointers**）是一种在链表中使用两个「指针」来解决问题的算法技巧，通过控制两个指针的移动速度和方向，可以高效地解决许多链表相关的问题

在链表中，这两个指针可以：

- 指向不同的链表（如**「归并指针」**）
- 以不同的速度移动（如**「快慢指针」**）
- 从不同的起始位置开始（如**「前后指针」**）

**双指针的优势**：

- **时间效率**：大多数情况下只需要一次遍历
- **空间效率**：只需要常数级别的额外空间

**「双指针算法」**特别适用于以下场景：

- 需要同时访问链表中的多个位置
- 需要比较链表中不同位置的元素
- 需要在一次遍历中完成复杂的操作

### 二、算法原理

**核心思想：**

- 使用两个指针
- 根据具体问题调整两个指针的移动策略
- 通过指针的相对位置关系来解决问题

**基本工作原理：**

- **指针初始化**

  - 根据问题需求，将两个指针初始化到合适的位置

  - 可能都指向链表头部，也可能指向不同的位置


- **指针移动策略**

  - **同步移动**：两个指针以相同速度移动，保持固定距离

  - **异步移动**：两个指针以不同速度移动，产生相对位移

  - **条件移动**：根据特定条件决定哪个指针移动


- **终止条件**：

  - 当某个指针到达链表末尾

  - 当两个指针相遇

  - 当满足特定的业务条件


#### 2. 数学原理

**快慢指针的数学基础**：

- 设链表长度为 `n`，环的长度为 `c`
- 快指针速度为 `2`，慢指针速度为 `1`
- 如果存在环，快指针会在 `c` 步内追上慢指针
- 相遇点到环起点的距离等于链表头到环起点的距离

### 三、链表的合并与拆分

#### 3.1、合并有序链表

**描述**：

- 将两个升序链表合并为一个新的**升序**链表并返回
- 新链表是通过拼接给定的两个链表的所有节点组成的

**示例：**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/merge_ex1.jpg)

> ```
> 输入：l1 = [1,2,4],  l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]
> ```

**题解：**

```javascript
// 链表节点
function ListNode(val, next) {
  this.val = (val===undefined ? 0 : val)
  this.next = (next===undefined ? null : next)
}

// 合并有序链表
function mergeTwoLists(list1, list2) {
    // 创建一个新的链表，其表头是虚拟链表头（为了操作方便，创建的临时节点，最后会被丢弃）
    // dummy 占位的意思
    let dummy = new ListNode(0);

    // 创建一个指针指向新链表的表头
    let current = dummy;

    // 创建两个指针分别指向需要合并的链表的表头
    let p1 = list1;
    let p2 = list2;

    // 比较两个链表的节点值
    while (p1 && p2) {
      // 比较 p1 和 p2 两个指针
      // 将值较小的的节点接到 current 指针
        if (p1.val <= p2.val) {
            current.next = p1;
            p1 = p1.next;
        } else {
            current.next = p2;
            p2 = p2.next;
        }

        // current 指针不断前进
        current = current.next;
    }

    // 若 p1或 p2 链表已到达末尾，则直接连接剩余节点
    current.next = p1 || p2;

    // dummy 节点被丢弃，返回的是其后的链表
    return dummy.next;
}
```

**解析：** 这道题可以通过**「递归」**和**「双指针」**两种方式来解决

**「递归」**的逻辑：

- 比较两个链表的头节点，将较小的节点取出，作为结果链表的头节点

- 再递归比较两个链表的剩余部分，直到某一个链表为空

- 将另一个链表剩余的节点接到结果链表的末尾

- 返回结果链表

  > ```javascript
  > function mergeTwoListsRecursive(list1, list2) {
  >   // 递归终止条件
  >   if (!list1) return list2;
  >   if (!list2) return list1;
  >
  >   // 递归处理
  >   if (list1.val <= list2.val) {
  >       list1.next = mergeTwoListsRecursive(list1.next, list2);
  >       return list1;
  >   } else {
  >       list2.next = mergeTwoListsRecursive(list1, list2.next);
  >       return list2;
  >   }
  > }
  > ```

**「双指针」**的逻辑：

- 创建一个虚拟头节点，用于存储合并后的链表
- 创建两个指针，分别指向两个链表的头部
- 比较两个指针指向的节点值，将值较小的节点接到虚拟头节点后面
- 移动指针，继续比较
- 当其中一个链表到达末尾时，将另一个链表剩余的节点接到虚拟头节点后面
- 返回虚拟头节点后面的链表

相比较与「递归」，「双指针」的逻辑更加直观，更容易理解，并且空间复杂度更低

#### 3.2、分隔链表

**描述：**

- 给一个链表的头节点 `head` 和一个特定值 `x` ，对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前
- 应当 **保留** 两个分区中每个节点的初始相对位置

**示例：**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/partition.jpg)

> ```markdown
> 输入：head = [1,4,3,2,5,2], x = 3
> 输出：[1,2,2,4,3,5]
> ```

**题解：**

```javascript
var partition = function(head, x) {
  // 创建新链表，存储比 x 小的节点
    let dummy1 = new ListNode(-1)
    // dummy1 链表的指针
    let p1 = dummy1
    // 创建新链表，存储 >= x 的节点
    let dummy2 = new ListNode(-1)
    // dummy2 链表的指针
    let p2 = dummy2

    // 创建一个指针，指向原链表的头部
    let current = head

    // 遍历原链表
    while(current !== null) {
      if(current.val < x) {
        // 如果当前节点的值小于 x，则将当前节点添加到 dummy1 链表中
        p1.next = current
        p1 = p1.next
      } else {
        // 如果当前节点的值 >= x，则将当前节点添加到 dummy2 链表中
        p2.next = current
        p2 = p2.next
      }
      // 移动原链表的指针
      current = current.next
    }
    // 将 dummy1 链表的尾部指向 dummy2 链表的头部
    p1.next = dummy2.next
    // 将 dummy2 链表的尾部指向 null
    p2.next = null
    // 返回 dummy1 链表的头部
    return dummy1.next
};
```

**解析：** 这个链表分隔问题的解法采用了双链表构建策略，核心思路如下

- 创建两个虚拟头节点：

  - `dummy1`：收集所有值小于 x 的节点

  - `dummy2`：收集所有值大于等于 x 的节点

- 使用三个指针：

  - `p1`：维护小于 x 的链表尾部

  - `p2`：维护大于等于 x 的链表尾部

  - `current`：遍历原链表

- 遍历分类：

  - 一次遍历原链表，根据节点值与 `x` 的比较结果

  - 将节点分别添加到对应的链表中

  - 保持原有的相对位置顺序

- 连接合并：

  - 将小于 `x` 的链表尾部连接到大于等于 `x` 的链表头部

  - 确保最终链表的尾部指向 `null`

**算法优势：**

- 时间复杂度：`O(n)`，只需一次遍历

- 空间复杂度：`O(1)`，只使用了常数个额外指针

- 保持顺序：完美保留了原链表中节点的相对位置

这种方法简洁高效，通过「**分而治之**」的思想将复杂的链表重排问题转化为两个简单的链表构建问题







### 三、常见的双指针策略

- **快慢指针（Floyd 判圈算法）**

  - **快指针**：每次移动两步

  - **慢指针**：每次移动一步

  - **应用场景**：检测链表是否有环、找到链表的中点


- **前后指针**

  - **前指针**：先移动 n 步

  - **后指针**：然后两个指针同时移动

  - **应用场景**：找到链表的倒数第 k 个节点


- **头尾指针**

  - **左指针**：从头开始

  - **右指针**：从尾开始（或预先定位）

  - **应用场景**：回文链表判断、链表反转


### 四、主要应用场景
