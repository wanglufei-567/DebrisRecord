## 数组相关算法

### 一、数组去重

#### 1.1、去除重复元素，只保留一个

**描述：**

- 给定一个 **非严格递增排列** 的数组 `nums` ， 删除重复出现的元素，使每个元素 **只出现一次** 

**示例：**

```markdown
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
```

**题解：**

```javascript
var removeDuplicates = function(nums) {
  if(nums.length === 0) return 0

  let slow = 0
  let fast = 0

  while(fast < nums.length) {
    // 当索引 slow 的值，不等于索引 fast 的值时，将 slow 索引向前移动一步，并赋值为 fast 索引的值
    if(nums[slow] !== nums[fast]) {
      slow++
      nums[slow] = nums[fast]
    }
    fast++
  }

  return slow + 1
};
```

#### 1.2、去除所有重复元素

**题解：**

```javascript
/**
 * 删除所有重复元素（不保留任何重复项）
 * @param {number[]} nums - 已排序的整数数组
 * @return {number} 去重后数组的有效长度
 *
 * 算法思路：
 * 1. 使用双指针技术遍历已排序数组
 * 2. 对每个元素统计其连续出现的次数
 * 3. 只保留出现次数为1的元素（即唯一元素）
 * 4. 原地修改数组，返回新数组的有效长度
 *
 * 示例：
 * 输入: [1,1,2,3,3]
 * 输出: 1，nums变为[2,_,_,_,_]（只保留唯一元素2）
 *
 * 输入: [0,0,1,1,1,2,2,3,3,4]
 * 输出: 1，nums变为[4,_,_,_,_,_,_,_,_,_]（只保留唯一元素4）
 */
const removeAllDuplicates = function(nums) {
    if (nums.length <= 1) return nums.length;

    let writeIndex = 0; // 写入指针：指向下一个要写入唯一元素的位置

    // 使用读取指针 i 遍历整个数组
    for (let i = 0; i < nums.length; ) {
        let current = nums[i];  // 记录当前正在处理的元素值
        let count = 0;          // 统计当前元素的连续出现次数

        // 内层循环：统计当前元素的连续出现次数
        // 由于数组已排序，相同元素必定连续出现
        while (i < nums.length && nums[i] === current) {
            count++;    // 计数器递增
            i++;        // 读取指针向前移动
        }

        // 判断是否为唯一元素：只有出现次数为1的元素才保留
        if (count === 1) {
            nums[writeIndex] = current;  // 将唯一元素写入到writeIndex位置
            writeIndex++;                // 写入指针向前移动
        }
        // 如果count > 1，说明是重复元素，直接跳过不写入
    }

    // 返回去重后数组的有效长度
    // 此时nums[0...writeIndex-1]包含所有唯一元素
    return writeIndex;
};
```

