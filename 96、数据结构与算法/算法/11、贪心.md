## 贪心

### 一、前言

**「贪心算法」**是一种**算法思想**，在每一步都做出当前看起来最优选择、期望通过**局部最优**累积得到**整体最优解**的

#### 1.1、贪心算法要解决什么类型的问题？

**「贪心算法」**的核心是：在每一步都有明确选择标准，当前选择不会破坏最终最优解，不需要回头修正之前的决策

它适用于满足以下特征的问题：

- **局部最优选择可以推导出全局最优**
  - 与**「动态规划」**一样依赖**「最优子结构」**，即**整体最优可以由局部最优推导出**

- **贪心选择性质**

  - 每一步都有一个**当前看起来当前最优的选择**

  - 决策一旦做出，**不需要撤销**，这个选择**不会破坏最终得到全局最优解**

    > **动态规划**：评估所有可能的选择路径，再从中选出全局最优
    >
    > **贪心算法**：在满足条件的前提下，每一步直接选局部最优，并确信不会后悔



典型应用场景包括：

- 区间调度、任务选择
- 最小生成树、最短路径（部分算法）
- 资源分配、排序后的最优选择问题

#### 1.2、贪心算法的基本思维模式

**「贪心算法」**的决策过程高度统一

1. 定义“什么是当前最优”
2. 在当前状态下选择最优解
3. 更新问题规模
4. 重复上述过程，直到问题结束

<!--贪心不关心未来的完整展开，只关心当前这一步是否足够好-->

#### 1.3、与其他算法思想的区别

**贪心 vs 回溯**

| 维度 | 贪心算法 | 回溯算法 |
|---|---|---|
| 决策方式 | 每步只选一个最优 | 枚举所有可能 |
| 是否回退 | 否 | 是 |
| 时间复杂度 | 低 | 高（通常指数级） |
| 适用场景 | 选择路径唯一的问题 | 解空间复杂、约束多的问题 |

**本质区别：**  贪心相信当前选择，回溯不相信任何选择

**贪心 vs 动态规划**

| 维度               | 贪心算法 | 动态规划   |
| ------------------ | -------- | ---------- |
| 是否要求最优子结构 | 是       | 是         |
| 是否枚举所有选择   | 否       | 是         |
| 是否比较历史状态   | 否       | 是         |
| 是否回退           | 否       | 是（隐含） |
| 对局部最优的态度   | 直接采信 | 全量验证   |

**本质区别：**  贪心是“只看眼前一步”，动态规划是“系统性比较所有可能的历史状态”

<!--能用贪心的问题，一定能用动态规划；能用动态规划的问题，未必能用贪心-->

**总结：**

**「回溯算法」**通过剪枝减少无效搜索，但本质仍是在可行解空间中进行指数级枚举

**「动态规划」**通过备忘录消除重复子问题，将指数级搜索压缩为有限状态计算，复杂度通常下降为多项式级

二者的共同点在于：**都需要系统性地覆盖所有可能的状态或路径，才能保证最优解的正确性**

而**「贪心算法」**的根本不同在于： 在特定问题中，不必穷举所有可能，就可以**通过局部最优选择直接推导出全局最优解**，从而降低计算成本

一句话总结：**回溯和动态规划通过“减少无效穷举”提升效率，而贪心算法通过“避免穷举本身”提升效率**

### 二、跳跃游戏

**描述：**

给定一个非负整数数组 `nums` ，最初位于数组的**第一个下标** ，数组中的每个元素代表在该位置可跳跃的最大长度

判断是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标
```

 **思路：**

- 这是一个**可行性判断问题**，不是最值问题

- 这个问题具备**贪心选择性质**：

  - 只需要关心**目前最远能到哪**，将当前能到达的位置区间不断向右扩展
  - 不需要关心具体是从哪一步跳过去的，最后能到达终点只需看**区间右侧**能否到达终点
    - **区间右侧**表示，区间内“某一个起点”所能达到的**最远位置**


  <!--换句话说：到达同一个位置之前的路径细节，对后续是否能继续前进没有影响-->

- 在遍历过程中，始终维护当前能到达的**最远位置**，只要这个最远位置能够覆盖终点，就说明可达

  <!--也就是说每次都找最远位置-->
  
  ```
  maxReach = max(maxReach, i + nums[i])
  ```

**题解：**

```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function (nums) {
  // 当前能到达的最远位置
  let maxReach = 0
  const last = nums.length - 1

  // 遍历可达区间内的每个元素，同时将区间不断往右拓展
  for (let i = 0; i <= maxReach; i++) {
    // 更新最远位置
    maxReach = Math.max(maxReach, i + nums[i])
    // 当最远位置覆盖了终点，则说明终点可达
    if (maxReach >= last) return true
  }

  return false
}
```

**解析：**

- 初始化可达区间的终点为数组的第一个元素
- 遍历可达区间内的每个元素，更新可达区间终点
  - 由于终点是动态的，所以遍历的次数也是动态变化的
- 遍历结束条件
  - 区间终点覆盖了数组终点
  - 区间内所有元素都遍历一遍了，但区间终点没有覆盖数组终点
