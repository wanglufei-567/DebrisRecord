### 写在前面

#### 名词解释

- 协议栈
  - 解释：计算机网络控制软件
  - 作用：将应用信息打包并加上目的地地址等控制信息；用快递来类比，就是将快递打包然后再写上发件人和收件人信息；当然还有其他功能，如发生通信错误时重新发包、调节发送效率等
- 网卡
  - 解释：负责以太网或无线网络通信的硬件
  - 作用：将应用信息转换为电信号通过网络发出去
- Socket库
  - 解释：Socket库是用于调用网络功能的程序组件集合，是操作系统内置的网络库
  - 作用：Socket库中包含很多用于发送和接受数据的程序组件
- 套接字
  - 解释：套接字只是个概念没有实体，若一定要赋予它一个实体，那协议栈中存放的控制信息就是套接字
  - 作用：协议栈内部中存在一块内存空间，记录了用于控制通信操作的控制信息，比如：通信对象的IP地址、端口号、通信操作的进行状态等
- 描述符
  - 作用：应用程序通过”描述符“这一类似于号码牌的东西来识别套接字
- 端口号
  - 作用：识别应用程序的套接字的，客户端和服务端之间用来识别对方套接字的机制

#### 类比理解

- 包(Packet)：类似于快递中的概念，**包**相当于快递包裹，而路由器和交换机则相当于快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据这些控制信息进行分拣，然后将它们一步一步地搬运到目的地。
- 网络: 搬运网络包（数字信息）的机制加上浏览器、服务器这些网络应用程序就构成了网络的全貌
- IP地址：相当于现实中的XX号XX室一样，IP地址就是网络中的地址，”号“对应的是网络号，”室“对应的是主机号
- 子网掩码：IP地址是32比特的数字，按照8比特一组分为四组，再用十进制表示，包含了网络号和主机号，子网掩码是表示网络号和主机号的边界

------

### 从在浏览器输入URL到页面加载内容

1. ##### 解析URL生成HTTP请求信息
   1. HTTP协议定义了客户端和服务端交互的信息内容和步骤；HTTP请求消息中包含的内容是“对什么”和“进行怎么样的操作”两个部分；“对什么”部分是URI，“进行怎么样的操作”是方法；
   2. 浏览器虽然可以解析URL生成HTTP请求消息，但浏览器本身是不具备将消息发送到网络中的功能的；因此需要委托操作系统实现；在委托操作系统发送消息时，必须要提供服务端的Ip地址，所以在根据URL生成请求消息之后，下一步骤就是获取服务端IP地址；

2. ##### DNS域名解析

   1. 浏览器调用Socket库中的DNS解析器查询IP地址
      - 查询IP地址其实也是一次网络通信，是Socket库和DNS服务器的通信，**DNS服务器的IP地址已经配置在系统里面了**，传输层的协议使用的是UDP协议而不是TCP协议（*为什么是UDP？后面再补充*）
      - 查询到IP地址之后，Scoket库会将IP地址写入到浏览器提供的内存中去，**服务端的IP地址是存在浏览器中的**

3. ##### 委托协议栈发送消息（其实就是建立TCP连接，根据IP地址和默认80端口，和服务器建立TCP连接）

   知道了IP地址之后就可以委托操作系统内部的协议栈向这个目标IP地址发送消息了

   - 首先，客户端应用程序传递ip地址和端口给系统协议栈，协议栈中的tcp模块会将这些信息写入头部，tcp模块又委托ip模块进行消息传递；  
   -  当消息传递到服务端之后（服务端的服务进程是默认打开且待连接状态），服务端的tcp模块会根据客户端传递过来的端口号找到对应的套接字（协议栈中内存保存的控制信息）并且对应套接字会写入客户端的ip地址并修改连接状态为正在连接（默认是未连接），操作完成后服务端会返回响应给客户端，在返回头部中写入信息（ACK，用来告诉客户端收到请求的信息了）； 
   -  当客户端的tcp模块收到响应信息后会根据响应头判断是否连接成功，连接成功的话会将服务端的ip和端口等信息写入到自己的套接字中，并修改连接状态为连接完毕，并再次发送信息（还是只有头部信息，没有具体的数据）给服务端，通知服务端自己收到了刚才的响应信息

   （其实以上的过程就是TCP的三次握手，按照自己的理解去写的，有点拉胯，有单独的TCP协议笔记，比较详细）

   <!--三次握手的语义化理解就是：第一次握手：客户端向服务端发送消息说我要建立连接（SYN：1, seq:j）;第二次握手：服务端向客户端发送消息说同意进行连接（SYN：1,ACK:1,ack:j+1,seq:x）;第三次握手：客户端向服务端发送消息说连接成功了可以通信了（ACK:1, ack:x+1）其实做的事情主要是交换ack和seq，要保证后面通信的时候的数据的完整性-->
   
   
   
   <!--四次挥手的语义化理解就是：第一次挥手：客户端向服务端发送消息说我要断开连接了（FIN：M）;第二次挥手：服务端向客户端发送消息说收到了（ack: M+1）;第三次挥手：服务端向客户端发送消息说我也要断开连接了（FIN：N）; 第四次挥手：客户端向服务端发送消息说收到了（ACK：1，ack:k+1）-->
   
   







