## 二分查找算法

### 一、前言

**二分查找（Binary Search**）是在**有序**（或可单调判定）的搜索空间中，通过每次将**搜索区间折半**来快速定位目标的位置或答案的算法

其时间复杂度为 $O(\log n)$，远优于线性扫描的 $O(n)$。

**主要应用场景：**

- **有序数组定位**：在升序/降序数组中查找某个值或其插入位置

- **边界问题**：寻找“第一个 ≥ 目标”、“最后一个 ≤ 目标”、“第一个满足条件的位置”等

- **答案空间单调**：虽然原数据未排序，但**判定函数**关于答案是单调的

  例如：

  - 最小可行值/最大可行值（最小化最大值、最大化最小值类问题）
  - 按难度/容量/时间上界做 “是否可行” 判定（如装载、排班、带宽分配）

**核心思想**

- 明确**搜索空间**（索引区间或答案区间）
- 设计**单调判定**：一个布尔函数 `check(x)`，使得当 `x` 增大（或减小）时，`check` 结果呈单调
- 每次取中点 `mid`，依据 `check(mid)` 真/假，**丢掉一半区间**
- 循环至区间收敛，返回边界或位置

**简单分类：**

- **闭区间 [l, r] **：适合精确查找、找“最后一个满足”
- **半开区间 [l, r) **：适合找“第一个满足”（lower_bound 风格），不易越界

**模板：**

-  **经典闭区间 [l, r] 二分**：用于精确等值查找

  ```javascript
  /**
   * 若找到返回索引；否则返回 -1
   */
  function binarySearchEqual(arr, target) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
      const mid = left + Math.floor((right - left) / 2);
      if (arr[mid] === target) return mid;
      if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return -1;
  }
  ```

- **半开区间 [left, right) 二分**：**lower_bound**

  > **定义**：在一个有序数组中，找到第一个 **大于等于 target** 的元素的索引
  >
  > - 如果数组中有元素等于 target，会返回最左边的那个
  >
  > - 如果所有元素都小于 target，则返回 `arr.length`（即“插入到最后”）

  ```javascript
  /**
   * 返回“第一个 >= target 的索引”，若不存在则返回 arr.length
   */
  function lowerBound(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
      const mid = left + Math.floor((right - left) / 2);
      if (arr[mid] >= target) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    return left;
  }
  ```

  - 关键点解析：
    -  `right` 起始值是 `arr.length`
    - 条件是 `arr[mid] >= target` → 往左收缩 `right = mid`
    - 最终 `left ` 会等于 `right` 并且停在第一个满足 `arr[left] >= target` 的位置

- **半开区间 [left, right) 二分**：**upper_bound**

  > **定义**：在一个有序数组中，找到第一个 **大于 target** 的元素的索引
  >
  > - 如果数组中有多个等于 target 的元素，它会越过这些元素，返回第一个大于 target 的位置
  > - 如果所有元素都小于等于 target，则返回 `arr.length`

  ```javascript
  /**
   * 返回“第一个 > target 的索引”，若不存在则返回 arr.length
   */
  function upperBound(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
      const mid = left + Math.floor((right - left) / 2);
      if (arr[mid] > target) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    return left;
  }
  ```

  - 关键点解析：
    -  `right` 起始值是 `arr.length`
    - 条件是 `arr[mid] > target` → 往左收缩
    - 最终 `left ` 会等于 `right` 并且停在第一个满足 `arr[left] > target` 的位置

  > `lowerBound` 和 `upperBound` 经常配合使用，用来**统计某个值在有序数组中出现的次数**，或者直接把所有等于 `target` 的元素所在区间拿出来
  >
  > 原理：
  >
  > - `lowerBound(arr, target)` 会返回 **第一个 `>= target` 的位置**（最左边的索引）
  > - `upperBound(arr, target)` 会返回 **第一个 `> target` 的位置**（最右边的索引的下一个）
  >
  > 因此 `count = upperBound(arr, target) - lowerBound(arr, target);` 就等于 **数组中 `target` 出现的次数**
  >
  > 另外，找“**最后一个 <= target**”的索引，可由 `upperBound - 1` 得到

