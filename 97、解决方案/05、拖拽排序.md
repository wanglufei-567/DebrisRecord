## 拖拽排序

### 一、**Web** 拖拽交互概述

拖拽（**Drag and Drop**）交互是现代 **Web** 应用中非常重要的用户交互方式；它允许用户通过鼠标或触摸手势来移动、重新排列或传输界面元素，提供了直观、自然的操作体验

**常见的拖拽交互场景**

- **文件上传**：将文件从本地拖拽到浏览器上传区域
- **任务管理**：在看板应用中拖拽任务卡片在不同列之间移动
- **列表排序**：通过拖拽重新排列列表项目的顺序
- **界面布局**：拖拽组件来自定义页面布局
- **数据传输**：在不同容器之间移动数据项

### 二、主流拖拽交互工具库

- **React DnD**

  - **特点**：基于 **HTML5** 拖拽 **API**，使用 **Redux** 架构

  - **优势**：成熟稳定，功能强大，社区活跃

  - **劣势**：学习曲线陡峭，配置复杂，体积较大


- **React Beautiful DnD**

  - **特点**：专注于列表排序，视觉效果优美

  - **优势**：易于使用，动画流畅，性能优秀

  - **劣势**：功能相对单一，主要适用于垂直列表


- **SortableJS**

  - **特点**：原生 **JavaScript** 实现，框架无关

  - **优势**：轻量级，兼容性好，支持多种排序模式

  - **劣势**：**React** 集成需要额外封装


- **dnd-kit**

  - **特点**：现代化的拖拽工具库，专为 **React** 设计

  - **优势**：高性能、模块化、可访问性友好、**TypeScript** 支持

  - **劣势**：相对较新，社区生态还在发展中


### 三、**dnd-kit** 基础使用

**dnd-kit** 是一个现代化的 **React** 拖拽工具库，采用模块化设计，提供了高性能和出色的可访问性支持

**dnd-kit** 采用了分层架构设计：

- **@dnd-kit/core**：核心拖拽功能
- **@dnd-kit/sortable**：排序功能扩展
- **@dnd-kit/utilities**：工具函数集合

#### 3.1、基础概念

- **DndContext** - 拖拽上下文
  - 拖拽功能的根容器，提供拖拽环境和全局配置。它管理着整个拖拽过程的状态和事件

- **传感器（Sensors）** - 输入检测
  - 传感器负责检测用户的输入行为，支持鼠标、触摸等不同设备。激活约束可以防止误触发拖拽操作

- **可拖拽元素（Draggable）**
  - **useDraggable** **Hook** 将普通元素转换为可拖拽元素，返回必要的属性和方法

- **接收区域（Droppable）**
  - **useDroppable** **Hook** 创建可接收拖拽的区域，提供悬停状态反馈

-  **事件处理**
  - 拖拽事件包含完整的拖拽信息，允许开发者根据拖拽结果更新应用状态

以下是一个完整的基础拖拽示例 `BasicDragDrop.tsx`：

```tsx
import React, { useState } from 'react'
import {
  DndContext,           // 拖拽上下文容器，提供拖拽功能的根组件
  DragEndEvent,         // 拖拽结束事件类型，包含拖拽结果信息
  PointerSensor,        // 指针传感器，用于检测鼠标/触摸拖拽操作
  useSensor,            // 创建传感器的 Hook
  useSensors,           // 组合多个传感器的 Hook
  closestCenter,        // 碰撞检测算法，选择距离中心最近的元素
  useDraggable,         // 使元素可拖拽的 Hook
  useDroppable,         // 使元素可接收拖拽的 Hook
} from '@dnd-kit/core'
import './BasicDragDrop.css'

interface DraggableItemProps {
  id: string
  children: React.ReactNode
}
```

可托拽元素

```javascript
/**
 * 可拖拽元素组件
 * 使用 useDraggable Hook 使元素支持拖拽功能
 */
function DraggableItem({ id, children }: DraggableItemProps) {
  // useDraggable Hook：将元素标记为可拖拽
  // 返回拖拽相关的属性和方法
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: id,  // 拖拽元素的唯一标识符
  })

  // 根据拖拽变换计算样式
  // transform 包含拖拽过程中的位置偏移量
  const style = transform ? {
    transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`,
  } : undefined

  return (
    <div
      ref={setNodeRef}        // 设置拖拽元素的 DOM 引用
      style={style}           // 应用拖拽变换样式
      {...listeners}          // 绑定拖拽事件监听器（鼠标按下、移动等）
      {...attributes}         // 绑定拖拽相关的 DOM 属性（aria 属性等）
      className="draggable-item"
    >
      {children}
    </div>
  )
}

interface DroppableZoneProps {
  id: string
  children: React.ReactNode
}
```

接收拖拽的区域

```javascript
/**
 * 可接收拖拽的区域组件
 * 使用 useDroppable Hook 使区域能够接收拖拽的元素
 */
function DroppableZone({ id, children }: DroppableZoneProps) {
  // useDroppable Hook：将元素标记为可接收拖拽
  // 返回拖拽悬停状态和 DOM 引用
  const { isOver, setNodeRef } = useDroppable({
    id: id,  // 接收区域的唯一标识符
  })

  return (
    <div
      ref={setNodeRef}        // 设置接收区域的 DOM 引用
      className={`drop-zone ${isOver ? 'over' : ''}`}  // 根据悬停状态添加样式
    >
      {children}
    </div>
  )
}
```

基础拖拽演示组件

```javascript
function BasicDragDrop() {
  // 管理拖拽元素的状态
  // 每个元素包含 id、内容和所属区域信息
  const [items, setItems] = useState([
    { id: '1', content: '拖拽我 1', zone: 'source' },
    { id: '2', content: '拖拽我 2', zone: 'source' },
    { id: '3', content: '拖拽我 3', zone: 'source' },
  ])

  // 配置拖拽传感器
  // useSensors：组合多个传感器
  // useSensor：创建单个传感器实例
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,  // 激活约束：需要拖拽 8px 距离才激活拖拽
      },
    })
  )

  /**
   * 处理拖拽结束事件
   * @param event 拖拽结束事件对象
   */
  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event
    // active：当前被拖拽的元素信息
    // over：拖拽悬停的目标元素信息

    console.log(active, over)

    if (over) {
      // 如果拖拽到了有效的接收区域
      setItems(items =>
        items.map(item =>
          item.id === active.id
            ? { ...item, zone: over.id as string }  // 更新元素的所属区域
            : item
        )
      )
    }
  }

  // 根据区域过滤元素
  const sourceItems = items.filter(item => item.zone === 'source')
  const targetItems = items.filter(item => item.zone === 'target')

  return (
    <div className="demo-section">
      <h2>基础拖拽演示</h2>
      <p>将左侧的元素拖拽到右侧区域</p>

      {/* DndContext：拖拽功能的根容器，提供拖拽上下文 */}
      <DndContext
        sensors={sensors}                    // 配置拖拽传感器
        collisionDetection={closestCenter}   // 设置碰撞检测算法
        onDragEnd={handleDragEnd}           // 拖拽结束时的回调函数
      >
        <div className="basic-container">
          <div className="source-area">
            <h3>源区域</h3>
            <DroppableZone id="source">
              {sourceItems.length === 0 ? (
                <p className="empty-message">空</p>
              ) : (
                sourceItems.map(item => (
                  <DraggableItem key={item.id} id={item.id}>
                    <div className="item-content">
                      📦 {item.content}
                    </div>
                  </DraggableItem>
                ))
              )}
            </DroppableZone>
          </div>

          <div className="target-area">
            <h3>目标区域</h3>
            <DroppableZone id="target">
              {targetItems.length === 0 ? (
                <p className="empty-message">拖拽到这里</p>
              ) : (
                targetItems.map(item => (
                  <DraggableItem key={item.id} id={item.id}>
                    <div className="item-content">
                      ✅ {item.content}
                    </div>
                  </DraggableItem>
                ))
              )}
            </DroppableZone>
          </div>
        </div>
      </DndContext>
    </div>
  )
}

export default BasicDragDrop
```

### 四、拖拽排序实现

拖拽排序比基础拖拽更复杂，需要处理元素在列表中的位置变化。以下是完整的拖拽排序组件实现：

#### 4.1、通用拖拽排序组件 `DragSortable.tsx`

```tsx
import React from 'react'
import {
    DndContext,
    closestCenter,
    PointerSensor,
    useSensor,
    useSensors,
    DragEndEvent,
} from '@dnd-kit/core'
import {
    useSortable,
    SortableContext,
    verticalListSortingStrategy,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

function arrayMove<T> (array: T[], from: number, to: number): T[] {
    const result = [ ...array ]
    result.splice(to, 0, result.splice(from, 1)[0])
    return result
}

function restrictToVerticalAxis ({ transform }) {
    return {
        ...transform,
        x: 0, // 强制 x 轴偏移为 0，只允许 y 轴移动
    }
}

type DragSortableItem = {
    id: string | number
    [key: string]: any
}

export interface DragSortableProps {
  items: DragSortableItem[]
  onItemsChange: (items: DragSortableItem[]) => void
  renderItem: (param: { item: DragSortableItem, index: number, dragHandleProps: any }) => React.ReactNode
}

export default function DragSortable ({
    items,
    onItemsChange,
    renderItem,
}: DragSortableProps) {
    const sensors = useSensors(
        useSensor(PointerSensor, {
            activationConstraint: { distance: 8 },
        }),
    )

    const handleDragEnd = (event: DragEndEvent) => {
        const { active, over } = event

        if (active.id !== over?.id && over?.id) {
            const oldIndex = items.findIndex(item => item.id === active.id)
            const newIndex = items.findIndex(item => item.id === over.id)

            if (oldIndex !== -1 && newIndex !== -1) {
                onItemsChange(arrayMove(items, oldIndex, newIndex))
            }
        }
    }

    function SortableItem ({ item, index }: { item: DragSortableItem; index: number }) {
        const {
            attributes,
            listeners,
            transform,
            transition,
            setNodeRef,
        } = useSortable({ id: item.id })

        const style = {
            transform: CSS.Transform.toString(transform),
            transition,
        }

        const dragHandleProps = {
            ...listeners,
            style: {
                cursor: 'grab',
            },
        }

        return (
            <div
                ref={setNodeRef}
                style={style}
                className="drag-sortable-item"
                {...attributes}
            >
                {renderItem({ item, index, dragHandleProps })}
            </div>
        )
    }

    return (
        <div className="drag-sortable-container">
            <DndContext
                sensors={sensors}
                collisionDetection={closestCenter}
                onDragEnd={handleDragEnd}
                modifiers={[ restrictToVerticalAxis ]}
            >
                <SortableContext
                    items={items.map(item => item.id)}
                    strategy={verticalListSortingStrategy}
                >
                    <div className="drag-sortable-list">
                        {items.map((item, index) => (
                            <SortableItem
                                key={item.id}
                                item={item}
                                index={index}
                            />
                        ))}
                    </div>
                </SortableContext>
            </DndContext>
        </div>
    )
}
```

#### 4.2、使用拖拽排序组件 `SortableList.tsx`

```tsx
// React 核心库导入
import React, { useState } from 'react'
import { DragSortable } from './DragSortable'
import './SortableList.css'
import './DragSortable.css'

function TaskCard({ item, index, dragHandleProps }: any) {
  return (
    <div className="task-card">
      <span className="task-number">#{index + 1}</span>
      <span className="task-content">{item.content}</span>

      <span
        className="drag-handle"
        {...dragHandleProps}
      >
        ⋮⋮
      </span>
    </div>
  )
}

function SortableList() {
  const [items, setItems] = useState([
    { id: '1', content: '任务 1' },
    { id: '2', content: '任务 2' },
    { id: '3', content: '任务 3' },
    { id: '4', content: '任务 4' },
    { id: '5', content: '任务 5' },
  ])

  const renderTaskItem = (item: any, index: number, dragHandleProps: any) => {
    return (
      <TaskCard
        item={item}
        index={index}
        dragHandleProps={dragHandleProps}
      />
    )
  }

  return (
    <div className="demo-section">
      <h2>可排序列表</h2>
      <p>只能通过拖拽手柄来重新排序</p>

      <div className="sortable-container">
        <DragSortable
          items={items}
          onItemsChange={setItems}
          renderItem={renderTaskItem}
        />
      </div>
    </div>
  )
}

export default SortableList
```
