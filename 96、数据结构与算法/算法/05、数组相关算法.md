## 数组相关算法

### 一、数组去重

#### 1.1、去除重复元素，只保留一个

**描述：**

- 给定一个 **非严格递增排列** 的数组 `nums` ， 删除重复出现的元素，使每个元素 **只出现一次**

**示例：**

```markdown
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
```

**题解：**

```javascript
var removeDuplicates = function(nums) {
  if(nums.length === 0) return 0

  let slow = 0
  let fast = 0

  while(fast < nums.length) {
    // 当索引 slow 的值，不等于索引 fast 的值时，将 slow 索引向前移动一步，并赋值为 fast 索引的值
    if(nums[slow] !== nums[fast]) {
      slow++
      nums[slow] = nums[fast]
    }
    fast++
  }

  return slow + 1
};
```

#### 1.2、去除所有重复元素

**题解：**

```javascript
/**
 * 删除所有重复元素（不保留任何重复项）
 * @param {number[]} nums - 已排序的整数数组
 * @return {number} 去重后数组的有效长度
 *
 * 算法思路：
 * 1. 使用双指针技术遍历已排序数组
 * 2. 对每个元素统计其连续出现的次数
 * 3. 只保留出现次数为1的元素（即唯一元素）
 * 4. 原地修改数组，返回新数组的有效长度
 *
 * 示例：
 * 输入: [1,1,2,3,3]
 * 输出: 1，nums变为[2,_,_,_,_]（只保留唯一元素2）
 *
 * 输入: [0,0,1,1,1,2,2,3,3,4]
 * 输出: 1，nums变为[4,_,_,_,_,_,_,_,_,_]（只保留唯一元素4）
 */
const removeAllDuplicates = function(nums) {
    if (nums.length <= 1) return nums.length;

    let writeIndex = 0; // 写入指针：指向下一个要写入唯一元素的位置

    // 使用读取指针 i 遍历整个数组
    for (let i = 0; i < nums.length; ) {
        let current = nums[i];  // 记录当前正在处理的元素值
        let count = 0;          // 统计当前元素的连续出现次数

        // 内层循环：统计当前元素的连续出现次数
        // 由于数组已排序，相同元素必定连续出现
        while (i < nums.length && nums[i] === current) {
            count++;    // 计数器递增
            i++;        // 读取指针向前移动
        }

        // 判断是否为唯一元素：只有出现次数为1的元素才保留
        if (count === 1) {
            nums[writeIndex] = current;  // 将唯一元素写入到writeIndex位置
            writeIndex++;                // 写入指针向前移动
        }
        // 如果count > 1，说明是重复元素，直接跳过不写入
    }

    // 返回去重后数组的有效长度
    // 此时nums[0...writeIndex-1]包含所有唯一元素
    return writeIndex;
};
```

#### 1.3、保留最多k个重复元素

**描述：**

- 给定一个 **非严格递增排列** 的数组 `nums` ， 删除重复出现的元素，使每个元素 **只出现 k 次**

**示例：**


```markdown
输入：nums = [1,1,2,2,3,3,3,4,4,5], k = 2
输出：5, nums = [1,1,2,2,3,3,4,4,5,_]
```

**题解：**

```javascript
// 保留最多k个重复元素的通用解法
var removeDuplicatesK = function(nums, k) {
    let slow = 0;

    for (let fast = 0; fast < nums.length; fast++) {
        if (slow < k || nums[fast] !== nums[slow - k]) {
            nums[slow] = nums[fast];
            slow++;
        }
    }

    return slow;
};

// 本题就是k=2的特殊情况
var removeDuplicates = function(nums) {
    return removeDuplicatesK(nums, 2);
};
```

**解析：**

- 使用快慢双指针遍历数组
- 当 `slow` 指针小于 `k` 时，不需要判断，直接保留当前元素，因为必定不会重复 `k` 次
- 当 `slow` 指针大于等于 `k` 时，判断当前元素是否保留
  - 如果 `nums[fast] !== nums[slow - k]` ，这就说明了即使 `slow` 指针前面 `k - 1` 个元素都是相同，`fast` 指针的元素与其也不相同，则说明当前 `fast` 指针的元素不会重复 `k` 次，可以保留

### 二、数组中 n 数之和

#### 2.1、两数之和

**描述：**

- 给定一个非递减顺序排列的整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和 为目标值 `target` 的那两 整数，并返回它们的数组下标

**示例：**

```markdown
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**题解 1：头尾双指针**

因为是有序数组所以优先考虑双指针解法

```javascript
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 * 数组是有序的优先考虑双指针解法
 * 这里使用的是头尾双指针
 * 若是sum > target 则说明尾指针的元素太大了，与最小值相加都大于target，所以尾指针需要左移
 * 若是sum < target 则说明头指针的元素太小了，与最大值相加都小于target，所以头指针需要右移
 * 若是sum === target 则说明找到了，返回头指针和尾指针的索引+1
 */
var twoSum = function(numbers, target) {
  let left = 0
  let right = numbers.length - 1

  while(left < right) {
    const sum = numbers[left] + numbers[right]
    if( sum === target) {
      return [left, right]
    } else if (sum > target) {
      right--
    } else {
      left++
    }
  }
};
```

**解析：**

- 因为原数组是已经排过序的，所以完全可以通过首尾相加，来将不符合的元素排除掉

**题解 2：哈希表**

哈希表的解法更为通用，数组没有排序也能使用

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  const map = new Map()
  for(let i = 0; i < nums.length; i++) {
    // 得到差值
    const complement = target - nums[i]
    // 若是哈希表中存在差值，说明之前遍历到该元素了
    if(map.has(complement)) {
      return [map.get(complement), i]
    }
    map.set(nums[i], i)
  }
};
```

### 三、前缀和

**前缀和（Prefix Sum）**的是指**通过预处理，把数组的部分和问题转化为两个前缀和的差，从而避免重复计算**
 公式如下：
$$
sum(l,r) = prefix[r] - prefix[l-1]
$$
其中：

- `prefix[i]` 表示前 i 个元素的和
- `prefix[0] = 0`，方便统一计算公式

这样，原本 **O(n)** 的区间求和可以在 **O(1)** 时间内完成

**适用场景：**

1. 多次区间和查询
2. 子数组和问题（配合哈希表）
3. 二维区域和查询
4. 与差分数组结合

#### 3.1、一维前缀和 - 区域和检索 - 数组不可变

```javascript
class NumArray {
  constructor(nums) {
    // 定义一个前缀和数组，起始只有一个元素，prefix[0] === 0
    this.prefix = [0];
    
    // 从 0 开始遍历目标数组，不断的将计算出来的元素和 push 到前缀和数组中
    // 注意：prefix(i+1) 才是前 i 项元素的和
    for (let i = 0; i < nums.length; i++) {
      this.prefix.push(this.prefix[i] + nums[i]);
    }
  }

  // 获取 [left, right] 区间的元素和，相当于前 right 项元素和减去前 left-1 项元素和
  // 等价于 prefix(right+1) - prefix(left)
  sumRange(left, right) {
    return this.prefix[right + 1] - this.prefix[left];
  }
}

// 用法示例
const obj = new NumArray([-2, 0, 3, -5, 2, -1]);
console.log(obj.sumRange(0, 2)); // 1
console.log(obj.sumRange(2, 5)); // -1
console.log(obj.sumRange(0, 5)); // -3
```

### 四、差分数组

**差分数组（Difference Array**）是前缀和的“逆操作”

- 前缀和：用来 **快速求区间和**
- 差分数组：用来 **快速做区间修改**

给定一个数组 `nums`，它的差分数组 `diff` 定义为：
$$
diff[i] = nums[i] - nums[i-1], \quad i \geq 1
$$
通常设定：

- `diff[0] = nums[0]`

- 原数组可以通过前缀和还原：
  $$
  nums[i] = diff[0] + diff[1] + ... + diff[i]
  $$

<!--起始就是将当前元素和前一个元素的差值保存到数组，还原的时候就是从第一个元素开始逐渐加上差值就可以了-->

**适用场景**：

1. **区间加法操作频繁**

   - 如果对数组的区间 `[l, r]` 不断执行 “每个元素都加上 `val`”，直接操作 **O(n)**，很慢

   - 差分数组只需 **O(1)** 修改：

     ```
     diff[l] += val
     diff[r+1] -= val
     ```

   - 最终再通过前缀和还原数组

2. **需要高效处理多个区间更新**

   - 比如区间增加、区间减少的批量操作

**差分数组模板：**

```javascript
class Difference {
    constructor(nums) {
        // 差分数组
        this.diff = new Array(nums.length);
        // 根据初始数组构造差分数组，通常 diff[0] = nums[0]
        this.diff[0] = nums[0];
        for (let i = 1; i < nums.length; i++) {
            this.diff[i] = nums[i] - nums[i - 1];
        }
    }

    // 给闭区间 [i, j] 增加 val（可以是负数）
    increment(i, j, val) {
        this.diff[i] += val;
        if (j + 1 < this.diff.length) {
            this.diff[j + 1] -= val;
        }
    }

    // 返回结果数组
    result() {
        let res = new Array(this.diff.length);
        // 根据差分数组构造结果数组
        res[0] = this.diff[0];
        for (let i = 1; i < this.diff.length; i++) {
            res[i] = res[i - 1] + this.diff[i];
        }
        return res;
    }
}
```

#### 4.1、区间加法

**描述：**给定数组长度 `n` 和一组操作，每个操作 `[l, r, val]` 表示区间 `[l, r]` 上每个元素加 `val`，返回最终数组

```javascript
function getModifiedArray(n, updates) {
  const diff = new Array(n).fill(0);

  // 这里很简单，diff[l] += val，diff[r+1] -= val
  for (let [l, r, val] of updates) {
    diff[l] += val;
    if (r + 1 < n) diff[r + 1] -= val;
  }

  // 这里很关键，还原数组
  const res = new Array(n).fill(0);
  res[0] = diff[0];
  // 当前元素值等于前一个元素加上差值
  for (let i = 1; i < n; i++) {
    res[i] = res[i - 1] + diff[i];
  }

  return res;
}

// 示例
console.log(getModifiedArray(5, [[1, 3, 2], [2, 4, 3], [0, 2, -2]]));
// 输出: [-2, 0, 3, 5, 3]
```

