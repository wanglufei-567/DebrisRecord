## 常见的数据结构

### 一、前言

#### 1.1、数据结构是什么？

在计算机科学中，**数据结构**（**data structure**）是一种==**存储**==和==**组织**==数据的方式，目的是为了高效地**==访问==**和**==修改==**数据，数据结构的选择对算法的效率有很大的影响，可以极大地优化程序的性能

**数据结构**的主要包括：**数据内容**、**数据之间关系**、**数据操作方法**

**数据结构**具有以下设计目标：

- 空间占用尽量少，以节省计算机内存 <!--数据内容相关-->
- 提供简洁的数据表示和逻辑信息，以便算法高效运行 <!--数据之间关系相关-->
- 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等操作 <!--数据操作方法相关-->

一句话概括：**数据结构的本质是一种为了高效地对数据进行增删改查而对数据进行有序组织和存储的设计方案**

#### 1.2、常见的数据结构

常用的**数据结构**主要包括以下几种：

1. **栈（Stack）**：栈是一种**后进先出**（**LIFO**）的数据结构，添加或删除元素都发生在同一端，这一端被称为栈顶

2. **队列（Queue）**：队列是一种**先进先出**（**FIFO**）的数据结构，新元素加在队列的尾部，删除元素发生在队列的头部

3. **链表（Linked List）**：链表也是一种线性结构，但其元素在内存中不是连续存储的

   - 每个元素（节点）包含数据部分和指向下一个节点的指针

   - ==链表允许在任何位置高效地插入和删除元素==

4. **二叉树（Binary Tree）**：二叉树是每个节点最多有两个子树的树结构（通常为左子树和右子树）

   - 特殊类型的二叉树，如二叉搜索树、AVL树、红黑树等
   - 支持高效的数据查找、插入和删除操作

5. **图（Graph）**：图是由节点（也称为顶点）和边组成的集合

   - 节点可能代表某种实体，边则表示节点间的关系
   - 图可以是有向的或无向的
   

#### 1.3、数据结构的存储方式

所有复杂的**数据结构**，最终都可以归结为**「数组」**或**「链表」**的变种

不同的应用场景和优化需求决定了它们的实现方式，但底层存储本质上只有两种：**「数组」**和**「链表」**

**数组**：

- **优点**：连续存储，支持随机访问，查找速度快，存储空间节省

- **缺点**：扩容时需要重新分配并复制数据，插入和删除操作时需要移动元素，时间复杂度为 **O(N)**

  <!--数组适合查找元素O(1)，不适合动态插入和删除元素O(n)，这里的数组和 JS 中的数组有一定区别，插入和删除操作需要移动后面元素的位置-->

**链表**：

- **优点**：不需要连续存储，插入和删除操作可以在 **O(1)** 时间内完成，不需要扩容问题

- **缺点**：不能随机访问元素，查找速度较慢；每个元素需要额外的指针来存储前后元素，增加了空间开销

  <!--链表适合动态插入和删除元素 O(1)，不适合查找元素O(n)-->

#### 1.4、数据结构的基本操作

**对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改**

**「遍历」**是所有数据结构都必须支持的**最基本**、**最通用**的访问操作，它确保我们能够系统地访问结构内的全部或部分元素

除了**「遍历」**这一最通用的访问操作之外，各种数据结构通常还会内置以下基础能力：

- **插入（Insert / Add）：** 将新元素高效地加入结构中，同时保持结构的合法性和预期的性能
  - 例如平衡树的旋转、哈希表的扩容
- **删除（Delete / Remove）：** 移除指定元素，并保持结构的正确性和一致性
  - 例如堆的下滤、链表的指针重连
- **搜索 / 定位（Search / Lookup）：** 根据关键字或条件在结构中查找元素，强调高效索引和定位
  - 例如哈希表的哈希函数、二分搜索树的对数级查找
- **更新（Update）：** 修改已存在元素的值或属性，可能涉及调整结构以维持约束
  - 例如优先队列更新后重新排序
- **排序（Sort / Maintain Order）：** 有些结构自带有序性要求
  - 例如如平衡搜索树、B 树、跳表，在插入、删除后需要维护全局或局部顺序
- **合并 / 分割（Merge / Split）：** 特殊场景下的数据结构支持高效合并或分割
  - 例如可并堆、B 树拆分

数据结构的本质使命是为了在特定应用场景下高效地支持「增、删、查、改」四类基本操作

### 二、栈

栈是一种遵从**==后进后出==**原则（**LIFO, Last In First Out**）的有序集合，新添加或待删除的元素都保存在站的同一端，称为**栈顶**，另一端就称为**栈底**；在栈里，新元素都靠近栈顶，旧元素都靠近栈底，这意味着最后被加入到栈中的元素会最先被移除

这种特性使得栈非常适合解决问题时追踪元素的**顺序**，如在函数调用、**撤销操作**在编辑器中的应用、**括号匹配**等场景中 <!--undo/redo，括号匹配挺常见-->

栈的主要操作包括：

1. **Push（压栈）**：将一个元素添加到栈顶
2. **Pop（弹栈）**：移除栈顶的元素，并返回该元素
3. **Top/Peek（访问栈顶元素）**：返回栈顶的元素但不移除它
4. **IsEmpty（检查栈空）**：判断栈是否为空
5. **Size（栈的大小）**：返回栈中元素的数量

由于栈的这些操作通常都是在栈顶进行，因此它们的时间复杂度是 O(1)，即这些操作的执行时间不依赖于栈中数据的多少，非常快速

![栈的先入后出规则](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/stack_operations.png)

#### 2.1、基于数组实现一个栈

具体实现👇：<!--最简单的方式就是直接使用数组，数组本身就具备push,pop 方法，其他栈操作，数组也很容易实现-->

```js
// 基于数组的栈
class ArrayBasedStack {
    constructor() {
        this._elements = []
    }

    // 添加元素到栈顶
    push(element) {
        this._elements.push(element)
    }

    // 从栈顶移出元素
    pop() {
        return this._elements.pop()
    }

    // 获取栈顶元素
    peek() {
        return this._elements[this._elements.length - 1]
    }

    // 检查栈顶是否为空
    isEmpty() {
        return this._elements.length === 0
    }

    // 获取栈中元素个数
    size() {
        return this._elements.length
    }

    // 清空栈
    clear() {
        this._elements = []
    }
}
```

#### 2.2、基于 JS 对象实现一个栈

创建一个 **Stack** 最简单的方式是使用一个数组来存储其元素，但同样需要评估如何操作元素是最高效的

在使用数组时，大部分方法的时间复杂度你是 $O(n)$，最坏的情况下需要迭代整个数组的长度才能找到我们想要的那个元素 <!--其实用对象实现也有这种问题-->

使用 **JS** 对象来存储元素，可以占用更少的内存空间，并且仍然保证所有元素按照我们的需要进行排序

具体实现👇：

```js
class ObjectBasedStack {
    constructor() {
        this._count = 0
        this._elements = {}
    }

    // 添加元素到栈顶
    push(element) {
        this._elements[this._count] = element
        this._count++
    }

    // 检查栈顶是否为空
    isEmpty() {
        return this._count === 0
    }

    // 获取栈中元素个数
    size() {
        return this._count
    }

    // 从栈顶移出元素
    pop() {
        if (this.isEmpty()) return
        this._count--
        const result = this._elements[this._count]
        delete this._elements[this._count]
        return result
    }

    // 获取栈顶元素
    peek() {
        if (this.isEmpty()) return
        return this._elements[this._count - 1]
    }

    // 清空栈
    clear() {
        this._count = 0
        this._elements = {}
    }

    // 展示栈中所有元素
    toString(){
      if(this.isEmpty()) return ''
      let objString = `${this._elements[0]}`
      for(let i = 1; i < this._count; i++) {
        objString=`${objString},${this._elements[i]}`
      }
      return objString
    }
}
```

使用示例：

```js
// 实际应用，二进制转换
function decimalToBinary(decNumber){
  const remStack = new ObjectBasedStack()
  let num = decNumber
  let rem
  let binaryString = ''

  while(num >0) {
    rem = Math.floor(num % 2)
    remStack.push(rem)
    num = Math.floor(num / 2)
  }

  while (!remStack.isEmpty()) {
    binaryString += `${remStack.pop().toString()}`
  }

  return binaryString
}
console.log('result',decimalToBinary(10)); // result 1010
```

### 三、队列

队列（**Queue**）是一种**先进先出**（**FIFO, First In First Out**）的线性数据结构，用于存储元素的集合

在队列中，元素的添加（入队）操作发生在一端，称为**队尾**，而元素的移除（出队）操作发生在另一端，称为**队首**

队列的基本操作包括：

1. **Enqueue（入队）**：在队列的末尾添加一个元素
2. **Dequeue（出队）**：移除队列前端的元素，并返回该元素
3. **Front（查看队首元素）**：返回队列首部的元素但不移除它
4. **IsEmpty（检查队列空）**：判断队列是否为空
5. **Size（队列的大小）**：返回队列中元素的数量

与栈类似，队列的这些操作也通常都是 **O(1)** 时间复杂度，因为它们只涉及队列的头部或尾部，而不需要处理中间的元素

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/format%252Cwebp" alt="img" style="zoom:70%;" />

具体实现👇：

```javascript
class Queue {
  constructor() {
    this.count = 0
    this.lowestCount = 0 // 用于记录队头元素
    this.items = {}
  }

  // 获取队列中元素个数
  size(){
    return this.count - this.lowestCount
  }

  // 检查队列是否为空
  isEmpty() {
    return this.size === 0
  }

  // 向队列添加元素
  enqueue(element){
    this.items(this.count) = element
    this.count++
  }

  // 从队列移出元素
  dequeue(){
    if(this.isEmpty()) return
    const result = this.items[this.lowestCount]
    delete this.items[this.lowestCount]
    this.lowestCount++
    return result
  }

  // 查看队头元素
  peek(){
    if(this.isEmpty()) return
    return this.items[this.lowestCount]
  }

  // 清空队列
  clear(){
    this.items = {}
    this.count = 0
    this.lowestCount = 0
  }

  // 查看元素的方法
  toString() {
    if(this.isEmpty()) return
    let objString = `${this.items[this.lowestCount]}`
    for(let i = this.lowestCount+1; i <this.count; i++){
      objString = `${objString},${this.items[i]}`
    }
    return objString
  }
}
```

使用示例：**击鼓传花**

```javascript
/*
击鼓传花
所有人围成一个圈，把花传递给旁边的人，某一时刻这个花在谁手里，谁就淘汰出局
重复这个过程，直到剩下最后一个人
 */

function hotPotato(list, num){
  const queue = new Queue()
  const eliminatedList = []

  for(let i = 0; i <list.length; i++){
    queue.enqueue(list[i])
  }

  while(queue.size() > 1) {
    for(let i = 0; i < num; i++) {
      queue.enqueue(queue.dequeue()) // 从队头移出一项并将其添加到队尾
    }
    eliminatedList.push(queue.dequeue()) // 一旦达到给定的传递次数就将队首的移出
  }

  return {
    eliminated:eliminatedList,
    winner:queue.dequeue()
  }
}

const result = hotPotato(['John','Jack','Li', 'carl', 'James'], 10)
console.log('eliminated', result.eliminated);
// eliminated [ 'John', 'carl', 'Jack', 'Li' ]

console.log('winner', result.winner);
// winner James
```

这个示例的精髓在于巧妙的利用了队列的入列和出列机制，将队首的元素出列之后再入列，实现了一个**循环队列**

能够指导实际开发中需要**周期性**处理或管理资源的问题，尤其适合于需要**均匀**、**连续处理**任务或数据的场景

<!--在实际应用时，可以利用 JS 数组的 shift 和 push 方法模仿队列的出列和入列-->

#### 3.1、双端队列

**双端队列**（**Double-Ended Queue**）是一种具有队列和栈性质的线性数据结构

与普通队列只允许在一端入队和另一端出队不同，双向队列允许在**两端**都进行**添加**和**删除**操作，这提供了更大的灵活性和应用范围

双向队列的主要操作包括：

1. **添加操作**：
   - **push_front**：在队列的前端添加一个元素
   - **push_back**：在队列的后端添加一个元素

2. **删除操作**：
   - **pop_front**：移除队列前端的元素
   - **pop_back**：移除队列后端的元素

3. **访问操作**：
   - **front**：查看队列前端的元素
   - **back**：查看队列后端的元素

4. **辅助操作**：
   - **isEmpty**：检查队列是否为空
   - **size**：返回队列中的元素数量

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/deque_operations.png" alt="双向队列的操作" style="zoom:50%;" />

```javascript

// 双端队列
class Deque {
    constructor() {
        this.count = 0
        this.lowestCount = 0 // 用于记录队头元素
        this.items = {}
    }

    // 获取队列中元素个数
    size() {
        return this.count - this.lowestCount
    }

    // 检查队列是否为空
    isEmpty() {
        return this.size === 0
    }

    // 像双向队列队尾添加元素
    addBack(element) {
        this.items[this.count] = element
        this.count++
    }

    // 向双向队列队首添加元素
    addFront(element) {
        if (this.isEmpty()) {
            this.addBack(element)
        } else if (this.lowestCount > 0) {
            this.lowestCount--
            this.items[this.lowestCount] = element
        } else {
            for (let i = this.count; i > 0; i--) {
                this.items[i] = this.items[i - 1]
            }
            this.count++
            this.lowestCount = 0
            this.items[0] = element
        }
    }

    // 从队列队首移出元素
    removeFront() {
        if (this.isEmpty()) return
        const result = this.items[this.lowestCount]
        delete this.items[this.lowestCount]
        this.lowestCount++
        return result
    }

    // 从队列队尾移除元素
    removeBack() {
        if (this.isEmpty()) return
        const result = this.items[this.count - 1]
        delete this.items[this.lowestCount - 1]
        this.count--
        return result
    }

    // 查看队头元素
    peekFront() {
        if (this.isEmpty()) return
        return this.items[this.lowestCount]
    }

    // 查看队尾元素
    peekBack() {
        if (this.isEmpty()) return
        return this.items[this.count-1]
    }

    // 清空队列
    clear() {
        this.items = {}
        this.count = 0
        this.lowestCount = 0
    }

    // 查看元素的方法
    toString() {
        if (this.isEmpty()) return
        let objString = `${this.items[this.lowestCount]}`
        for (let i = this.lowestCount + 1; i < this.count; i++) {
            objString = `${objString},${this.items[i]}`
        }
        return objString
    }
}
```

使用示例：**回文检查器**

> 回文是正反都能读通的单词，词组、数字或者一系列字符的序列，例如 madam 或 racecar

```javascript
function palindromeChecker(aString) {
    if (aString === undefined || aString === null || aString.length === 0) return false

    const queue = new Deque()
    const lowerString = aString.toLocaleLowerCase().split(' ').join('')
    let isEqual = true
    let firstChar, lastChar

    for(let i=0; i<lowerString.length ; i++){
      queue.addBack(lowerString.charAt(i))
    }

    while(queue.size() > 1 && isEqual) {
      firstChar = queue.removeFront()
      lastChar = queue.removeBack()
      if(firstChar !== lastChar) {
        isEqual = false
      }
    }

    return isEqual
}

console.log('level', palindromeChecker('level')); // true
console.log('kaka', palindromeChecker('kaka')); // false
```

<!--在实际应用时，可以利用 JS 数组的 shift 和 pop 方法模仿双端队列的队首出列和队尾出列，unshift 和 push 模仿队首入列和队尾入列-->

### 四、链表

链表（**Linked List**）是一种线性数据结构，由一系列节点（**Node**）组成，这些节点通过指针连接在一起；每个节点包含两部分：数据（数据域）和指向下一个节点的指针（指针域）

链表可以分为几种主要类型：

1. **单向链表（Singly Linked List）**：
   - 每个节点只包含一个指针，指向下一个节点
   - 最后一个节点的指针指向`null`，表示链表的末尾
2. **双向链表（Doubly Linked List）**：
   - 每个节点包含两个指针：一个指向下一个节点，一个指向前一个节点
   - 这种结构允许从链表的任意节点向前或向后遍历
3. **循环链表（Circular Linked List）**：
   - 链表中的最后一个节点的指针指向第一个节点，形成一个环状结构
   - 可以是单向循环链表，也可以是双向循环链表

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/linkedlist_common_types.png" alt="常见链表种类" style="zoom:50%;" />

#### 4.1、单向链表

具体实现👇：

```javascript
function defaultEquals(a, b) {
  return a === b
}

class Node {
  constructor(element) {
    this.element = element
    this.next = undefined // 指针
  }
}

class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0
    this.head = undefined // 用于记录表头
    this.equalsFn = equalsFn
  }

  // 向链表尾添加一个元素
  push(element) {
    const node = new Node(element)
    let current
    if (this.head === undefined) {
      this.head = node
    } else {
      current = this.head
      // 找到表尾的元素
      while (current.next !== undefined) {
        current = current.next
      }
      current.next = node
    }
    this.count++
  }

  // 返回链表中特定位置的元素
  getElementAt(index) {
    if (index >= 0 && index <= this.count) {
      let node = this.head
      for (let i = 0; i < index && node !== null; i++) {
        node = node.next
      }
      return node
    }
    return undefined
  }

  // 向链表特定位置插入一个元素
  insert(element, index) {
    if (index >= 0 && index <= this.count) {
      const node = new Node(element)
      if (index === 0) { // 表头插入
        const current = this.head
        node.next = current
        this.head = node
      } else { // 其他位置插入
        const previous = this.getElementAt(index - 1)
        const current = previous.next
        previous.next = node
        node.next = current
      }
      this.count++
      return true
    }
    return false
  }

  // 从链表指定位置移出一个元素
  removeAt(index) {
    if (index >= 0 && index <= this.count) {
      let current = this.head
      if (index === 0) { // 表头移出
        this.head = current.next
      } else { // 其他位置移出
        const previous = this.getElementAt(index - 1)
        current = previous.next
        previous.next = current.next
      }
      this.count--
      return current.element
    }
    return undefined
  }

  // 返回元素在链表中的索引
  indexOf(element) {
    let current = this.head
    for (let i = 0; i < this.count && current !== null; i++) {
      if (this.equalsFn(element, current.element)) return i
      current = current.next
    }
    return -1
  }

  // 从链表中移出一个元素
  remove(element) {
    const index = this.indexOf(element)
    this.removeAt(index)
  }

  // 返回链表元素个数
  size() {
    return this.count
  }

  // 检查链表是否为空
  isEmpty() {
    return this.size() === 0
  }

  // 返回表示整个链表的字符串
  toString() {
    if (this.head === undefined) {
      return ''
    }
    let objString = `${this.head.element}`
    let current = this.head.next
    for (let i = 1; i < this.size() && current !== undefined; i++) {
      objString = `${objString}${current.next.element}`
      current = current.next
    }
    return objString
  }
}
```

#### 4.2、双向链表

在单向链表中，若是迭代错过了要找的元素，就需要回到起点，从新开始迭代

而双向链表则不需要，相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，即可以从头到尾遍历，也可以从尾到头遍历

**双向链表的结构：**

一个双向链表的节点通常包含以下三个部分：

1. **数据域（data）**：存储节点的数据。
2. **前驱指针（prev）**：指向前一个节点。
3. **后继指针（next）**：指向后一个节点。

```mathematica
[prev | data | next] <-> [prev | data | next] <-> [prev | data | next]
```

具体实现👇：

```javascript
class DoublyNode extends Node {
  constructor(element, next, prev) {
    super(element, next)
    this.prev = prev
  }
}

// 双向链表
class DoubleLinkedList {
  constructor(equalsFn = defaultEquals) {
    super(equalsFn)
    this.tail = undefined // 指向尾部元素
  }

  // 在任意位置插入新元素
  insert(element, index) {
    if (index >= 0 && index <= this.count) {
      const node = new DoublyNode(element)
      let current = this.head
      if (index === 0) {
        // 头部
        if (this.head === undefined) {
          this.head = node
          this.tail = node
        } else {
          node.next = this.head
          current.prev = node
          this.head = node
        }
      } else if (index === count) {
        // 尾部
        current = this.tail
        current.next = node
        node.prev = current
        this.tail = node
      } else {
        // 中间
        const previous = this.getElementAt(index - 1) // 当前 index 前面的元素
        current = previous.next // 当前 index 位置处的元素
        node.next = current
        previous.next = node
        current.prev = node
        node.prev = previous
      }
      this.count++
      return true
    }
    return false
  }

  // 从任意位置移出元素
  removeAt(index) {
    if (index >= 0 && index <= this.count) {
      let current = this.head
      if (index === 0) {
        // 头部
        this.head = current.next // head 指向后一个元素
        if (this.count === 1) {
          // 只有一个元素
          this.tail = undefined
        } else {
          this.head.prev = undefined
        }
      } else if (index === this.count - 1) {
        // 尾部
        current = this.tail
        this.tail = current.prev // tail 指向前一个元素
        this.tail.next = undefined // 取消前一个元素的 next 指向
      } else {
        // 中间
        current = this.getElementAt(index)
        const previous = current.prev
        previous.next = current.next // 前一个元素的 next 指向后一个元素
        current.next.prev = previous // 后一个元素的 prev 指向前一个元素
      }
      this.count--
      return current.element
    }
    return undefined
  }
}
```

#### 4.3、循环链表

循环链表是一种特殊的链表结构，其中链表的最后一个节点的指针指向链表的第一个节点，从而形成一个环状结构

这种结构允许从链表中的任何节点开始遍历，且可以在链表中循环往复地进行操作

**循环链表的类型**

循环链表可以分为以下两种主要类型：

1. **单向循环链表（Singly Circular Linked List）**：
   - 每个节点只有一个指针，指向下一个节点
   - 最后一个节点的指针指向第一个节点，形成一个环
2. **双向循环链表（Doubly Circular Linked List）**：
   - 每个节点有两个指针，一个指向下一个节点，一个指向前一个节点
   - 最后一个节点的后继指针指向第一个节点，第一个节点的前驱指针指向最后一个节点，形成一个双向环

单向循环链表的实现👇：

```javascript
class CircularLinkedList extends LinkedList {
  constructor(equalsFn = defaultEquals) {
    super(equalsFn)
  }

  // 指定位置插入一个元素
  insert(element, index) {
    if (index >= 0 && index <= this.count) {
      const node = new Node(element)
      let current = this.head
      if (index === 0) {
        if (this.head === null) {
          this.head = node
          node.next = this.head
        } else {
          node.next = current
          current = this.getElementAt(this.size())
          this.head = node
          current.next = this.head
        }
      } else {
        const previous = this.getElementAt(index - 1)
        node.next = previous.next
        previous.next = node
      }
      this.count++
      return true
    }
    return false
  }

  // 指定位置删除一个元素
  removeAt(index) {
    if (index >= 0 && index <= this.count) {
      let current = this.head
      if (index === 0) {
        if (this.size() === 1) {
          this.head = null
        } else {
          const removed = this.head
          current = this.getElementAt(this.size())
          this.head = this.head.next
          current.next = this.head
          current = removed
        }
      } else {
        const previous = this.getElementAt(index - 1)
        current = previous.next
        previous.next = current.next
      }
      this.count--
      return current.element
    }
    return undefined
  }
}
```

### 五、哈希表

**哈希表**（**Hash Table**）是一种数据结构，通过将键（**Key**）映射到值（**Value**），能够实现快速的数据查找、插入和删除；哈希表使用一种称为**哈希函数**的算法，**将键转换为数组中的索引**，从而在常数时间内（平均情况下）完成这些操作

<!--从哈希表的定义来看，JS 语言本身就有这种数据结构，简单点的就是数组和对象，若是希望键（Key）为其他类型，还有 Set 和 Map 这两种数据类型-->

**哈希表的基本概念：**

1. **哈希函数（Hash Function）**：
   - 将输入的键转换为哈希码（通常是整数），然后使用该哈希码来计算数组的索引
   - 一个好的哈希函数应当尽量避免哈希冲突，使得不同的键尽可能映射到不同的索引
2. **哈希冲突（Hash Collision）**：
   - 当两个不同的键通过哈希函数映射到相同的索引时，称为哈希冲突
   - 常见的解决哈希冲突的方法有链地址法和开放地址法 <!--用到再了解-->



