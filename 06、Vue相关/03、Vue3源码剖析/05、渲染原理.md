## Vue3源码剖析（五）— Vue3渲染原理

### 一、前言

Vue3中运行时的==核心模块有两个==**runtime-dom** 和**runtime-core** 

- **runtime-dom：**==提供**DOM API**==
- **runtime-core：**调用**runtime-dom**提供的**DOM API**==将虚拟DOM变成真实DOM==

接下来实现的就是`runtime-dom` 和`runtime-core`这两个模块

#### 1.1、渲染过程中的几个关键方法

##### 1.1.1、`createApp`

==`createApp` 是一个工厂函数，用于创建一个 **Vue应用程序实例**==

它接受一个根组件作为参数，==返回一个提供应用上下文的**应用实例**对象== 

该对象包含了一些常用的方法和属性，比如 `mount`、`unmount`、`provide`、`inject` 等。通过 `createApp` 方法可以方便地创建一个 Vue 应用程序，并将其挂载到页面上

<!--应用实例挂载的整个组件树共享同一个上下文-->

示例：

```js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

app.mount('#app')
```

> CreateApp 作为 vue 的==启动函数==，返回一个应用实例，每个 Vue 应用程序都首先使用以下函数创建一个新的**应用程序实例**，应用程序实例公开的大多数方法都返回相同的实例，可以链式调用

##### 1.1.2、`h`

==`h` 方法是用于创建**虚拟节点(VNode)**的函数==，它接受三个参数：**标签名**、**属性对象**和**子节点数组**

**VNode**是一个普通对象，它描述了一个 DOM 元素的结构和属性，可以用于构建 Vue 组件的模板

使用 `h` 方法可以方便地创建虚拟节点，并在应用程序中动态生成组件

示例：

```js
import { createApp, h } from 'vue'
import App from './App.vue'

const app = createApp({
  render() {
    return h('div', {
      class: 'container'
    }, [
      h('h1', {}, 'Hello Vue 3.0'),
      h(App)
    ])
  }
})

app.mount('#app')
```

##### 1.1.3、Custom Renderer API  — `createRenderer` 

==`createRenderer` 是用于创建自定义渲染器的函数==

Vue3通过向外暴露出`runtime-dom` 模块的`createRenderer`方法，==支持用户自定义渲染器==，去适配不同的平台，例如 Canvas 或 WebGPU

> ==渲染器的作用是把虚拟DOM渲染为特定平台上的真实元素==
>
> 在浏览器中，渲染器会把虚拟DOM渲染成真实DOM元素
>
> ==`createRenderer`方法是整个Vue渲染原理的核心方法==，DOM 的初始化挂载、`diff`更新、卸载都在`createRenderer`中实现

`createRenderer`语法如下👇

```js
import { createRenderer } from 'vue'
const { render, createApp } = createRenderer({
  patchProp,
  ...nodeOps
})
```

**==入参：==**

`createRenderer` 函数的接受一个`rendererOptions`对象作为参数，在`rendererOptions`中可以定义很多==操作真实DOM的方法==用于==构建整个渲染器==

通过自定义`rendererOptions`可以生成适配不同平台的渲染器

> 在 [runtime-dom/src/nodeOps.ts](https://github.com/vuejs/vue-next/blob/master/packages/runtime-dom/src/nodeOps.ts) 中有官方的实现可以作为参考
>
> Vue3中内置了浏览器平台的`rendererOptions`作为默认值

`rendererOptions`中的内容： <!--Vue3中内置的rendererOptions是浏览器平台的操作真实DOM的方法，这些方法在runtime-dom这个包中-->

- `patchProp (el, key, prevValue, nextValue)`：**==操作DOM元素属性的API==**

  -  在组件==属性被修改时调用==，针对不同属性，对 `el` 进行不同的操作

- `nodeOps`：==**操作DOM元素的API**==

  - `createElement(tag)` ：创建元素

  - `createText(text)`：创建文本

  - `setElementText(node, text)`：设置文本

  - `insert(el, parent)`：将元素插入父节点的元素，`el` 要插入的元素对象，`parent` 父元素对象

    <!--...还有很多，待补充-->

**==返回值：==**

`createRenderer`的返回值是个对象，对象中有两个方法`render`和`createApp`

- `render(VNode, el)`  <!--这个方法很重要‼️-->

  ==用来将`VNode`转化成真实`DOM`并挂载到指定节点上，`VNode`的`diff`更新，以及`VNode`的卸载==

  - `VNode`：虚拟**DOM**节点
  - `el`：容器，是个真实**DOM**节点

- `createApp` 

  - 是用来创建整个应用的工具，运行它会返回==一个提供应用上下文的应用实例==，应用实例挂载的整个组件树共享同一个上下文；
  - 可以在 `createApp` 之后链式调用其它方法，这些方法可以在 [应用 API](https://vue3js.cn/docs/zh/api/application-api.html) 中找到

使用示例如下👇

```js
const {createRenderer,h} = Vue
const renderer = createRenderer({
    createElement(element){
        return document.createElement(element);
    },
    setElementText(el,text){
        el.innerHTML = text
    },
    insert(el,container){
        container.appendChild(el)
    }
});
renderer.render(h('h1','hello world'),document.getElementById('app')) 
```

#### 1.2、Vue3中的diff算法

**Vue3**的**diff**算法与**Vue2**的**diff**算法相比，有以下一些重要的改进：

1. ==**静态标记：**== **Vue3** 中引入了==静态标记==，可==以将不会发生变化的节点标记为静态节点，从而在 diff 算法中跳过这些节点的比较。==这样可以大幅减少 diff 的时间复杂度，提高渲染性能。
2. **PatchFlag：**Vue 3 中的虚拟节点引入了 PatchFlag 标记，可以用于标记节点的类型、属性、子节点等信息。在 diff 算法中，可以根据 PatchFlag 快速比较节点的差异，从而避免不必要的比较。
3. **动态节点的缓存：**Vue 3 中通过缓存动态节点的方式，可以避免在每次渲染时都重新创建节点。在 diff 算法中，可以直接复用之前的节点，从而减少了节点的创建和销毁。

总之，Vue 3 的 diff 算法在性能和可维护性方面都有了很大的提升，使得 Vue 3 在处理大型应用和高性能场景时更加优秀

### 二、`runtime-dom` 

创建`runtime-dom`包

`runtime-dom` 包是提供运行时处理真实DOM的方法，包括DOM API 、属性、事件处理等

```json
// runtime-dom/package.json
{
    "name": "@vue/runtime-dom",
    "main": "index.js",
    "module": "dist/runtime-dom.esm-bundler.js",
    "unpkg": "dist/runtime-dom.global.js",
    "buildOptions": {
        "name": "VueRuntimeDOM",
        "formats": [
        "esm-bundler",
        "cjs",
        "global"
        ]
    }
}
```

```shell
pnpm install @vue/shared@workspace --filter @vue/runtime-dom
```

#### 2.1、内置的`rendererOptions`

##### 2.1.1、`pachProp`

```typescript
// packages/runtime-dom/src/patchProp.ts

import { patchAttr } from './patch-prop/patchAttr';
import { patchClass } from './patch-prop/patchClass';
import { patchEvent } from './patch-prop/patchEvent';
import { patchStyle } from './patch-prop/patchStyle';

/**
 * 对节点属性的操作
 * 给属性打补丁 {style:{color:'red'}}   {style:{}}
 */
export const patchProp = (el, key, preValue, nextValue) => {
  if (key === 'class') {
    // 类名
    patchClass(el, nextValue);
  } else if (key === 'style') {
    // 行内样式
    patchStyle(el, preValue, nextValue);
  } else if (/on[^a-z]/.test(key)) {
    // 事件 onClick onMousedown
    patchEvent(el, key, nextValue);
  } else {
    // 其他属性
    patchAttr(el, key, nextValue);
  }
};
```

```typescript
//packages/runtime-dom/src/patch-prop/patchClass.ts

/**
 * 操作元素的类名
 */
export function patchClass(el, nextValue) {
  if (nextValue == null) {
    el.removeAttribute('class');
  } else {
    el.className = nextValue;
  }
}
```

```typescript
//packages/runtime-dom/src/patch-prop/patchStyle.ts

/**
 * 操作元素的行内样式
 */
export function patchStyle(el, preValue, nextValue) {
  const style = el.style;
  for (let key in nextValue) {
    style[key] = nextValue[key];
  }
  if (preValue) {
    for (let key in preValue) {
      if (nextValue[key] == null) {
        // 老的有 新的没有 需要删除老的
        style[key] = null;
      }
    }
  }
}

```

```typescript
//packages/runtime-dom/src/patch-prop/patchEvent.ts

/**
 * 创建一个包装事件回调的函数
 * 这么做是为了提升性能
 * 只需要修改value的引用就可以调用不同的逻辑
 * 避免了绑定事件时新建函数的开销
 */
function createInvoker(initialValue) {
  const invoker = e => {
    invoker.value(e);
  };

  // 后续只需要修改value的引用就可以 达到调用不同的逻辑
  invoker.value = initialValue;
  return invoker;
}

/**
 * 操作元素的事件
 */
export function patchEvent(el, eventName, nextValue) {
  // 给元素el添加_vei属性用于存储事件
  const invokers = el._vei || (el._vei = {});
  const exitingInvoker = invokers[eventName];

  if (exitingInvoker && nextValue) {
    // 存在缓存的情况，直接进行换绑
    exitingInvoker.value = nextValue;
  } else {
    // 不存在缓存的情况 需要添加事件，事件名一般是这种形式的 onClick onMousedown
    const eName = eventName.slice(2).toLowerCase();
    if (nextValue) {
      // el._vei = {onClick: invoker}
      const invoker = createInvoker(nextValue);
      // 缓存invoker
      invokers[eventName] = invoker;
      el.addEventListener(eName, invoker);
    } else if (exitingInvoker) {
      // 没有新的值，但是之前绑定过 需要删除之前的
      el.removeEventListener(eName, exitingInvoker);
      // 清除缓存invoker
      invokers[eventName] = null;
    }
  }
}

```

```typescript
//packages/runtime-dom/src/patch-prop/patchAttr.ts

/**
 * 操作元素的其他属性
 */
export function patchAttr(el,key,nextValue){
    if(nextValue == null){
        el.removeAttribute(key);
    }else{
        el.setAttribute(key,nextValue)
    }
}
```

##### 2.1.2、`nodeOps`

```typescript
// packages/runtime-dom/src/nodeOps.ts

/**
 * 对节点的操作
 * 创建元素节点 创建文本节点  节点的增删查， 获取父子关系
 */
export const nodeOps = {
  createElement(tagName) {
    return document.createElement(tagName);
  },
  createTextNode(text) {
    return document.createTextNode(text);
  },
  insert(element, container, anchor = null) {
    container.insertBefore(element, anchor); // ==appendChild
  },
  remove(child) {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  querySelector(selectors) {
    return document.querySelector(selectors);
  },
  parentNode(child) {
    // 父节点
    return child.parentNode;
  },
  nextSibling(child) {
    // 获取兄弟元素
    return child.nextSibling;
  },
  setText(element, text) {
    // 给文本节点设置内容
    element.nodeValue = text;
  },
  setElementText(element, text) {
    // 给元素节点设置内容 innerHTML
    element.textContent = text;
  }
};
```

 `runtime-dom/src/nodeOps` 这里**==存放常见DOM操作API==**

不同运行时提供的具体实现不一样，最终将操作方法传递到`runtime-core`中，所以==`runtime-core`不需要关心平台相关代码==

#### 2.3、`runtime-core`

创建`runtime-core`包

`runtime-core` ==不关心运行平台==

```json
// runtime-core/package.json

{
  "name": "@vue/runtime-core",
  "module": "dist/runtime-core.esm-bundler.js",
  "types": "dist/runtime-core.d.ts",
  "files": [
    "index.js",
    "dist"
  ],
  "buildOptions": {
    "name": "VueRuntimeCore",
    "formats": [
      "esm-bundler",
      "cjs"
    ]
}
```

`runtime-core`中需要依赖 `@vue/shared` 及 `@vue/reactivity`

```shell
pnpm install @vue/shared@workspace @vue/reactivity@workspace --filter @vue/runtime-core
```

##### 2.3.1、`createVNode`实现

```typescript
// packages/runtime-core/src/createVNode.ts
/**
 * vue3中的形状标识
 * 通过组合可以描述虚拟节点的类型
 */
export const enum ShapeFlags {
  ELEMENT = 1, // 1
  FUNCTIONAL_COMPONENT = 1 << 1, // 2
  STATEFUL_COMPONENT = 1 << 2, // 4
  TEXT_CHILDREN = 1 << 3, // 8
  ARRAY_CHILDREN = 1 << 4, // 16
  SLOTS_CHILDREN = 1 << 5, // 32
  TELEPORT = 1 << 6, // 64
  SUSPENSE = 1 << 7, // 128
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,
  COMPONENT_KEPT_ALIVE = 1 << 9,
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT |
    ShapeFlags.FUNCTIONAL_COMPONENT
}
```

```typescript
// packages/runtime-core/src/createVNode.ts
import { isArray, isString } from '@vue/shared';

/**
 * 创建VirtualNode
 */
export function createVNode(type, props = null, children = null) {
  // 标记创建的是什么类型的VNode
  let shapeFlag = isString(type) ? ShapeFlags.ELEMENT : 0;

 const vnode = {
  __v_isVNode:true, // vnode标识
  type, // 真实节点的类型
  props,
  children,
  key: props && props.key,
  el: null,
  shapeFlag // 标记自己的类型及children VNode的类型
};

  /**
   * 通过位运算
   * 将当前的VNode 和 children VNode映射起来
   * 通过shapeFlags 就可以知道children VNode的类型了 是数组 还是元素 还是文本
   * 利用的是位运算在权限控制中的应用
   */
  if (children) {
    let temp = 0;
    // 子节点的数据格式，暂时只考虑数组和字符串
    if (isArray(children)) {
      temp = ShapeFlags.ARRAY_CHILDREN;
    } else {
      children = String(children);
      temp = ShapeFlags.TEXT_CHILDREN;
    }
    vnode.shapeFlag = vnode.shapeFlag | temp;
  }

  return vnode;
}
```

**虚拟DOM节点上重要的属性**：

- `type`：==真实节点的类型==
- `el`：==真实DOM节点==

`createVNode`的实现中应用到了位运算来==标识`children VNode`的类型==

`VNode`上的`shapeFlag`属性用来存储位运算的结果，==标记自己的类型及children节点的类型==

<!--关于位运算在权限控制中的应用，单独写了篇笔记记录-->

##### 2.3.2、`h`实现

`h`方法是`createVNode`的重载方法，处理不同的入参情况时如何调用`createVNode`

> `createVNode`入参可能的情况
>
> - 元素 内容
> -  元素 属性 内容
> - 元素 属性 多个儿子
> - 元素 儿子 / 元素    (只要不是文本节点，都会把儿子转成数组)
> - 元素 空属性 多个儿子
> - ...

```typescript
// packages/runtime-core/src/h.ts
import { isArray, isObject } from '@vue/shared';
import { isVnode, createVNode } from './createVNode';

/**
 * h方法是createVNode的重载方法
 * 处理不同的入参情况时如何调用createVNode`
 * createVNode入参可能的情况
 * 1) 元素 内容
 * 2) 元素 属性 内容
 * 3) 元素 属性 多个儿子
 * 4) 元素 儿子 / 元素 (只要不是文本节点，都会把儿子转成数组)
 * 5) 元素 空属性 多个儿子
 * 注意子节点是：数组、文本、null
 */
export function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    // 参数为两个的情况 1） 元素 + 属性 2） 元素 + children
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      // 若propsOrChildren是对象的话 则其可能是属性也有可能是children VNode
      if (isVnode(propsOrChildren)) {
        // children VNode 将其用数组包起来 h(type,元素对象)
        return createVNode(type, null, [propsOrChildren]);
      }
      // 属性 h(type,属性)
      return createVNode(type, propsOrChildren);
    } else {
      // 若propsOrChildren不是对象的话，那其一定是children VNode
      // children VNode是 数组 或者 字符 h(type,[] ) h(type,'文本‘)
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    // 参数大于两个的情况,则一定是 元素 + 属性 + children
    if (l === 3 && isVnode(children)) {
      // 只有三个参数 h(type,属性，children) 将children用数组包起来
      children = [children];
    } else if (l > 3) {
      // 大于三个参数 h(type,属性，children1，children2，...) 将children处理成数组
      children = Array.from(arguments).slice(2);
    }
    return createVNode(type, propsOrChildren, children);
  }
}
```

```typescript
// packages/runtime-core/src/createVNode.ts

/**
 * 判断是否是VNode
 */
export function isVnode(val) {
  return !!val.__v_isVNode;
}
```

##### 2.3.3、`createRenderer` 实现 ‼️

==在`createRenderer` 中需要实现`VNode`的初始化挂载、`diff`更新、卸载==

 <!--核心方法，很重要-->

###### 2.3.3.1、`createRenderer`整体结构

```typescript
// packages/runtime-core/src/renderer.ts

export function createRenderer(options){
  // 传入进来的renderOptions
  let {
    patchProp: hostPatchProp, // 对节点属性的操作
    createElement: hostCreateElement, // 创建元素
    createTextNode: hostCreateTextNode, // 创建文本
    createText: hostCreateText,
    querySelector: hostQuerySelector,
    insert: hostInsert,
    remove: hostRemove,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling
  } = options;
    
  const unmount = (n1) => {
    // 卸载逻辑在这里实现
  }
  
  const patch = (n1,n2,container) => {
    // 初始化和diff算法都在这里实现
  }
    
/**
   * DOM的渲染方法
   * 负责DOM的初始化挂载、更新、卸载
   * @param vnode 虚拟节点
   * @param container 容器，真实的DOM节点
   */
  function render(vnode, container) {
    // 我们需要将vnode渲染到container中，并且调用options中的api
    if (vnode == null) {
      // 卸载
      if (container._vnode) {
        unmount(container._vnode);
      }
    } else {
      // 初始化挂载和更新
      patch(container._vnode || null, vnode, container);
    }
    // 第一次渲染的时候就将vnode保留到了容器上，用于后续区分是初始化挂载还是更新
    container._vnode = vnode; 
  }
  
  return {
    render
  };
}
```

可以先看下`createRenderer`整体结构，后面会在`createRenderer`中实现==**挂载**==、==**卸载**==、==**更新**==的逻辑

------

`createRenderer`方法需要通过`runtime-dom`模块暴露出去，另外还要暴露出使用内置`rendererOptions`生成的`render`

```typescript
// packages/runtime-dom/src/index.ts

import { createRenderer } from '@vue/runtime-core';
import { nodeOps } from './nodeOps';
import { patchProp } from './patchProp';

export * from '@vue/runtime-core';

const renderOptions = { patchProp, ...nodeOps };
/**
 * vue内置的渲染器
 * 使用createRenderer搭配内置的renderOptions（浏览器平台的渲染配置项）
 * 创建的渲染器
 */
export function render(vnode, container) {
  let { render } = createRenderer(renderOptions);
  return render(vnode, container);
}

```

###### 2.3.3.2、初始化挂载

```typescript
// packages/runtime-core/src/renderer.ts

import { isNumber, isString } from '@vue/shared';
import {
  ShapeFlags,
  Text,
  createVNode,
  isSameVNode,
  Fragment
} from './createVNode';

export function createRenderer(options) {
  // 传入进来的renderOptions，，内部属性都是DOM Api
  let {
    patchProp: hostPatchProp, // 对节点属性的操作
    createElement: hostCreateElement, // 创建元素
    createTextNode: hostCreateTextNode, // 创建文本
    createText: hostCreateText,
    querySelector: hostQuerySelector,
    insert: hostInsert,
    remove: hostRemove,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling
  } = options;

  /**
   * 格式化children
   * children有可能是字符串或数字，需要将其处理成VNode
   */
  function normalize(children, i) {
    if (isString(children[i]) || isNumber(children[i])) {
      children[i] = createVNode(Text, null, children[i]);
    }
    return children[i];
  }

  /**
   * 挂载children的方法
   */
  function mountChildren(children, container) {
    for (let i = 0; i < children.length; i++) {
      // 格式化children child 可能是文本 需要把文本也变成虚拟节点
      let child = normalize(children, i);
      // 递归渲染子节点
      patch(null, child, container);
    }
  }

  /**
   * 元素类型的VNode的挂载
   * @param vnode 虚拟节点
   * @param container 父容器
   * @param anchor 锚点 用于真实节点的insert操作
   * mountElement被递归调用，不断的将根据VNode生成的真实节点insert到父容器中
   * 最终生成完整的DOM，
   * 最后再将DOM insert到根节点（用户指定的真实节点）上
   * 便完成挂载
   */
  function mountElement(vnode, container, anchor) {
    let { type, children, shapeFlag } = vnode;

    /**
     * 创建真实节点
     * 并保存在VNode的el属性上保存下来
     * 后续需要比对虚拟节点的差异，更新页面
     * 所以需要保留对应的真实节点
     */
    let el = (vnode.el = hostCreateElement(type));

    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      // children是文本，直接设置真实节点的文本内容即可
      hostSetElementText(el, children);
    }
    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // children是数组，则需要进一步处理
      mountChildren(children, el);
    }

    /**
     * 挂载操作
     * 将根据VNode生成的真实节点el挂载到父容器中
     */
    hostInsert(el, container, anchor);
  }

  /**
   * 文本类型的VNode的挂载和更新处理
   */
  function processText(n1, n2, container) {
    if (n1 == null) {
      hostInsert(
        (n2.el = hostCreateTextNode(n2.children)),
        container
      );
    } else {
     // 后续更新处理逻辑
    }
  }

  /**
   * 元素类型的VNode的挂载和更新处理
   */
  function processElement(n1, n2, container, anchor) {
    if (n1 == null) {
      mountElement(n2, container, anchor);
    } else {
      // 后续更新处理逻辑
    }
  }

  /**
   * VNode的初始化挂载和diff更新
   * @param n1 容器上保存的上一次的VNode
   * @param n2 新的VNode
   * @param container 容器 真实的DOM节点
   */
  const patch = (n1, n2, container, anchor = null) => {
    /**
     * n1 如果是null 说明是初始化挂载
     * n1 如果有值 说明是更新 要走diff算法
     */
    const { type, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container);
        break;
      default:
        if (shapeFlag & ShapeFlags.ELEMENT) {
          // 通过位运算判断当前VNode是元素类型
          processElement(n1, n2, container, anchor);
        }
    }
  };

  /**
   * DOM的渲染方法
   * 负责DOM的初始化挂载、更新、卸载
   * @param vnode 虚拟节点
   * @param container 容器，真实的DOM节点
   */
  function render(vnode, container) {
    if (vnode == null) {
      // 卸载逻辑
    } else {
      // 初始化挂载和更新
      patch(container._vnode || null, vnode, container);
    }
    // 第一次渲染的时候就将vnode保留到了容器上，用于后续区分是初始化挂载还是更新
    container._vnode = vnode;
  }

  return {
    render
  };
}
```

先看使用效果👇

```html
<!-- packages/runtime-dom/dist/index.html -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- <script src="../../../node_modules/@vue/runtime-dom/dist/runtime-dom.global.js"></script> -->
  <script src="./runtime-dom.global.js"></script>
  <div id="app"></div>

  <script>
    const { h, createVNode, render } = VueRuntimeDOM

    const vnode1 = createVNode('p', {}, 'hello world')
    const vnode2 = h('h1', [vnode1, 'Vue3.0'])

    // 渲染器就是为了用户方便扩展，vue中内置了 节点操作可以直接使用
    render(vnode2,app)
  </script>
</body>

</html>
```

![image-20220614085300891](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220614085300891.png)

上面👆初始化挂载的实现中，==核心在于挂载`children`中的**递归调用`patch`**==

```typescript
  function mountChildren(children, container) {
    for (let i = 0; i < children.length; i++) {
      // 格式化children child 可能是文本 需要把文本也变成虚拟节点
      let child = normalize(children, i);
      // 递归渲染子节点
      patch(null, child, container);
    }
  }
```

整个初始化挂载的流程如下👇

1. 根据根`VNode`的`type`属性，生成根`VNode`对应的==真实DOM节点==(`n0`)  ⬇️
2. 遍历`VNode`的`children`==**递归调用**`patch`==并生成对应的==子节点的真实DOM节点==(`nx`) ⬇️
3. 每生成一个`nx`，==就将其`insert`到父节点的真实DOM节点上==，最终生成一个完整的DOM ⬇️
4. 最后再将根`VNode`的真实DOM节点 <!--一棵完整的DOM树--> `insert`到指定好的根节点（`#app`）上便完成了==初始化挂载==

==整个初始化挂载的流程并不复杂，就是根据`VNode`创建真实DOM节点，最终得到一棵完整的DOM树挂载到容器上==

###### 2.3.3.3、卸载

卸载逻辑比较简单，直接`remove`掉就可以了，直接将真实DOM节点移除

<!--VNode上的el属性存放的是当前虚拟DOM节点对应的真实DOM节点-->

```typescript
// packages/runtime-core/src/renderer.ts

export function createRenderer(options) {
  // ...

  /**
   * VNode的卸载
   */
  const unmount = n1 => {
    hostRemove(n1.el);
  };

  function render(vnode, container) {
    if (vnode == null) {
      // 卸载逻辑
      unmount(container._vnode);
    } else {
      // 初始化挂载和更新
      patch(container._vnode || null, vnode, container);
    }
    // 第一次渲染的时候就将vnode保留到了容器上，用于后续区分是初始化挂载还是更新
    container._vnode = vnode;
  }

  return {
    render
  };
}
```

###### 2.3.3.4、diff更新

==Vue的`diff`采用的是同级节点比对，父节点比对完成之后会递归比对子节点==

同一节点有两种变化情况：

- **前后元素不一致**
- **前后元素一致**

下面👇将这两种情况进行实现

------

==**前后元素不一致**==

==两个不同虚拟节点不需要进行比较，直接移除老节点，将新的虚拟节点渲染成真实DOM进行挂载即可==

实现如下👇

```typescript
// packages/runtime-core/src/renderer.ts
  const patch = (n1, n2, container, anchor = null) => {
    // 若n1有值且n2、n1不相等，则说明是要将n1替换成n2
    if (n1 && !isSameVNode(n1, n2)) {
      // 卸载n1并重制为null，后续走n2的初始化
      unmount(n1);
      n1 = null;
    }

  /**
   * 此时n1被置为null，接下来走挂载逻辑
   * 同初始化挂载一致
   */
    const { type, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container);
        break;
      case Fragment:
        processFragment(n1, n2, container);
        break;
      default:
        if (shapeFlag & ShapeFlags.ELEMENT) {
          // 通过位运算判断当前VNode是元素类型
          processElement(n1, n2, container, anchor);
        }
    }
  };

```

```typescript
// packages/runtime-core/src/createVNode.ts
/**
 * 判断是否是相同VNode
 */
export function isSameVNode(v1, v2) {
  return v1.type === v2.type && v1.key == v2.key;
}
```

==前后元素不一致的情况，就直接使用新元素替换老元素，相当于直接卸载老元素，不用考虑子节点有没有复用==

------

==**前后元素一致**==

==前后元素一致则比较两个元素的属性和子节点==

实现如下👇

```typescript
const patch = (n1, n2, container, anchor = null) => {
    // ... 

    /**
     * 由于isSameVNode(n1, n2）为true，n1没有被置为null
     * n1有值 说明是更新 要走diff算法
     */
    const { type, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container);
        break;
      case Fragment:
        processFragment(n1, n2, container);
        break;
      default:
        if (shapeFlag & ShapeFlags.ELEMENT) {
          // 通过位运算判断当前VNode是元素类型
          processElement(n1, n2, container, anchor);
        }
    }
  };
```

```typescript
function processElement(n1, n2, container, anchor) {
    if (n1 == null) {
      // ...
    } else {
      patchElement(n1, n2);
    }
}
```

```typescript

/**
 * VNode的diff更新处理
 */
function patchElement(n1, n2) {
  // n1 和 n2 能复用说明dom节点就不用删除了

  // 复用真实DOM节点,不用删除
  let el = (n2.el = n1.el);

  let oldProps = n1.props;
  let newProps = n2.props;
  // 比较属性
  patchProps(oldProps, newProps, el);

  // 比较children
  patchChildren(n1, n2, el);
}
```

比较属性并更新`patchProps(oldProps, newProps, el)`实现如下👇

```typescript
/**
 * 更新属性的方法
 */
function patchProps(oldProps, newProps, el) {
  if (oldProps == null) oldProps = {};
  if (newProps == null) newProps = {};

  // 循环newProps覆盖oldProps
  for (let key in newProps) {
    hostPatchProp(el, key, oldProps[key], newProps[key]);
  }
  // oldProps中有的，但newProps没有的，要删除
  for (let key in oldProps) {
    if (newProps[key] == null) {
      hostPatchProp(el, key, oldProps[key], null);
    }
  }
}
```

==子节点的比对 `patchChildren(n1, n2, el)` 比较复杂，分为以下的情况==‼️ 

<!--这里也是diff大量计算的地方-->

| 新子节点 | 旧子节点 | 操作方式                   |
| :------- | :------- | :------------------------- |
| 文本     | 数组     | 删除旧子节点，设置文本内容 |
| 文本     | 文本     | 更新文本即可               |
| 文本     | 空       | 更新文本即可 与上面的类似  |
| 数组     | 数组     | diff算法                   |
| 数组     | 文本     | 清空文本，进行挂载         |
| 数组     | 空       | 进行挂载 与上面的类似      |
| 空       | 数组     | 删除所有旧子节点           |
| 空       | 文本     | 清空文本                   |
| 空       | 空       | 无需处理                   |

比较子节点并更新 `patchChildren(n1, n2, el)`实现如下👇

```typescript
/**
   * 更新子节点的方法
   * @param n1 旧节点
   * @param n2 新节点
   * @param el 真实的DOM节点
   */
  function patchChildren(n1, n2, el) {
    let c1 = n1.children;
    let c2 = n2.children;

    const prevShapeFlag = n1.shapeFlag;
    const shapeFlag = n2.shapeFlag;

    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      /**
       * 新子节点是文本
       * 数组 ——> 文本
       * 文本 ——> 文本
       * 空 ——> 文本
       * 若旧子节点是数组，则需先删除旧子节点，再设置文本内容
       * 不是的话，直接设置文本内容
       */
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        unmountChildren(c1);
      }
      if (c1 !== c2) {
        hostSetElementText(el, c2);
      }
    } else {
      // 新子节点是数组和空的情况
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // 旧子节点是数组
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          /**
           * 新子节点也是数组
           * 数组 ——> 数组
           * diff算法
           */
          patchKeyedChildren(c1, c2, el);
        } else {
          /**
           * 新子节点是空
           * 数组 ——> 空
           * 删除所有旧子节点
           */
          unmountChildren(c1);
        }
      } else {
        /**
         * 旧子节点是文本或空
         * 文本 ——> 数组
         * 文本 ——> 空
         * 空 ——> 数组
         * 空 ——> 空
         * 旧子节点若是文本，则清空再挂载新子节点
         * 不是则直接挂载新子节点
         */
        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
          hostSetElementText(el, '');
        }
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          mountChildren(c2, el);
        }
      }
    }
  }
```

其中==只有当新旧子节点都是数组的情况复杂些==，要使用`diff`，这个下面单独拎出来实现；

`unmountChildren`的实现

```typescript
  /**
   * 卸载子节点的方法
   */
  function unmountChildren(children) {
    children.forEach(child => {
      unmount(child);
    });
  }
```

###### 2.3.3.5、核心diff算法

Vue `diff`的**原则**是==尽可能**复用**节点==，而且找到变化的位置；

Vue的`diff`可以分为两种

- `patchKeyedChildren`：对有`key`值的`children` 进行`diff`
- `patchUnkeyedChildren`：对无`key`值的`children`进行 `diff` 

<!--下面实现的是`patchKeyedChildren`，`patchUnkeyedChildren`后续再补充-->

`patchKeyedChildren`主要==就是将新旧两个`children`数组的每一项进行比对==

- 首先是对于那些有规律的（`common sequence`）部分先找到`key`和`type`相同的两项进行复用
- 然后是`mount`新增的和`unmount`删除的
- 最后是对于那些乱序的（`unknown sequence`）部分进行比对找到可以复用的

------

`common sequence`的处理：

**sync from start：**==从头部开始进行对比，**遇到不同的就结束**==

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/diff-1.633a1a31.png)

两种情况：

1. 旧的比较多

   新的子节点：(a b) c

   旧的子节点：(a b)

   当 i > e2 说明新的比对完成了，但是旧的还有剩余，也就是说i 到 e1之间的内容就是要删除的

2. 新的比较多

   新的子节点：(a b)

   旧的子节点：(a b) c

   当i > e1 说明旧的全部比对完成，但是新的还有剩余，也就是说i 到 e2之间的内容就是要新增的

```js
 h('div',[
     h('li', { key: 'a' }, 'a'),
     h('li', { key: 'b' }, 'b'),
     h('li', { key: 'c' }, 'c')
 ]) : 
 h('div',[
     h('li', { key: 'a' }, 'a'),
     h('li', { key: 'b' }, 'b'),
     h('li', { key: 'd' }, 'd'),
     h('li', { key: 'e' }, 'e')
 ])
```

```typescript
  /**
   * children diff 方法
   * @param {Array} c1 旧的children
   * @param {Array} c2 新的的children
   * @param el 真实的DOM节点（对于c1、c2来说是父节点）
   * diff c1 和 c2 两个数组之间的差异并进行更新
   * 原则：尽可能复用节点，而且找到变化的位置
   */
  function patchKeyedChildren(c1, c2, el, parentComponent) {
    /**
     * i、e1、e2可以理解为指针，指针指向的是children中某一个child
     * i指向的是sync from start方向的指针
     * e1、e2指向的是sync from end方向的指针
     */
    let i = 0;
    let e1 = c1.length - 1;
    let e2 = c2.length - 1;

    /**
     * 1. sync from start 从头开始比对
     * 遇到不同的就结束
     * (a b) c
     * (a b)
     * 当 i > e2 说明新的比对完成了，但是旧的还有剩余
     * 也就是说i 到 e1之间的内容就是要删除的
     * (a b)
     * (a b) c
     * 当i > e1 说明旧的全部比对完成，但是新的还有剩余
     * 也就是说i 到 e2之间的内容就是要新增的
     */
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = normalizeVNode(c2, i);
      if (isSameVNode(n1, n2)) {
        patch(n1, n2, el);
      } else {
        break;
      }
      i++;
    }
    
    // ...
  }
```

------

**sync from end：**==从尾部开始进行对比，**遇到不同的就结束**==

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/diff-2.d3e4a7df.png)

两种情况：

1. 旧的比较多

   旧的子节点：d e (a b c)

   新的子节点：       (a b c)

   当i > e2 说明新的全部比对完成，但是旧的还有剩余

   也就是说i 到 e1之间的内容就是要删除的

2. 新的比较多

   旧的子节点：   (a b)

   新的子节点：c (a b)

   当 i > e1，说明旧的全部比对完成，但是新的还有剩余

   也就是说i 到 e2之间的内容是要新增的

```js
 h('div',[
     h('li', { key: 'a' }, 'a'),
     h('li', { key: 'b' }, 'b'),
     h('li', { key: 'c' }, 'c')
 ]) : 
 h('div',[
     h('li', { key: 'd' }, 'd'),
     h('li', { key: 'e' }, 'e')
     h('li', { key: 'b' }, 'b'),
     h('li', { key: 'c' }, 'c'),

 ])
```

```typescript
  function patchKeyedChildren(c1, c2, el, parentComponent) {
    let i = 0;
    let e1 = c1.length - 1;
    let e2 = c2.length - 1;
    
    // ...

    /**
     * 2. sync from end 从尾部开始比对
     * 遇到不同的就结束
     * d e (a b c)
     *     (a b c)
     * 当i > e2 说明新的全部比对完成，但是旧的还有剩余
     * 也就是说i 到 e1之间的内容就是要删除的
     *   (a b)
     * c (a b)
     * 当 i > e1，说明旧的全部比对完成，但是新的还有剩余
     * 也就是说i 到 e2之间的内容是要新增的
     */
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2];
      if (isSameVNode(n1, n2)) {
        patch(n1, n2, el);
      } else {
        break;
      }
      e1--;
      e2--;
    }

    
    // ...
  }
```

**common sequence + mount**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/diff-3.747209db.png)

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/diff-4.07076735.png)

```typescript
  function patchKeyedChildren(c1, c2, el, parentComponent) {
    let i = 0;
    let e1 = c1.length - 1;
    let e2 = c2.length - 1;
    
    // ...

     if (i > e1) {
      /**
       * 3. common sequence + mount
       * (a b)
       * (a b) c
       * i = 2, e1 = 1, e2 = 2
       *   (a b)
       * c (a b)
       * i = 0, e1 = -1, e2 = 0
       */
      if (i <= e2) {
        /**
         * 确定锚点anchor，e2若是c2的最后一项，则锚点为null
         * 将新子节点c2[i]直接appendChild到父节点上
         * 否则将新子节点c2[i] insertBefore 到锚点前
         */
        const nextPos = e2 + 1;
        let anchor = c2.length <= nextPos ? null : c2[nextPos].el;

        while (i <= e2) {
          patch(null, c2[i], el, anchor);
          i++;
        }
      }
    }

    // ...
  }
```

**common sequence + unmount**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/diff-5.92c37bd1.png)

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/diff-6.58f193d3.png)

```typescript
  function patchKeyedChildren(c1, c2, el, parentComponent) {
    let i = 0;
    let e1 = c1.length - 1;
    let e2 = c2.length - 1;
    
    // ...

      else if (i > e2) {
      /**
       * 4. common sequence + unmount
       * (a b) c
       * (a b)
       * i = 2, e1 = 2, e2 = 1
       * a (b c)
       *   (b c)
       * i = 0, e1 = 0, e2 = -1
       */
      while (i <= e1) {
        unmount(c1[i], parentComponent);
        i++;
      }
    }

    // ...
  }
```

`common sequence`的处理完之后，便可以处理`unknown sequence`的部分

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/diff-7.566dc6f6.png)

```typescript
 else {
      /**
       * 5. unknown sequence
       * [i ... e1]: a b [c d e] f g
       * [i ... e2]: a b [e d c h] f g
       * i = 2
       * e1 = 4, e2 = 5
       * s1 = 2, s2 = 2
       */
      const s1 = i;
      const s2 = i;

      /**
       * 使用Map存储child的索引值，key是子节点的属性key
       */
      const keyToNewIndexMap = new Map();
      for (let i = s2; i <= e2; i++) {
        keyToNewIndexMap.set(c2[i].key, i);
      }
   // loop through old children left to be patched and try to patch
   // ...
   
   // move and mount
   // ...
  }
```

**loop through old children left to be patched and try to patch**

```typescript
/**
 * 循环遍历旧的children剩下的部分进行比对
 * 若遍历到的child在新的children中找不到相同key的child，则直接unmount
 * 若是能找到则进行patch
 * [i ... e1]: a b [c d e] f g
 * [i ... e2]: a b [e d c h] f g
 * 遍历 [c d e]
 * s1 = 2 e1 = 4
 */
const toBePatched = e2 - s2 + 1;// 新的children 剩下乱序部分 的长度
const newIndexToOldMapIndex = new Array(toBePatched).fill(0);
for (let i = s1; i <= e1; i++) {
  const oldVNode = c1[i];
  let newIndex = keyToNewIndexMap.get(oldVNode.key);
  if (newIndex == null) {
    // 新的里面找不到了，说明要移除掉
    unmount(oldVNode, parentComponent);
  } else {
    // 如果能找到，则需要比较两个节点的差异，再去比较它们自己的children
    patch(oldVNode, c2[newIndex], el);
  }
}
```

**move and mount**

![img](http://www.zhufengpeixun.com/jg-vue/assets/img/diff-8.03470ece.png)

```typescript
/**
 * 遍历新的children乱序部分
 * 将能旧的children 能复用的部分 按照新的children位置重新“排列”并插入
 * 并且还需要将新的children中“新增”child添加上
 * 注意：是从尾部开始遍历
 * [i ... e1]: a b [c d e] f g
 * [i ... e2]: a b [e d c h] f g
 * toBePatched = 4
 * currentIndex 一开始指向 h
 * anchor 一开始指向 f
 */
  for (let i = toBePatched - 1; i >= 0; i--) {
    // 当前要操作的child
    const currentIndex = s2 + i;
    const child = c2[currentIndex];
    // 设置锚点
    const anchor =
      currentIndex + 1 < c2.length
        ? c2[currentIndex + 1].el
        : null;
    /**
     * 判断child是要移动还是新增
     */
    if (!child.el) {
      patch(null, child, el, anchor);   // 如果 没有el 说明是新增的
    } else {
      hostInsert(child.el, el, anchor); // 如果有el 说明以前渲染过了，是复用的dom节点
    }
  }
}
```

其实到这里`diff`数组形式的`children`已经完成了，但是上面👆处理`unknown sequence`的部分，其实是有优化的部分；

现在处理旧的`children`的方式是若`child`可以复用则找到锚点进行插入，但是这种操作是一个一个`child`的进行插入的，那这种情况：

- a b [c d e] f g
-  a b [e c d h] f g

`c`和`d`的相对顺序没有改变，其实可以直接将`c`和`d`视为一个整体不用移动的，直接移动`e`就好了，若是分开依次进行插入的话未免有些浪费性能；所以Vue3对于这种情况进行了优化，优化的方法就是**==最长递增子序列==**

==**最长递增子序列**==

> ==Vue3 采用最长递增子序列，求解不需要移动的元素有哪些==

什么是最长递增子序列？就是求一个数组中，最长连续上升的部分，如下图所示：

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69342f4f31434e30315641454563673235776a43736a7351416a5f2121363030303030303030373539312d322d7470732d3930302d3331302e706e67.png)

如果序列本身就是上升的，那就直接返回其本身；如果序列没有任何一段是上升的，则返回任何一个数字都可以。图中可以看到，虽然 `3, 7, 22` 也是上升的，但因为 `22` 之后接不下去了，所以其长度是有 3，与 `3, 7, 8, 9, 11, 12` 比起来，肯定不是最长的，因此找起来并不太容易。

==在具体 DOM diff 场景中，为了保证尽可能移动较少的 DOM，我们需要 **保持最长上升子序** 不动，只移动其他元素==。为什么呢？因为最长上升子序列本身就相对有序，只要其他元素移动完了，答案也就出来了。还是这个例子，假设原本的 DOM 就是这样一个递增顺序（当然应该是 1 2 3 4 连续的下标，不过对算法来说是否连续间隔不影响，只要递增即可）：

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69322f4f31434e303151483546386a323368784356636e5967785f2121363030303030303030373238382d322d7470732d3931302d3134302e706e67.png)

如果保持最长上升子序不变，只需要移动三次即可还原：

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/68747470733a2f2f696d672e616c6963646e2e636f6d2f696d6765787472612f69322f4f31434e30316d39453937763146763169554a325a516d5f2121363030303030303030303534382d322d7470732d3933342d3134362e706e67.png)

其他任何移动方式都不会小于三步，**因为我们已经最大程度保持已经有序的部分不动了**。

获取==**最长递增子序列**==的采用的算法是==**贪心算法**== + ==**二分查找法**==

算法如下👇

```typescript
/**
 * 获取最长递增子序列的方法
 */
function getSequence(arr) { // 最终的结果是索引 
  const len = arr.length;
  const result = [0]; // 结果集 存放的是索引值
  const p = new Array(len).fill(0); // 里面内容无所谓 和原本的数组相同 用来存放索引

  let lastIndex;
  let start;
  let end;
  let middle;

  for (let i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      // 0 在vue3中意味着新增节点，不计入最长递增子序列列表

      // 取到数组中的最后一项的索引值
      lastIndex = result[result.length - 1];

      if (arr[lastIndex] < arrI) {
        // 若是当前项比 结果集result 中最后一项大

        // 让当前的这一项记录其前一项的索引
        p[i] = lastIndex;
        // 直接将索引放入结果集result
        result.push(i);
        continue;
      }

      /**
       * 当前项比 结果集result 中最后一项小进行二分查找
       * 当 start === end
       * 就找到了结果集中最接近与当前项的值
       * 若是当前项小于该值则进行替换
       */
      start = 0;
      end = result.length - 1;
      while (start < end) {
        middle = Math.floor((start + end) / 2);
        if (arr[result[middle]] < arrI) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      if (arrI < arr[result[end]]) {
        p[i] = result[end - 1];
        result[end] = i;
      }
    }
  }
  // 倒叙追溯 先取到结果集中的最后一个
  let i = result.length;
  let last = result[i - 1];

  while (i-- > 0) {
    // 当检索后停止
    result[i] = last; // 最后一项是正确的
    last = p[last]; // 根据最后一项 向前追溯
  }
  return result;
}
```

关于获取==**最长递增子序列**==的算法其实很难以理解，可以看看这篇文章[**精读《DOM diff 最长上升子序列》**](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/192.%E7%B2%BE%E8%AF%BB%E3%80%8ADOM%20diff%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%8B.md)，虽然没有算法的数学推导过程，但也是有助于理解这个算法的

<!--整个算法的数学推导过程，感觉需要一定的算法的基础知识，没有一些前置知识，看起来很费劲，若是有一段循序渐进的推导过程估计会更容易理解-->

所以优化过后处理`unknown sequence`的实现是这样的

```typescript
 else {
   // ...
   
   // loop through old children left to be patched and try to patch
   // ...
   
   
   // move and mount
   
   // 计算出了不用动序列 （索引）
    let increasingNewIndexSequence = getSequence(
      newIndexToOldIndexMap
    );
    let j = increasingNewIndexSequence.length - 1;

    for (let i = toBePatched - 1; i >= 0; i--) {
      // 当前要操作的child
      const currentIndex = s2 + i;
      const child = c2[currentIndex];
      // 设置锚点
      const anchor =
        currentIndex + 1 < c2.length
          ? c2[currentIndex + 1].el
          : null;

      /**
       * 判断child是要移动还是新增
       */
      if (newIndexToOldIndexMap[i] === 0) {
        // newIndexToOldIndexMap[i]为0 说明是新增的
        patch(null, child, el, anchor);
      } else {
        if (i !== increasingNewIndexSequence[j]) {
          // 通过序列来进行比对，找到哪些需要移动
          hostInsert(child.el, el, anchor);
        } else {
          j--; // 不做任何操作
        }
      }
    }
  }
}
```

###### 2.3.3.6、`createRenderer` 完整代码

```typescript
import {
  ShapeFlags,
  Text,
  isSameVNode,
  normalizeVNode,
  Fragment
} from './createVNode';

/**
 * 获取最长递增子序列的方法
 */
function getSequence(arr) {
  // 最终的结果是索引
  const len = arr.length;
  const result = [0]; // 结果集 存放的是索引值
  const p = new Array(len).fill(0); // 里面内容无所谓 和原本的数组相同 用来存放索引

  let lastIndex;
  let start;
  let end;
  let middle;

  for (let i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      // 0 在vue3中意味着新增节点，不计入最长递增子序列列表

      // 取到数组中的最后一项的索引值
      lastIndex = result[result.length - 1];

      if (arr[lastIndex] < arrI) {
        // 若是当前项比 结果集result 中最后一项大

        // 让当前的这一项记录其前一项的索引
        p[i] = lastIndex;
        // 直接将索引放入结果集result
        result.push(i);
        continue;
      }

      /**
       * 当前项比 结果集result 中最后一项小进行二分查找
       * 当 start === end
       * 就找到了结果集中最接近与当前项的值
       * 若是当前项小于该值则进行替换
       */
      start = 0;
      end = result.length - 1;
      while (start < end) {
        middle = Math.floor((start + end) / 2);
        if (arr[result[middle]] < arrI) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      if (arrI < arr[result[end]]) {
        p[i] = result[end - 1];
        result[end] = i;
      }
    }
  }
  // 倒叙追溯 先取到结果集中的最后一个
  let i = result.length;
  let last = result[i - 1];

  while (i-- > 0) {
    // 当检索后停止
    result[i] = last; // 最后一项是正确的
    last = p[last]; // 根据最后一项 向前追溯
  }
  return result;
}

export function createRenderer(options) {
  // 传入进来的renderOptions，内部属性都是DOM Api
  let {
    patchProp: hostPatchProp, // 对节点属性的操作
    createElement: hostCreateElement, // 创建元素
    createTextNode: hostCreateTextNode, // 创建文本
    createText: hostCreateText,
    querySelector: hostQuerySelector,
    insert: hostInsert,
    remove: hostRemove,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling
  } = options;

  /**
   * 挂载children的方法
   */
  function mountChildren(
    children,
    container,
    anchor,
    parentComponent
  ) {
    for (let i = 0; i < children.length; i++) {
      // 格式化children child 可能是文本 需要把文本也变成虚拟节点
      let child = normalizeVNode(children, i);
      // 递归渲染子节点
      patch(null, child, container, anchor, parentComponent);
    }
  }

  /**
   * 元素类型的VNode的挂载
   * @param vnode 虚拟节点
   * @param container 父容器
   * @param anchor 锚点 用于真实节点的insert操作
   * mountElement被递归调用，不断的将根据VNode生成的真实节点insert到父容器中
   * 最终生成完整的DOM，
   * 最后再将DOM insert到根节点（用户指定的真实节点）上
   * 便完成挂载
   */
  function mountElement(vnode, container, anchor, parentComponent) {
    let { type, props, children, shapeFlag } = vnode;

    /**
     * 创建真实节点
     * 并保存在VNode的el属性上保存下来
     * 后续需要比对虚拟节点的差异，更新页面
     * 所以需要保留对应的真实节点
     */
    let el = (vnode.el = hostCreateElement(type));

    if (props) {
      // 更新属性
      patchProps(null, props, el);
    }

    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      // children是文本，直接设置真实节点的文本内容即可
      hostSetElementText(el, children);
    }
    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // children是数组，则需要进一步处理
      mountChildren(children, el, anchor, parentComponent);
    }

    /**
     * 挂载操作
     * 将根据VNode生成的真实节点el挂载到父容器中
     */
    hostInsert(el, container, anchor);
  }

  /**
   * 更新属性的方法
   */
  function patchProps(oldProps, newProps, el) {
    if (oldProps == null) oldProps = {};
    if (newProps == null) newProps = {};

    // 循环newProps覆盖oldProps
    for (let key in newProps) {
      hostPatchProp(el, key, oldProps[key], newProps[key]);
    }
    // oldProps中有的，但newProps没有的，要删除
    for (let key in oldProps) {
      if (newProps[key] == null) {
        hostPatchProp(el, key, oldProps[key], null);
      }
    }
  }

  /**
   * children diff 方法
   * @param {Array} c1 旧的children
   * @param {Array} c2 新的的children
   * @param el 真实的DOM节点（对于c1、c2来说是父节点）
   * diff c1 和 c2 两个数组之间的差异并进行更新
   * 原则：尽可能复用节点，而且找到变化的位置
   */
  function patchKeyedChildren(c1, c2, el, parentComponent) {
    /**
     * i、e1、e2可以理解为指针，指针指向的是children中某一个child
     * i指向的是sync from start方向的指针
     * e1、e2指向的是sync from end方向的指针
     */
    let i = 0;
    let e1 = c1.length - 1;
    let e2 = c2.length - 1;

    /**
     * 1. sync from start 从头开始比对
     * 遇到不同的就结束
     * (a b) c
     * (a b)
     * 当 i > e2 说明新的比对完成了，但是旧的还有剩余
     * 也就是说i 到 e1之间的内容就是要删除的
     * (a b)
     * (a b) c
     * 当i > e1 说明旧的全部比对完成，但是新的还有剩余
     * 也就是说i 到 e2之间的内容就是要新增的
     */
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = normalizeVNode(c2, i);
      if (isSameVNode(n1, n2)) {
        patch(n1, n2, el);
      } else {
        break;
      }
      i++;
    }

    /**
     * 2. sync from end 从尾部开始比对
     * 遇到不同的就结束
     * d e (a b c)
     *     (a b c)
     * 当i > e2 说明新的全部比对完成，但是旧的还有剩余
     * 也就是说i 到 e1之间的内容就是要删除的
     *   (a b)
     * c (a b)
     * 当 i > e1，说明旧的全部比对完成，但是新的还有剩余
     * 也就是说i 到 e2之间的内容是要新增的
     */
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2];
      if (isSameVNode(n1, n2)) {
        patch(n1, n2, el);
      } else {
        break;
      }
      e1--;
      e2--;
    }

    if (i > e1) {
      /**
       * 3. common sequence + mount
       * (a b)
       * (a b) c
       * i = 2, e1 = 1, e2 = 2
       *   (a b)
       * c (a b)
       * i = 0, e1 = -1, e2 = 0
       */
      if (i <= e2) {
        /**
         * 确定锚点anchor，e2若是c2的最后一项，则锚点为null
         * 将新子节点c2[i]直接appendChild到父节点上
         * 否则将新子节点c2[i] insertBefore 到锚点前
         */
        const nextPos = e2 + 1;
        let anchor = c2.length <= nextPos ? null : c2[nextPos].el;

        while (i <= e2) {
          patch(null, c2[i], el, anchor);
          i++;
        }
      }
    } else if (i > e2) {
      /**
       * 4. common sequence + unmount
       * (a b) c
       * (a b)
       * i = 2, e1 = 2, e2 = 1
       * a (b c)
       *   (b c)
       * i = 0, e1 = 0, e2 = -1
       */
      while (i <= e1) {
        unmount(c1[i], parentComponent);
        i++;
      }
    } else {
      /**
       * 5. unknown sequence
       * [i ... e1]: a b [c d e] f g
       * [i ... e2]: a b [e d c h] f g
       * i = 2
       * e1 = 4, e2 = 5
       * s1 = 2, s2 = 2
       */
      const s1 = i;
      const s2 = i;

      /**
       * 使用Map存储child的索引值，key是子节点的属性key
       */
      const keyToNewIndexMap = new Map();
      for (let i = s2; i <= e2; i++) {
        keyToNewIndexMap.set(c2[i].key, i);
      }

      /**
       * 循环遍历旧的children剩下的部分进行比对
       * 若遍历到的child在新的children中找不到相同key的child，则直接unmount
       * 若是能找到则进行patch
       * [i ... e1]: a b [c d e] f g
       * [i ... e2]: a b [e c d h] f g
       * 遍历 [c d e]
       * s1 = 2 e1 = 4
       * s2 = 2 e2 = 5
       * newIndexToOldMapIndex长度为4 [e d c h]的长度
       */

      const toBePatched = e2 - s2 + 1; // 新的children 剩下乱序部分 的长度
      const newIndexToOldIndexMap = new Array(toBePatched).fill(0);
      for (let i = s1; i <= e1; i++) {
        const oldVNode = c1[i];
        let newIndex = keyToNewIndexMap.get(oldVNode.key);
        if (newIndex == null) {
          // 新的里面找不到了，说明要移除掉
          unmount(oldVNode, parentComponent);
        } else {
          /**
           * 记录下来可以旧的children中可以复用的child的索引
           * 新的位置和老的位置做一个关联
           * [c d e]
           * [e c d h]
           * newIndexToOldIndexMap = [4+1, 2+1, 3+1, 0+1] = [5, 3, 4, 1]
           * 为什么要+1
           * 是因为为了将newIndexToOldIndexMap默认属性值0和
           * 旧的children第一项的索引0区分开
           */
          newIndexToOldIndexMap[newIndex - s2] = i + 1;

          // 如果能找到，则需要比较两个节点的差异，再去比较它们自己的children
          patch(oldVNode, c2[newIndex], el);
        }
      }

      /**
       * 遍历新的children乱序部分
       * 将能旧的children 能复用的部分 按照新的children位置重新“排列”并插入
       * 并且还需要将新的children中“新增”child添加上
       * 注意：是从尾部开始遍历
       * [i ... e1]: a b [c d e] f g
       * [i ... e2]: a b [e d c h] f g
       * toBePatched = 4
       * currentIndex 一开始指向 h
       * anchor 一开始指向 f
       */

      // 计算出了不用动序列 （索引）
      let increasingNewIndexSequence = getSequence(
        newIndexToOldIndexMap
      );
      let j = increasingNewIndexSequence.length - 1;

      for (let i = toBePatched - 1; i >= 0; i--) {
        // 当前要操作的child
        const currentIndex = s2 + i;
        const child = c2[currentIndex];
        // 设置锚点
        const anchor =
          currentIndex + 1 < c2.length
            ? c2[currentIndex + 1].el
            : null;

        /**
         * 判断child是要移动还是新增
         */
        if (newIndexToOldIndexMap[i] === 0) {
          // newIndexToOldIndexMap[i]为0 说明是新增的
          patch(null, child, el, anchor);
        } else {
          if (i !== increasingNewIndexSequence[j]) {
            // 通过序列来进行比对，找到哪些需要移动
            hostInsert(child.el, el, anchor);
          } else {
            j--; // 不做任何操作
          }
        }
      }
    }
  }

  /**
   * 卸载子节点的方法
   */
  function unmountChildren(children, parentComponent) {
    children.forEach(child => {
      unmount(child, parentComponent);
    });
  }

  /**
   * 更新子节点的方法
   * @param n1 旧节点
   * @param n2 新节点
   * @param el 真实的DOM节点（n2复用n1的真实DOM节点）
   * @param parentComponent 父组件
   */
  function patchChildren(n1, n2, el, anchor, parentComponent) {
    let c1 = n1.children;
    let c2 = n2.children;

    const prevShapeFlag = n1.shapeFlag;
    const shapeFlag = n2.shapeFlag;

    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      /**
       * 新子节点是文本
       * 数组 ——> 文本
       * 文本 ——> 文本
       * 空 ——> 文本
       * 若旧子节点是数组，则需先删除旧子节点，再设置文本内容
       * 不是的话，直接设置文本内容
       */
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        unmountChildren(c1, parentComponent);
      }
      if (c1 !== c2) {
        hostSetElementText(el, c2);
      }
    } else {
      // 新子节点是数组和空的情况
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // 旧子节点是数组
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          /**
           * 新子节点也是数组
           * 数组 ——> 数组
           * diff算法
           */
          patchKeyedChildren(c1, c2, el, parentComponent);
        } else {
          /**
           * 新子节点是空
           * 数组 ——> 空
           * 删除所有旧子节点
           */
          unmountChildren(c1, parentComponent);
        }
      } else {
        /**
         * 旧子节点是文本或空
         * 文本 ——> 数组
         * 文本 ——> 空
         * 空 ——> 数组
         * 空 ——> 空
         * 旧子节点若是文本，则清空再挂载新子节点
         * 不是则直接挂载新子节点
         */
        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
          hostSetElementText(el, '');
        }
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          mountChildren(c2, el, anchor, parentComponent);
        }
      }
    }
  }

  /**
   * VNode的diff更新处理
   */
  function patchElement(n1, n2, parentComponent) {
    // n1 和 n2 能复用说明dom节点就不用删除了

    // 复用真实DOM节点,不用删除
    let el = (n2.el = n1.el);

    let oldProps = n1.props;
    let newProps = n2.props;
    // 比较属性
    patchProps(oldProps, newProps, el);

    // 比较children
    patchChildren(n1, n2, el, null, parentComponent);
  }

  /**
   * 文本类型的VNode的挂载和更新处理
   */
  function processText(n1, n2, container) {
    if (n1 == null) {
      hostInsert(
        (n2.el = hostCreateTextNode(n2.children)),
        container
      );
    } else {
      // 复用老的节点
      const el = (n2.el = n1.el);
      let newText = n2.children;
      if (newText !== n1.children) {
        // 不相同才更新
        hostSetText(el, newText);
      }
    }
  }

  function processFragment(n1, n2, container, parentComponent) {
    const fragmentEndAnchor = (n2.anchor = n1
      ? n1.anchor
      : hostCreateText(''))!;

    if (n1 == null) {
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent
      );
    } else {
      patchKeyedChildren(
        n1.children,
        n2.children,
        container,
        parentComponent
      );
    }
  }

  /**
   * 元素类型的VNode的挂载和更新处理
   */
  function processElement(
    n1,
    n2,
    container,
    anchor,
    parentComponent
  ) {
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent);
    } else {
      patchElement(n1, n2, parentComponent);
    }
  }

  /**
   * VNode的初始化挂载和diff更新
   * @param n1 容器上保存的上一次的VNode
   * @param n2 新的VNode
   * @param container 容器 真实的DOM节点
   */
  const patch = (
    n1,
    n2,
    container,
    anchor = null,
    parentComponent = null
  ) => {
    // 若n1有值且n2、n1不相等，则说明是要将n1替换成n2
    if (n1 && !isSameVNode(n1, n2)) {
      // 卸载n1并重制为null，后续走n2的初始化
      unmount(n1, parentComponent);
      n1 = null;
    }

    /**
     * n1 如果是null 说明是初始化挂载
     * n1 如果有值 说明是更新 要走diff算法
     */
    const { type, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container);
        break;
      case Fragment:
        processFragment(n1, n2, container, parentComponent);
        break;
      default:
        if (shapeFlag & ShapeFlags.ELEMENT) {
          // 通过位运算判断当前VNode是元素类型
          processElement(n1, n2, container, anchor, parentComponent);
        }
    }
  };

  /**
   * VNode的卸载
   */
  const unmount = (n1, parentComponent) => {
    let { shapeFlag, component } = n1;

    if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
      parentComponent.ctx.deactivate(n1);
    }

    if (n1.type == Fragment) {
      // fragment 删除所有子节点
      return unmountChildren(n1.children, parentComponent);
    } else if (shapeFlag & ShapeFlags.COMPONENT) {
      // _vnode 组件的虚拟节点  subTree组件渲染的内容
      return unmount(component.subTree, parentComponent); // 组件要卸载的是subTree 而不是自己
    }

    hostRemove(n1.el);
  };

  /**
   * DOM的渲染方法
   * 负责DOM的初始化挂载、更新、卸载
   * @param vnode 虚拟节点
   * @param container 容器，真实的DOM节点
   */
  function render(vnode, container) {
    if (vnode == null) {
      // 卸载
      if (container._vnode) {
        unmount(container._vnode, null);
      }
    } else {
      // 初始化挂载和更新
      patch(container._vnode || null, vnode, container);
    }
    // 第一次渲染的时候就将vnode保留到了容器上，用于后续区分是初始化挂载还是更新
    container._vnode = vnode;
  }

  return {
    render
  };
}

```

### 三、总结

==其实整个Vue渲染原理的核心就是 `createRenderer`方法，其中包含了DOM 的初始化挂载、`diff`更新、卸载==。

这里也是Vue最消耗性能的地方，若是虚拟DOM的结构复杂些， `createRenderer`中便会有很多递归运算；

了解渲染原理的源码有助于更加深入的理解Vue。