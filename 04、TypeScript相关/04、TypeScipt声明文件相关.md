## TypeScript使用记录(四) 声明文件相关

### 一、什么是TypeScript声明文件

在**TypeScript**中，==**声明文件**用于描述JavaScript库或模块的类型信息==。它们提供了有关变量、函数、类和模块等代码元素的类型定义，使得**TypeScript**编译器能够在开发过程中==进行类型检查和提供智能感知==，类型声明文件的后缀是`.d.ts` <!--屁话，难以理解，就是将TS类型单独放到一个文件中，并且TS可以自己引入这些类型-->

`*.d.ts`文件和`*.ts`文件的区别：

- `*.d.ts`对于**TypeScript**而言，是**类型声明文件**，
  - 在`*.d.ts`文件中的顶级声明必须以`declare`或`export`修饰符开头
  - `*.d.ts`文件==只在开发阶段有用==，用于声明一些变量或者类型，以免**TypeScript**在做检查的时候抛出变量或类型不存在的错误，从而导致编译失败，在项目编译过后，`*.d.ts`文件是不会生成任何代码的
  - 同时，`*.d.ts`文件还能帮助**TypeScript**获得对应的代码补全、接口提示等功能
- `*.ts`则没有那么多限制，任何在`*.d.ts`中的内容，均可以在`*.ts`中使用

### 二、TypeScript声明文件的分类

**TypeScript**声明文件可以分为**全局声明文件**和**模块声明文件**：

1. **==全局声明文件==**：用于描述全局范围的变量、函数、类、命名空间等

   - 默认情况下，**TypeScript** 会解析项目内所有 `.d.ts` 文件，==当声明文件中不出现顶层 `import` 或 `export` 时==， 文件内声明的都是全局变量或全局类型
   - 也就是说，这些全局变量或全局类型都是可以在全局任何地方直接使用的，而不需要导入后再使用

2. **==模块声明文件==**：模块声明文件用于描述模块、库或第三方依赖的类型信息，它们提供了对模块导出的变量、函数、类和命名空间的类型定义

   - 模块声明文件的命名通常与模块名称相匹配，并以`.d.ts`结尾。例如，`lodash.d.ts`、`react.d.ts`等

   - ==只要声明文件中出现顶层的 `import` 或 `export`，那么这个声明文件就会被当做模块==，模块中所有的声明都是==局部变量==或==局部类型==，必须 `export` 导出后，才能在其他文件中通过`import`或`/// <reference>`指令引入使用

### 三、 TypeScript 查找第三方依赖包类型声明文件时的顺序

第三方依赖包的类型声明文件属于**模块声明文件**，通常当当我们在代码中导入一个模块时，**TypeScript** 会根据导入的模块名==自动查找对应的类型声明文件==，例如`import React from 'react'`时，便会自动去查找`react`的类型声明文件

这种自动查找模块声明文件的模式，会按照下面的顺序进行查找

1. 首先会在**==依赖包内部查找==**
   - 先查找 npm 包的 `package.json` 中的==根属性 `types` 或 `typings` 字段指定的声明文件==，有则使用，否则继续查找
   - 查找 npm 包的**==根目录==**是否有一个 `index.d.ts` 声明文件，有则使用，否则继续查找
   - 查看 npm 包的 `package.json` 中的根属性 `main` 字段（入口文件），==查找和入口文件同级目录下==是否有同名的 `.d.ts` 文件，有则使用，否则认为此 npm 包完全没有声明文件
2. 接着会在**==依赖包外查找==**
   - 首先会按照文件目录层级依次向上查找项目中的 `node_modules/@types` ，查找==与依赖包名称相对应==的类型声明文件
      - 例如，如果你的项目依赖了 `lodash`，**TypeScript** 会在 `node_modules/@types` 目录下查找是否存在 `lodash` 的类型声明文件，如 `lodash.d.ts`
   - 如果在项目的 `node_modules/@types` 目录下找不到与依赖包名称相对应的类型声明文件，**TypeScript** 会继续查找全局安装的类型声明文件，全局安装的类型声明文件通常位于全局的 `typings` 或 `types` 目录下

如果 **TypeScript** 仍然无法找到类型声明文件，它会假设该依赖包不包含类型声明，将其视为一个纯 **JavaScript** 库，无法提供类型检查和推断

### 四、`.ts`文件与`.tsx`文件使用全局声明文件的区别

在普通的 `.ts` 文件中，如果在全局范围内声明了一个类型，它会被默认视为全局可用的类型

这是因为在 `.ts` 文件中，默认情况下，**TypeScript** 假设你是在全局范围内工作，并且==在编译过程中会将所有全局声明合并到一个全局命名空间中==

例如，如果你在一个 `.ts` 文件中声明了一个全局类型：

```typescript
interface Person {
  name: string;
  age: number;
}
```

你可以在同一个项目的其他 `.ts` 文件中直接使用 `Person` 类型，而无需进行额外的导入操作

然而，在 `.tsx` 文件中，情况略有不同，`.tsx` 文件通常用于编写 **React** 组件，其中可能会涉及 **JSX** 语法和嵌入式的 **TypeScript** 类型注解

由于 `.tsx` 文件的特殊用途，**TypeScript** 默认不会将全局类型声明合并到全局命名空间中，这是为了避免可能的命名冲突和类型混淆，因此，当在 `.tsx` 文件中使用全局类型声明时，**TypeScript** 并不会假设这些类型对整个项目都是可见的，而是要求显式地导入它们要在 `.tsx` 文件中使用全局类型声明，==需要确保先在文件顶部使用 `import` 或 `/// <reference>` 指令将相关类型声明导入进来==

<!--不是很理解这个原因，但现象就是要先引入才能使用-->

例如：

```typescript
import { Person } from './types'; // 假设类型声明在 types.ts 文件中

const MyComponent: React.FC = () => {
  const person: Person = { name: 'John', age: 25 };

  // 组件的其余代码...

  return <div>{person.name}</div>;
};

export default MyComponent;
```

通过显式地导入类型声明，可以确保在 `.tsx` 文件中正确使用全局类型，并避免可能的冲突和错误

### 五、TypeScript 的配置文件（`tsconfig.json`）在项目中的生效顺序

1. 基于命令行：
   - 如果使用命令行直接指定了 **TypeScript** 配置文件，例如 `tsc --project tsconfig.json`，那么该指定的配置文件将直接生效
2. 当前目录的配置文件：
   - **TypeScript** 将会在当前目录中查找并使用名为 `tsconfig.json` 的配置文件。==如果找到了该配置文件，它将被用作主要的配置文件，并且不会继续查找其他位置的配置文件==
3. 父目录的配置文件：
   - 如果在当前目录中找不到 `tsconfig.json`，**TypeScript** 将会递归向上查找父目录，直到找到包含 `tsconfig.json` 的目录为止。找到的第一个 `tsconfig.json` 文件将被用作主要的配置文件，==并且不会继续查找其他位置的配置文件==
4. 默认配置：
   - 如果 **TypeScript** 在项目的根目录及其父目录中都找不到任何 `tsconfig.json` 文件，它将使用默认配置作为后备配置。默认配置是 **TypeScript** 自身定义的一组默认值，用于编译 TypeScript 代码。

需要注意的是，如果 **TypeScript** 在项目中找到了多个 `tsconfig.json` 文件，它只会使用第一个找到的配置文件，并忽略其他位置的配置文件



