## 为何 Vue 不需要时间切片

### 一、前言

**React Fiber** 架构是 **React** 团队于 **2017** 年提出并在 **React 16** 中首次发布的一项全新架构，是 **React** 团队对 **React** 框架底层架构的一次重大重构

旧版 **React** 架构采用「递归」的方式处理虚拟 **DOM** 树，一旦开始渲染就无法中断，会导致性能问题，特别是在复杂应用中会出现掉帧现象

而新版架构（**Fiber** 架构）==将渲染任务拆分成小单元，支持中断和恢复，从而实现了并发模式==，**Fiber** 架构的主要目的是提升性能和用户体验

> 有人认为 **React Fiber** 架构只是一种补丁，他们觉得 **Fiber** 是为了弥补旧架构的不足，而不是一开始就设计好
>
> **React** 早期的设计没有预见到现在的需求变化，导致后来需要大规模重构，这种情况下，**Fiber** 看起来像是对原有架构缺陷的补救措施，而不是预先规划好的设计
>
> 但在软件迭代中，架构调整是正常的，特别是像 **React** 这样被广泛使用的库，必须不断适应新需求；虽然 **Fiber** 确实解决了旧架构的问题，但这也==是一种演进，而不是简单的补丁==
>
> 不能混淆了补丁和架构演进的区别

而「**时间切片**」正是 **React Fiber** 架构中所使用的一项关键技术，那作为另外一项主流的前端渲染库（**Vue**）是否也面临着类似 **React 旧架构**的性能瓶颈，是否也需要「**时间切片**」？

这一问题要从 **Vue** 框架设计哲学、渲染机制两方面进行深入分析：

### 二、框架设计哲学

- **Vue** 与 **React** 框架设计哲学对比

  | **设计维度** | **React**                 | **Vue**                   |
  | ------------ | ------------------------- | ------------------------- |
  | **更新策略** | **Pull-based** (显式调度) | **Push-based** (自动追踪) |
  | **优化重心** | 调度算法                  | **==编译优化==**          |
  | 内存模型     | 不可变数据结构            | 可变响应式对象            |

  <!--不可变数据结构表示着更新的确定性，可变响应式对象在复杂场景下可能会产生级联更新风暴-->

- **Vue** 与 **React**（旧）核心架构差异对比

  | **特性**         | **React (Fiber前)**               | **Vue 2/3**                |
  | ---------------- | --------------------------------- | -------------------------- |
  | **更新触发方式** | ==自顶向下递归==                  | ==细粒度依赖追踪==         |
  | **DOM 更新粒度** | 整树协调(**Full Reconciliation**) | ==组件级重渲染==           |
  | **任务调度机制** | 同步不可中断                      | 异步批处理队列             |
  | **内存结构**     | 虚拟**DOM**树                     | 虚拟**DOM** + 响应式依赖图 |


### 三、Vue 渲染机制中的关键设计

#### 3.1、响应式系统的天然优势
- **组件级更新边界**：

  - 每个组件实例对应一个渲染 **Watcher**
  - 数据变更仅触发相关组件重新渲染

- **依赖收集自动化**：

  ```javascript
  // Vue 3 的响应式原理
  const proxy = new Proxy(data, {
    get(target, key) {
      track(target, key) // 自动收集依赖
      return Reflect.get(target, key)
    },
    set(target, key, value) {
      trigger(target, key) // 精准触发更新
      return Reflect.set(target, key, value)
    }
  })
  ```

- **响应式依赖追踪示意图**：

  ```
  [组件模板]                          [响应式数据]
     │                                  │
     ▼                                  ▼
  ┌─────────────┐  getter触发   ┌─────────────────┐
  │ 渲染Watcher │◀─────────────┤  Proxy Object   │
  └─────────────┘  依赖收集     └─────────────────┘
         ▲                           ▲ ▲ ▲
         │ setter触发                 │ │ │
         │                         ┌─┘ │ └─┐
         │                   ┌─────┴┐┌─┴─┐┌─┴────┐
         │                   │ 状态A ││状态B││ 状态C │
         │                   └──────┘└───┘└──────┘
         │
  ┌──────────────┐
  │ 异步更新队列  │
  └──────────────┘
  ```

  **运作流程**：

  1. 组件初次渲染时，**渲染 Watcher **读取组件中的响应式数据
  2. 通过 **Proxy** 的 `getter` 自动建立数据与 **Watcher** 的依赖关系
  3. 数据变更时，通过 `setter` 触发对应 **Watcher** 入队更新
  4. 更新执行被延迟到微任务队列批量处理

#### 3.2、异步更新队列机制

- **异步更新队列原理**：

  ```javascript
  // Vue 的更新调度伪代码
  const queue = []
  let flushing = false
  
  function queueWatcher(watcher) {
    if (!queue.includes(watcher)) {
      queue.push(watcher)
    }
    if (!flushing) {
      nextTick(flushQueue) // 延迟到微任务阶段执行
    }
  }
  
  function flushQueue() {
    queue.sort((a,b) => a.id - b.id) // 保证父组件先更新
    queue.forEach(watcher => watcher.run())
  }
  ```

- **异步更新队列时序图**：

  ```
  [数据变更] → [触发setter]
                    │
                    ▼
              [Watcher入队]
                    │
                    ▼
          ┌───────────────────┐
          │ 微任务队列         │
          │  - Watcher1.run() │
          │  - Watcher2.run() │
          └───────────────────┘
                    │
      ┌─────────────┴─────────────┐
      ▼                           ▼
  [虚拟DOM对比]              [DOM更新]
      │                           │
      └───────────┬───────────────┘
                  ▼
           [视图更新完成]
  ```

  **关键阶段**：

  1. **批处理阶段**：同一事件循环内的多次数据变更被合并
  2. **排序阶段**：父组件 **Watcher** 总是优先于子组件执行
  3. **执行阶段**：在微任务中一次性完成所有组件的**虚拟 DOM** 对比和 **DOM** 更新

#### 3.3、编译时优化策略 (**Vue** 3)

```html
<!-- 原始模板 -->
<div>
  <span>静态文本</span>
  <div v-for="item in list" :key="item.id">{{ item.name }}</div>
</div>

<!-- 编译后代码结构 -->
export function render(_ctx) {
  return (_openBlock(), _createBlock("div", null, [
    _hoisted_1,  // 静态节点提升
    _createVNode("div", null, _toDisplayString(_ctx.item.name), 1 /* TEXT */)
  ]))
}
```

**优化点标记**：

1. **静态节点提升**：`_hoisted_1` 指向静态 `<span>`节点，跳过静态节点对比
2. **动态标记**：`1 /* TEXT */` 表示只有文本内容需要更新
3. **块树结构**：`_openBlock()` 开启动态节点追踪上下文

#### 3.4、小结

**Vue** 通过「**响应式系统**」、「**异步更新队列**」、「**模板编译优化**」的设计，在保持高性能的同时避免了复杂调度器的开发成本

这种架构选择使得 **Vue** 在典型业务场景下（非极端大规模数据操作）能天然规避「同步递归」带来的性能问题，但也意味着在超大规模应用场景中需要开发者更主动地实施性能优化策略

### 四、**Vue** 不需要时间切片的核心原因

前面对 **Vue** 框架设计哲学、渲染机制进行了深入分析，进而可以得出 **Vue** 不需要时间切片的核心原因如下：

1. **更新粒度更小**

   - **React**：==全局虚拟**DOM**树协调，必须遍历整树==

   - **Vue**：==组件级更新 + 精确依赖追踪，平均更新路径缩短 60%==

2. **任务调度层设计**

   - **React**：需要主动让出主线程控制权
     
     ```javascript
     // React 调度逻辑
     const task = scheduleCallback(performConcurrentWorkOnRoot)
     ```

   - **Vue**：利用浏览器事件循环机制
     
     ```javascript
     // Vue 的 nextTick 实现
     const p = Promise.resolve()
     function nextTick(fn) {
       return p.then(fn) // 微任务队列批处理
     }
     ```
     
     <!--其实 React18 的任务调度也是利用了浏览器的时间循环机制，但是要比 Vue 的复杂很多，涉及到更新优先级，所以 React 的运行时文件体积要更大-->


3. **AOT优化**
- **React**：使用 **JSX**，无需编译
   
- **Vue**：使用模板，可以进行模板编译优化


### 五、React 18 和 Vue3 的性能关键指标对比

| **测试场景**          | **React** 18 (并发模式) | **Vue** 3 | 技术实现差异                      |
| --------------------- | ----------------------- | --------- | --------------------------------- |
| 10000节点初次渲染     | 320ms                   | 280ms     | **Vue** 的模板编译优化优势        |
| 500节点频繁更新       | 16ms/op                 | 12ms/op   | 响应式精准更新 vs 虚拟**DOM**对比 |
| 输入延迟(99th)        | <50ms                   | <30ms     | **Vue** 的微任务批处理机制        |
| 内存占用(典型**SPA**) | ~1.8MB                  | ~1.2MB    | **Proxy** 比 **Fiber** 节点更轻量 |

<!--以上数据来自官方基准测试（React Conf 2021 演示数据，Vue Mastery 性能专题课案例）、第三方对比评测（Krausest/js-framework-benchmark，Stefan Krause 的框架性能追踪平台）-->

### 六、尤雨溪关于此问题的回答

[Why remove time slicing from vue3? — 尤雨溪](https://github.com/vuejs/rfcs/issues/89#issuecomment-546988615) 

核心观点如下：

1. **现有更新机制已足够高效**
   - **Vue** 的「响应式系统」和更新策略采用了「异步队列」「批处理」机制，使得大部分更新操作操作的耗时通常在 1ms 以内
   - 大多数更新只涉及局部数据变化，所以每次更新的工作量较小，并且更新过程本身经过充分优化，因此无需引入额外的时间切片机制来分割任务
2. **保持设计的简单性与稳定性**
   - **Vue** 的设计目标之一就是简单、高效，而目前的「同步响应」和「批处理更新」已经能满足绝大多数应用场景的性能需求
   - **Vue** 的更新操作均在极短时间内完成（通常低于 1ms），完全在浏览器帧率要求内运行，引入时间切片不仅无实际必要，还会增加调度和代码复杂度
3. **时间切片的适用场景有限**
   - **React** 的「**时间切片**」机制主要面向「复杂场景」下可能超出 16ms 帧窗口的任务，通过任务拆分来降低主线程压力，但同时也带来了额外的调度开销
   -  但在 **Vue** 的常见使用场景下，这种问题并不明显，**Vue** 现有的架构和更新策略已经在性能和用户体验上达到了良好的「**平衡**」，没有必要为了极少数边缘情况而引入额外机制

总结：尤雨溪认为 **Vue** 不需要「**时间切片**」，因为当前的「**响应式更新**」方式已经能够高效、简洁地处理大多数更新场景，引入「**时间切片**」不仅收益有限，还可能破坏原有的设计原则和代码可维护性

<!--尤雨溪的评价中提供了一些客观量化指标（Vue 1ms、React 5ms 切片）并进行了合理的技术分析，但也表现出了其作为竞品代表的主观倾向，有意弱化 React 在复杂场景下的优势，强调 Vue 的设计优势-->

<!--React 和 Vue 的差异本质上是不同设计哲学之间的权衡和选择，其中一点的具体表现就是，在性能优化和更新策略上有不同侧重点-->









