## 滑动窗口算法

### 一、前言

#### 1.1、概述

**「滑动窗口」**（**Sliding Window**）是一种高效处理数组或字符串**「连续区间问题」**的算法技巧，通过维护一个**「动态窗口」**来快速求解满足条件的连续子数组或子串

**特性：**

- **连续性**：窗口内的元素是**「连续的子区间」**
- **双指针驱动**：通常用 `left` 和 `right` 控制窗口边界
- **动态更新**：扩张与收缩窗口时，窗口状态能在 **O(1)** 时间内更新
- **常见复杂度**：**O(n)**，适合大规模数据处理

**适用场景：**

- **固定长度**的区间统计（求和、求平均等）
- **可变长度**的条件匹配（如无重复字符、最小覆盖子串）

**核心思想：**

1. **两个指针** `left`、`right` 表示窗口边界
2. **右指针右移** 扩展窗口
3. 当窗口不满足条件时，**左指针右移** 收缩窗口
4. 每次窗口调整后更新结果

#### 1.2、算法模板与应用

**通用模板：**

```js
function slidingWindow(arr, conditionCheck, updateResult) {
  let left = 0;
  let windowState = {}; // 用于维护窗口状态（计数、和、Set、Map等）

  for (let right = 0; right < arr.length; right++) {
    // 1. 加入新元素（扩展窗口）
    addElementToWindow(windowState, arr[right]);

    // 2. 当窗口不满住条件时，左指针右移，收缩窗口
    while (!conditionCheck(windowState)) {
      removeElementFromWindow(windowState, arr[left]);
      left++;
    }

    // 3. 每次窗口调整后，更新结果
    updateResult(windowState, left, right);
  }
}
```

> 核心是：**扩张 + 收缩 + 更新状态** 三步循环
>
> **收缩** 和 **更新状态** 的顺序取决于窗口长度是否固定
>
> - 固定窗口长度
>   - 先更新状态，再收缩窗口
>   - 窗口长度满足条件时，窗口就已经有效了
> - 非固定窗口长度
>   - 先收缩窗口，再更新状态
>   - 需要先保证窗口有效
>
> 通用模板中一般是，先收缩窗口，在更新状态，因为大多数复杂题都是非固定窗口

**具体使用：**

**描述：**给定一个整数数组 `nums` 和整数 `k`，找出长度恰好为 `k` 的连续子数组的最大和

**示例：**

```markdown
输入：[1, 2, 3, 4, 5], 2
输出：9 (4+5)
```

**题解：**

```javascript
function maxSumSubarray(nums, k) {
  // 定义左指针
  let left = 0;
  // 创建一个窗口状态对象，用于维护窗口内的状态，sum 用于记录窗口内的和，size 用于记录窗口内的元素个数
  let windowState = { sum: 0, size: 0 };
  let maxSum = -Infinity;

  // 添加元素到窗口
  function addElementToWindow(state, value) {
    state.sum += value;
    state.size++;
  }

  // 移除元素从窗口
  function removeElementFromWindow(state, value) {
    state.sum -= value;
    state.size--;
  }

  // 检查窗口是否满足条件
  function conditionCheck(state) {
    // 窗口大小不能超过 k
    return state.size <= k;
  }

  // 更新结果
  function updateResult(state) {
    // 当窗口大小刚好为 k 时更新最大值
    if (state.size === k) {
      maxSum = Math.max(maxSum, state.sum);
    }
  }

  // 遍历数组，右指针右移
  for (let right = 0; right < nums.length; right++) {
    // 1. 加入新元素（扩展窗口）
    addElementToWindow(windowState, nums[right]);

    // 2. 当窗口不满足条件时，左指针右移，收缩窗口
    while (!conditionCheck(windowState)) {
      removeElementFromWindow(windowState, nums[left]);
      left++;
    }

    // 3. 每次窗口调整后，更新结果
    updateResult(windowState, left, right);
  }

  return maxSum;
}

// 示例
console.log(maxSumSubarray([1, 2, 3, 4, 5], 2)); // 输出 9 (4+5)

```

**解析：**

- 先创建一个**窗口状态对象**和一个**最大数变量**
  - **窗口状态对象**：记录窗口内所有元素的和和元素个数
  - **最大数变量**：记录最大和

- **扩展窗口**
  - 遍历数组，右指针右移，将新元素添加到窗口中
  - 并更新窗口状态，元素和增加，元素个数增加 1

- **收缩窗口**
  - 右指针一直往右移动，当窗口内的元素个数超过 k 时，则左指针右移，移除最左元素，使窗口内的元素个数维持在 k 个
  - 更新窗口状态，元素和减少，元素个数减少 1

- **更新结果**
  - 如果窗口大小刚好为 k，则更新最大和，并记录当前窗口内的和

- 最后返回**最大和**


### 二、经典问题

#### 2.1、固定长度最大子数组和

**题目描述：**

给定一个整数数组 `nums` 和一个整数 `k`，找出长度为 `k` 的连续子数组的最大和

```js
function maxSumSubarray(nums, k) {
  let sum = 0;
  let maxSum = -Infinity;

  for (let i = 0; i < nums.length; i++) {
    // 1. 加入新元素，扩展窗口
    sum += nums[i];

    if (i > k - 1) {
      // 2. 当窗口内的元素个数超过 k 时，说明窗口已不满足条件，需要移除最左元素，收缩窗口
      sum -= nums[i - k + 1];

      // 3. 每次窗口调整后，更新最大和
      maxSum = Math.max(maxSum, sum);


    }
  }
  return maxSum;
}

// 示例
console.log(maxSumSubarray([1, 2, 3, 4, 5], 2)); // 输出 9 (4+5)
```

#### 2.2、最小覆盖子串

**题目描述**

给定字符串 `s` 和字符串 `t`，返回 `s` 中包含 `t` 所有字符的最小子串。如果不存在这样的子串，返回空字符串 `""`

- 子串中的字符顺序不要求与 `t` 中一致，但必须全部包含
- 如果有多个长度相同的最小子串，返回任意一个即可

```js
function minWindow(s, t) {
  // 创建一个窗口对象，用于维护窗口内的状态

  // need 用于记录窗口内每个字符的个数
  const need = new Map();
  for (let c of t) need.set(c, (need.get(c) || 0) + 1);
  // 记录窗口内需要匹配的目标字符个数
  let count = t.length
  // 记录最小子串的长度
  let minLen = Infinity
  // 记录最小子串的起始位置
  let start = 0

  // 左指针
  let left = 0

  // 遍历字符串 s，右指针右移
  for (let right = 0; right < s.length; right++) {
    let c = s[right];

    if (need.has(c)) {
      if (need.get(c) > 0) count--;
      // 1. 扩展窗口
      need.set(c, need.get(c) - 1);
    }

    while (count === 0) { // 窗口已满足条件
      if (right - left + 1 < minLen) {
        minLen = right - left + 1;
        start = left;
      }
      let lc = s[left];
      if (need.has(lc)) {
        need.set(lc, need.get(lc) + 1);
        if (need.get(lc) > 0) count++;
      }
      left++;
    }
  }
  return minLen === Infinity ? "" : s.substring(start, start + minLen);
}

// 示例
console.log(minWindow("ADOBECODEBANC", "ABC")); // 输出 "BANC"
```

#### 2.3、无重复字符的最长子串

**题目描述**

给定一个字符串 `s`，找出其中不包含重复字符的 **最长子串** 的长度。

```js
function lengthOfLongestSubstring(s) {
  const set = new Set();
  let left = 0, maxLen = 0;

  for (let right = 0; right < s.length; right++) {
    while (set.has(s[right])) {
      set.delete(s[left]); // 收缩窗口
      left++;
    }
    set.add(s[right]); // 扩展窗口
    maxLen = Math.max(maxLen, right - left + 1);
  }
  return maxLen;
}

// 示例
console.log(lengthOfLongestSubstring("abcabcbb")); // 输出 3 ("abc")
```

### 三、核心思想解读

**本质总结**

- **双指针控制窗口**：`left` 收缩，`right` 扩展；
- **状态维护**：用变量/数据结构记录当前窗口信息；
- **条件驱动移动**：根据题目条件决定收缩或扩展窗口；
- **结果实时更新**：每次窗口变化时更新最优结果；
- **避免重复计算**：通过增量更新，省去每次全量扫描。
