## 正则表达式相关

### 一、概述

**正则表达式**（**Regular expression** 或 **regex** 或 **regexp**）是一组由字母和符号组成的特殊文本，正则表达式可以从一个基础字符串中根据一定的**匹配规则**「查找」、「替换」文本中的字符串，进行验证表单、提取字符串等操作

正则表达式有两种创建方式：

- **字面量**：`let reg = /ab+c/`

  ```js
  // 字面量形式创建
  let reg = /'正则表达式'/'匹配模式'  
  
  // 例如： 
  let reg = /^ab$/i  // 匹配以a开头b结尾的字符串，不区分大小写
  ```

- **构造函数**：`let reg = new RegExp('ab+c');`

  ```js
  // 构造函数形式创建
  let reg = new RegExp('正则表达式'，'匹配模式')    
  let reg = new RegExp('^ab$','i') // i 表示不区分大小写
  
  // 当使用构造函数时可以将变量嵌入到正则表达式中
  // 例如：
  const searchTerm = "DYNAMIC_PARAMS"
  // 使用构造函数创建正则表达式对象，并使用变量嵌入
  const pattern = new RegExp(`DYNAMIC_PARAMS\.${searchTerm}`, "g") // g 表示全局搜索
  
  typeof  reg === 'object', // 正则表达式是个对象
  ```

### 二、正则表达式常用的方法

- **test()**： **RegExp** 方法，用于检测字符串是否匹配正则表达式的模式；如果匹配，返回 `true`，否则，返回 `false`

  ```js
   // 用法：reg.test(str)
   let reg = /a/  
   reg.test(ab) // true 检查字符串中是否有'a'
  ```

- **exec()**：**RegExp** 方法，用于在字符串中查找匹配正则表达式的子串；如果找到匹配项，返回一个匹配的详细信息数组，否则返回 `null`

  - 语法：

    ```javascript
    regex.exec(string);
    ```

    - `regex`：正则表达式对象（`RegExp` 实例）

    - `string`：要在其中搜索匹配的目标字符串

  - 返回值：

    - **匹配成功**：返回一个数组，包含匹配结果的详细信息：

      - `index`：匹配开始的索引

      - `input`：目标字符串

      - 捕获组：如果正则表达式中有捕获组，会包含它们的匹配结果

    - **匹配失败**：返回 `null`

  - 特性

    - `exec` 方法**会影响全局正则表达式**（带有 `g` 标志的正则），多次调用会从上次匹配结束的地方继续

    - 非全局正则表达式，每次调用 `exec` 都从字符串的起始位置开始搜索

  - 示例

    1. 匹配简单字符串

       ```javascript
       const regex = /hello/;
       const result = regex.exec("hello world");
       
       console.log(result);
       // [
       //   'hello',
       //   index: 0,
       //   input: 'hello world',
       //   groups: undefined
       // ]
       ```

    2. 捕获组

       正则表达式可以使用捕获组 `()` 提取特定部分的匹配结果

       ```javascript
       const regex = /(\d{3})-(\d{3})-(\d{4})/;
       const result = regex.exec("Phone: 123-456-7890");
       
       console.log(result);
       // [
       //   '123-456-7890',
       //   '123', // 第1个捕获组
       //   '456', // 第2个捕获组
       //   '7890', // 第3个捕获组
       //   index: 7, // 匹配开始的索引
       //   input: 'Phone: 123-456-7890',
       //   groups: undefined
       // ]
       ```

    3. 全局正则表达式（`g` 标志）

       对于带 `g` 标志的正则，`exec` 会从上次匹配结束的地方继续

       ```javascript
       const regex = /\d+/g; // 匹配所有数字序列
       const str = "abc 123 def 456";
       
       let result;
       while ((result = regex.exec(str)) !== null) {
         console.log(result);
         console.log(`Matched: ${result[0]}, at index ${result.index}`);
       }
       
       // 输出：
       // [ '123', index: 4, input: 'abc 123 def 456', groups: undefined ]
       // Matched: 123, at index 4
       // [ '456', index: 12, input: 'abc 123 def 456', groups: undefined ]
       // Matched: 456, at index 12
       ```

       注意：每次调用会更新正则表达式对象的 `lastIndex` 属性，记录匹配位置

    4. 非全局正则（不受 `lastIndex` 影响）

       如果正则表达式没有 `g` 标志，每次调用 `exec` 都从头开始

       ```typescript
       const regex = /\d+/;
       const str = "123 456";
       
       let result1 = regex.exec(str);
       let result2 = regex.exec(str);
       
       console.log(result1); // 匹配 '123'
       console.log(result2); // 仍然匹配 '123'（从头开始）
       ```

- **match()**：**String** 方法，用于提取字符串中与正则表达式匹配的子串，如果找到匹配项，返回一个数组，否则，返回 `null`

  - 默认找到第一个符合的就停止检索

    ```javascript
    const str = "The quick brown fox jumps over the lazy dog.";
    const regex = /(\w+) (\w+)/;
    const result = str.match(regex);
    
    console.log(result);
    // 输出：["The quick", "The", "quick"]
    // result[0] 是整个匹配的字符串
    // result[1] 是第一个捕获组 "The"
    // result[2] 是第二个捕获组 "quick"
    
    ```

  - 可以设置全局匹配`/g`，

    ```javascript
    const str = "The quick brown fox jumps over the lazy dog.";
    const regex = /(\w+) (\w+)/g;
    const result = str.match(regex);
    
    console.log(result);
    // 输出：["The quick", "brown fox", "jumps over", "the lazy"]
    // 仅包含所有匹配项的字符串数组，不包含捕获组的信息
    ```

    <!--当 `match` 方法带有全局标志时，它会返回一个包含所有匹配项的数组，但不包括捕获组的信息，如果需要获取所有匹配项的捕获组信息，应该使用 `matchAll` 方法-->

- **matchAll()**：**String 方法**，返回一个迭代器，包含所有的匹配结果，与 `match` 不同，`matchAll` 始终返回包含捕获组的详细结果

  ```js
  const str = "The quick brown fox jumps over the lazy dog.";
  const regex = /(\w+) (\w+)/g;
  const matches = str.matchAll(regex);
  
  for (const match of matches) {
    console.log(match);
  }
  // 输出：
  // ["The quick", "The", "quick"]
  // ["brown fox", "brown", "fox"]
  // ["jumps over", "jumps", "over"]
  // ["the lazy", "the", "lazy"]
  ```

- **split()**：**String 方法**，将字符串拆分为一个数组

  ```js
  //用法：str.split(reg)
  let reg = /b/
  let str = 'abc'; 
  str.split(reg)  // ['a', 'c']
  ```

- **search()**：**String 方法**，检索与正则表达式相匹配的子字符串，并返回子串的起始位置,没有符合的则返回-1

  ```js
  //用法：str.search(reg)
  let reg = /a/;
  let str = 'abc';
  str.search(reg) // 1
  ```

- **replace()**：**String 方法**，替换一个与正则表达式匹配的子串

  ```js
  //用法：str.replace(reg，newStr)
  let reg = /(Hello), (\w+)!/
  let str = "Hello, world!";
  
  str.replace(reg, vvvv) // 'vvvvbc'
  // 或者
  str.replace(reg, function(match, p1, p2) {
    return `${p1}, wonderful ${p2}!`;
  }); 
  // "Hello, wonderful world!"
  // 替换函数的参数 match 是整个匹配的子字符串，p1 和 p2 分别是第一个和第二个捕获组
  ```


### 三、常见的使用示例

#### 3.1、替换带有边界的单词

```javascript
function replaceWholeWord(str, target, replacement) {
    // 对于中文单词，单词边界可以用空格或标点符号来表示
    const regex = new RegExp(`(?<![\\w\\u4e00-\\u9fa5])${target}(?![\\w\\u4e00-\\u9fa5])`, 'g');
    return str.replace(regex, replacement);
}

const result = replaceWholeWord('这是一个 a测试 字符串。This is a test testString. 这是一个 a测试字符串。', 'a测试', ' 11')
console.log(result); // 这是一个  11 字符串。This is a test testString. 这是一个 a测试字符串。
```

