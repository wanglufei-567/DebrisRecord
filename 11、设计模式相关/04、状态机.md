## 状态机

### 一、什么是状态机

现实中事物是有不同「状态」的，例如一个自动门，就有 **「open」** 和 **「closed」** 两种「状态」

我们通常所说的**「状态机」**是**「有限状态机」**，也就是==被描述的事物的状态的数量是有限个==

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20230412141512329.png" alt="image-20230412141512329" style="zoom:40%;" />

**状态机（State Machine**），也被称为**有限状态自动机（Finite-state automaton简称FSA）**，是一种数学模型，用于描述系统或程序在离散时间内==从一个状态转移到另一个状态==的行为，它由一组**「状态」**、**「转移规则」**和**「可能的输入」**组成，可以用来描述复杂的逻辑和控制流程

**「自动」**两个字也是包含重要含义的，给定一个状态机，同时给定它的**「当前状态」**以及**「输入」**，那么**「输出状态」**是可以明确的运算出来的，例如：对于自动门，给定初始状态 **closed** ，给定输入“**开门**”，那么**下一个状态**是可以运算出来的

### 二、状态机的组成

**状态机**一般由以下几个部分组成：

1. **状态（States**）： <!--状态集合：系统可能处于的所有状态的集合-->
   - 状态是系统或程序在**特定时刻**的某种状态或条件

   - 状态可以是离散的
     - 例如 "开始"、"进行中"、"完成" 等，也可以是连续的
     - 例如温度、速度等。状态通常用字符串、枚举、数值等方式进行表示

2. **转移规则（Transitions**）：
- 转移规则描述了在不同状态之间的**转移条件和动作**
   - 它定义了==在特定条件下从一个状态切换到另一个状态的行为==
     - 转移规则可以是简单的 `if/else` 逻辑，也可以是复杂的条件逻辑、事件触发等

3. **输入（Inputs）**：
- 输入是触发状态转移的**外部事件**、**信号或条件**
   - 输入可以来自用户输入、传感器信号、网络消息等
   - 状态机通过输入来触发不同的状态转移规则，从而改变系统的状态

4. **动作（Actions）**：
- ==动作是**状态转移过程**中执行的**具体操作或行为**==
   - 动作可以是更新状态、调用函数、发送消息等
   - 动作通常与转移规则相结合，定义了状态转移时应该执行的具体操作

5. **初始状态（Initial State）**：
   - 初始状态是状态机的起始状态，它表示系统或程序在开始时的初始状态
   - 状态机从初始状态开始，并通过输入和转移规则来不断改变当前状态
   
6. **终止状态（Final State）**：
   - 终止状态是状态机的结束状态，它表示系统或程序在某个条件下终止或结束的状态
   - 状态机可以在终止状态下停止运行或等待新的输入

这些部分一起构成了状态机的基本组成，并通过**状态**、**转移规则**、**输入**和**动作**之间的交互来描述系统或程序的行为

状态机可以用于建模和管理复杂的逻辑和控制流程，并在编程中实现各种应用场景，例如游戏、业务流程、协议处理等

### 三、具体使用

在 **JavaScript** 中，状态机可以通过对象和函数来实现

下面是一个简单的状态机示例，用于模拟一个交通信号灯的状态：

```js
// 定义一个交通信号灯状态机
const TrafficLightStateMachine = {
  currentState: "red",  // 初始状态为红灯
  transition: function() {  // 转移函数
    switch (this.currentState) {
      case "red":
        console.log("红灯，停车");
        this.currentState = "green";
        break;
      case "green":
        console.log("绿灯，行驶");
        this.currentState = "yellow";
        break;
      case "yellow":
        console.log("黄灯，准备停车");
        this.currentState = "red";
        break;
      default:
        console.log("无效状态");
    }
  },
  changeState: function() {  // 改变状态的方法
    this.transition();
  }
};

// 使用状态机模拟交通信号灯的行为
TrafficLightStateMachine.changeState();  // 输出：红灯，停车
TrafficLightStateMachine.changeState();  // 输出：绿灯，行驶
TrafficLightStateMachine.changeState();  // 输出：黄灯，准备停车
```

在这个例子中，`TrafficLightStateMachine` 对象表示了一个交通信号灯的状态机，包含了当前状态和转移函数。

- 状态机的**「初始状态」**为红灯，通过调用 `changeState` 方法，可以模拟交通信号灯的状态转移行为，输出对应的状态信息

- **「转移函数」**使用 `switch` 语句根据当前状态判断下一个状态，并更新当前状态 

  <!--这个很关键，这也是为什么状态机被称为有限状态自动机的精髓，有了当前状态和输入，状态机器会自动更新当前状态为下一状态-->

#### 3.1、**策略模式**和**状态模式**的区别

- **策略模式**和**状态模式**都有**==上下文==**，**有环境类或者状态类**，上下文把这些请求委托给这些类来执行
  - 策略模式是由上下文来选择执行何种策略 <!--上下文类-->
  - 状态模式是由上下文来决定下一状态和执行何种行为动作 <!--转移规则-->
- 策略模式中各个类是**「平等」**的，没有关系，客户端需要知道算法**「主动切换」**
  - 每个策略是独立的，不同策略之间是没有关系的
- 状态模式中，**状态的切换和行为被封装好了，会「自动切换和执行」**，客户不需要了解细节
  - 状态之间是关联的，状态的转移是需要上一状态+输入信号才能完成

