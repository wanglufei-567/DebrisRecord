## 动态规划

### 一、前言

**「动态规划」**是一种**算法思想**，用于把一个复杂问题**拆成**若干**相互重叠的子问题**，先算小的、再由小推大，并把中间结果保存起来，避免重复计算

> **动态规划** = **状态建模** + **有序转移** + **结果复用**
>
> - **状态建模**：用有限且可计算的状态来准确描述一个子问题，把原问题拆解为可枚举、可管理的问题空间
>
> - **状态转移**：用确定的规则描述当前状态如何由一个或多个已知状态推导得到

#### 1.1、动态规划要解决什么类型的问题？

动态规划并不是通用解法，它只针对**具有特定结构的问题**，主要解决以下类型：

- **问题可拆分为规模更小的子问题**
- **子问题之间高度重叠** <!--这个是关键特点-->
- **整体解可以由子问题解推导得到（最优子结构）**

  > **最优子结构**指的是：一个问题的最优解，可以由其子问题的最优解直接推导得到
  >
  > 通俗的说就是，若子问题是最优解，那么把它们组合起来，整体结果仍然是最优的
  >
  > <!--有些问题中子问题最优不能保证整体最优，这时就不能使用动态规划--> 

<!--动态规划最常见的问题就是解决求最值（最大 / 最小）-->

#### 1.2、动态规划的两种实现方式

动态规划有两种主流实现方式，**状态定义和转移完全一致，差异只在计算顺序**

**自顶向下（Top-Down，记忆化搜索）**：

- 从原问题出发递归拆解
  - 最后才是 **base case**

- 在递归过程中缓存已计算的状态 <!--使用备忘录缓存-->

- 更贴近问题的自然推导过程

```javascript
function dp(state):
  for 选择 in 所有可能的选择:
      // 此时的状态已经因为做了选择而改变
      result = 求最值(result, dp(状态1, 状态2, ...))
  return result
```

**自底向上（Bottom-Up，迭代填表）**

- 从最小子问题开始计算
  - 一开始就是 **base case**

- 按依赖顺序逐步填充状态表 <!--使用 DP Table 记录-->
- 无递归，执行路径明确，性能稳定

```javascript
// 初始化 base case
dp[0][0][...] = base case
// 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

#### 1.3、动态规划与分治思想的差异

**「动态规划」**与**「分治」**这两种思想很相似，但**解决的问题本质不同**

| 对比维度           | 分治思想   | 动态规划             |
| ------------------ | ---------- | -------------------- |
| 子问题关系         | 相互独立   | 高度重叠             |
| 是否复用结果       | 否         | 是                   |
| 是否要求最优子结构 | 否         | 是                   |
| 关注重点           | 拆分与合并 | 状态与转移           |
| 典型问题           | 排序、搜索 | 背包、路径、序列问题 |

**本质区别一句话概括：**

> 分治解决“可以拆的问题”，动态规划解决“拆了会反复计算的问题”

#### 1.4、动态规划解决斐波那契问题

暴力递归的解法

```javascript
// f(n) 计算第 n 个斐波那契数
var fib = function(n) {
    // base case
    if (n == 0 || n == 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
};
```

这种解法有个问题，中间有许多重复计算，导致算法复杂度为指数级别，既然存在大量的重复子问题，那么这个问题便可以使用「动态规划」思想来解决

**自顶向下的方式** <!--带备忘录-->

```javascript
const fib = function(n) {
    // 初始化备忘录，把 `f(0) ~ f(n)` 都记录到 memo 中
    let memo = new Array(n + 1).fill(-1);

    return dp(memo, n);
};


// 带着备忘录进行递归
const dp = function(memo, n) {
    // base case
    if (n === 0 || n === 1) {
        return n;
    }
    // 已经计算过，不用再计算了
    if (memo[n] !== -1) {
        return memo[n];
    }
    // 在返回结果之前，存入备忘录
    memo[n] = dp(memo, n - 1) + dp(memo, n - 2);
    return memo[n];
}
```

这种解法通过复用子问题的结果，将复杂度降低到 O(n)

**自地向上的方式** <!--使用 DP Table 记录-->

```javascript
const fib = function(n) {
    if (n === 0 || n === 1) {
        return n;
    }
    // dp table
    let dp = new Array(n + 1).fill(0);
    // base case
    dp[0] = 0; dp[1] = 1;
    // 状态转移
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
};
```

这种解法无需使用递归的方式，直接创建一个数组（**DP table**），用一个 `for` 循环从 **base case** 开始从左到右进行计算即可

### 二、零钱兑换

**描述：**

给定一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额

计算并返回可以凑成总金额所需的 **最少的硬币个数** ；如果没有任何一种硬币组合能组成总金额，返回 `-1` 

每种硬币的数量是无限的

**示例 ：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**思路：**

- 这个问题同时满足「动态规划」的两个必要条件

  - 最优子结构
    - 凑出金额 `amount` 的最少硬币数 = 在选择一枚硬币 `coin` 后 + 凑出 `amount - coin` 的最少硬币数
    - 如果子问题不是最优的，整体也不可能最优
  - 子问题重叠

- 状态转移公式

  ```javascript
  dp[i] = min( dp[i]，dp[i - coin] + 1 )  （coin ∈ coins 且 i >= coin）
  // i 是金额，coin 是硬币面额
  ```

**题解：**

```javascript
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function (coins, amount) {
  // memo[i] 表示：凑出金额 i 所需的最少硬币数
  // undefined 表示该状态尚未计算
  const memo = new Array(amount + 1).fill(undefined)

  /**
   * 计算凑出 remain 金额所需的最少硬币数
   * @param {number} remain
   * @return {number}
   */
  function dfs(remain) {
    // 基准情况：金额为 0，不需要硬币
    if (remain === 0) return 0

    // 无效状态：金额为负，说明当前选择不可行
    if (remain < 0) return -1

    // 如果该状态已经计算过，直接复用结果
    if (memo[remain] !== undefined) return memo[remain]

    let min = Infinity

    // 遍历所有面额，计算不同面额情况下子问题所需硬币数，取其中最小值
    for (const coin of coins) {
      // 子问题：凑出 remain - coin 的最少硬币数
      const sub = dfs(remain - coin)

      // sub >= 0 说明该子问题有解
      if (sub >= 0) {
        min = Math.min(min, sub + 1)
      }
    }

    // 如果所有选择都不可行，则该状态无解，若有解则将解记录下来，表示 remain 金额所需最少硬币数
    memo[remain] = min === Infinity ? -1 : min

    return memo[remain]
  }

  // 从原问题开始递归求解
  return dfs(amount)
}
```

**解析：**

- 给定总金额 `amount` 减去每种面额，获取到子问题的金额数 `remain`，取最小值的解，直到递归到 **base case**
  - 每一次的递归环节中的 `for` 循环次数取决于有多少种面额的硬币
- 同时为了避免重复计算，通过备忘录缓存子问题的解

### 三、最长递增子序列

**描述：**

给定一个整数数组 `nums` ，找到其中最长严格递增子序列的长度

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序；例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列

**示例 ：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 
```

**思路：**

- 最优子结构

  - 以 `nums[i]` 结尾的最长递增子序列，一定可以由某个 **以 `j < i` 且 `nums[j] < nums[i]` 为结尾的最长递增子序列** 接上 `nums[i]` 得到

- 状态转移公式

  - 对每个 `i`，向前看所有 `j < i`：

  ```javascript
  dp(i) = max( dp(j) + 1 )  (0 ≤ j < i 且 nums[j] < nums[i])
  ```

  - 想让序列递增，前一个数必须更小，在所有可接的位置中，选最长的那个

**题解：**

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {
  const n = nums.length
  if (n === 0) return 0

  // memo[i]：以 nums[i] 结尾的 LIS 长度
  const memo = new Array(n).fill(undefined)

  function dfs(i) {
    // 如果已经计算过，直接复用
    if (memo[i] !== undefined) return memo[i]

    let maxLen = 1 // 至少包含 nums[i] 自身

    // 向前寻找所有可以接在 nums[i] 前面的元素
    for (let j = 0; j < i; j++) {
      // 只有前面的元素小于当前的元素时，才去计算子问题
      // 以前面每一个元素结尾的最长递增子序列都是一个子问题
      if (nums[j] < nums[i]) {
        maxLen = Math.max(maxLen, dfs(j) + 1)
      }
    }

    memo[i] = maxLen
    return maxLen
  }

  let ans = 0
  // 最终结果是所有“以 i 结尾”的 LIS 中的最大值
  for (let i = 0; i < n; i++) {
    ans = Math.max(ans, dfs(i))
  }

  return ans
}
```

解析：

- 这道题的关键在于状态转移，也就是当前元素结尾的最长递增子序列 = 以当前元素前面的每一个小于当前元素结尾的最长递增子序列中最长的那一个 + 1
  - 前面每一个元素都要计算一次
