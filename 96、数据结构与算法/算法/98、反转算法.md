## 反转算法

### 一、前言

**「反转算法」**是一类用于将「数据结构」或「数据序列」的顺序颠倒的算法

它们在计算机科学中有着广泛的应用，尤其是在需要逆序处理数据的场景中

以下是一些常见的反转算法及其基本思想：

1. **数组反转**：
   - **基本思想**：通过交换数组两端的元素，逐步向中间靠拢，直到整个数组被反转
   - **实现**：通常使用双指针，一个指向数组的起始位置，另一个指向数组的末尾，交换这两个指针所指的元素，然后移动指针，直到它们相遇

2. **字符串反转**：
   - **基本思想**：与数组反转类似，通过交换字符串两端的字符来实现反转
   - **实现**：可以使用双指针法，也可以将字符串转换为字符数组进行反转

3. **链表反转**：
   - **基本思想**：通过改变链表节点的指针方向来实现反转
   - **实现**：可以使用迭代或递归的方法。迭代方法通过遍历链表并逐个反转节点的指针，递归方法则通过递归调用反转子链表

4. **栈反转**：
   - **基本思想**：利用栈的后进先出特性，通过将元素依次出栈并存入另一个栈来实现反转
   - **实现**：可以使用辅助栈来存储出栈的元素，然后再将其入栈到原栈中

5. **队列反转**：
   - **基本思想**：通过将队列中的元素依次出队并存入栈，然后再从栈中出栈存入队列来实现反转
   - **实现**：利用栈的后进先出特性来实现队列的逆序

6. **二叉树反转**：
   - **基本思想**：通过交换每个节点的左右子树来实现反转
   - **实现**：可以使用递归的方法遍历每个节点，并交换其左右子树

7. **图的反转**：
   - **基本思想**：在有向图中，将所有边的方向反转
   - **实现**：遍历图中的每条边，将其起点和终点交换

### 二、数组反转

#### 2.1、双指针法

  ```js
  var reverseArray = (arr) => {
    let left = 0
    let right = arr.length - 1
    while(left < right) {
      [arr[left], arr[right]] = [arr[right], arr[left]]
      left++
      right--
    }
    return arr
  }
  // 示例
  console.log(reverseArray([1, 2, 3, 4, 5])) // [5, 4, 3, 2, 1]
  ```

#### 2.2、递归法

  ```js
  var reverseArray = (arr) => {
    if(arr.length <= 1) return arr
    return [...reverseArray(arr.slice(1)), arr[0]]
  }
  // 示例
  console.log(reverseArray([1, 2, 3, 4, 5])) // [5, 4, 3, 2, 1]
  ```

### 三、字符串反转

#### 3.1、双指针法

```js
var reverseString = (s) => {
  const arr = s.split('')
  let left = 0
  let right = arr.length - 1

  while (left < right) {
    // 交换字符
    [arr[left], arr[right]] = [arr[right], arr[left]]
    left++
    right--
  }

  return arr.join('')
}

// 示例
console.log(reverseString("hello")) // "olleh"
```

#### 3.2、递归法

```js
var reverseString = (s) => {
  // 基础情况：空字符串或单个字符
  if (s.length <= 1) return s

  // 递归：取第一个字符，递归反转剩余部分，然后拼接
  return reverseString(s.slice(1)) + s[0]
}

// 示例
console.log(reverseString("hello")) // "olleh"
```

### 四、链表反转

链表数据结构

```javascript
/**
 * Definition for singly-linked list.
 */
function ListNode(val, next) {
  this.val = (val===undefined ? 0 : val)
  this.next = (next===undefined ? null : next)
}
```

#### 4.1、整体反转

##### 4.1.1、迭代法（双指针）


```js
var reverseList = (head) => {
  let prev = null
  let curr = head

  while (curr !== null) {
    // 暂存下一个节点
    const next = curr.next
    // 反转指针
    curr.next = prev
    // 移动指针
    prev = curr
    curr = next
  }

  return prev // prev 成为新的头节点
}

// 示例
console.log(reverseList([1, 2, 3, 4, 5])) // [5, 4, 3, 2, 1]
```

##### 4.1.2、递归法

```js
var reverseList = (head) => {
  // 基础情况：空节点或只有一个节点
  if (head === null || head.next === null) {
    return head
  }

  // 递归反转后续链表，返回新的头节点
  const newHead = reverseList(head.next)

  // 反转当前节点与下一个节点的连接
  head.next.next = head
  head.next = null

  return newHead
}

// 示例
console.log(reverseList([1, 2, 3, 4, 5])) // [5, 4, 3, 2, 1]
```

#### 4.2、反转链表前 N 个节点

##### 4.2.1、迭代法

```javascript
var reverseN = function(head, n) {
  if(head === null || head.next === null) return head

  let pre = null
  let cur = head
  let nxt = head.next
  let num = n

  while(num > 0) {
    // 反转 next 指针
    cur.next = pre
    // pre cur nxt 指针往下继续走
    pre = cur
    cur = nxt
    if (nxt != null) {
      nxt = nxt.next;
    }
    num --
  }
  // 此时 head 指针是尾节点，使其连接剩余链表
  head.next = cur
  // pre 指针是头节点
  return pre
}

// 示例
console.log(reverseN([1, 2, 3, 4, 5], 3)) // [3, 2, 1, 4, 5]
```

##### 4.2.2、递归法

```javascript
// 用于记录剩下未被反转链表的头节点
var successor = null;

// 反转以 head 为起点的 n 个节点，返回新的头结点
var reverseN = function(head, n) {
    // 递归终止条件
    if (n == 1) {
        // 记录第 n + 1 个节点，也就是未被反转的链表的起点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    var last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 反转之后的 head 节点就是链表的尾节点，再和剩余链表连接起来
    head.next = successor;
    return last;
}

// 示例
console.log(reverseN([1, 2, 3, 4, 5], 3)) // [3, 2, 1, 4, 5]
```

#### 4.3、反转链表的一部分

##### 4.3.1、迭代法

反转前 N 个节点的实现

```javascript
var reverseN = function(head, n) {
  if(head === null || head.next === null) return head

  let pre = null
  let cur = head
  let nxt = head.next
  let num = n

  while(num > 0) {
    // 反转 next 指针
    cur.next = pre
    // pre cur nxt 指针往下继续走
    pre = cur
    cur = nxt
    if (nxt != null) {
      nxt = nxt.next;
    }
    num --
  }
  // 此时 head 指针是尾节点，使其连接剩余链表
  head.next = cur
  // pre 指针是头节点
  return pre
}
```

利用反转前 N 个节点的实现，来实现反转链表的一部分

```javascript
var reverseBetween = function(head, left, right) {
  // 若是起点直接是第一个节点，则直接复用反转前 N 个节点的实现
  if(left === 1) return reverseN(head, right)

  let pre = head
  // 找到第 left 个节点的前一个节点
  for(let i = 1; i < left - 1; i++) {
    pre = pre.next
  }

  // 开始从第 left 个节点进行反转
  pre.next = reverseN(pre.next, right-left+1)
  return head
};
```

##### 4.3.2、递归法

反转前 N 个节点的实现

```javascript
// 用于记录剩下未被反转链表的头节点
let successor = null
const reverseN = (head, n) => {
  // 递归终止条件
  if(n === 1) {
    successor = head.next
    return head
  }

  // 返回反转链表的头节点
  const reverseListHead = reverseN(head.next, n-1)
  // 当前节点 head 和 head.next 节点进行反转
  head.next.next = head
  // 此时当前节点 head 是反转链表的尾节点，将尾节点和剩余未反转链表连接起来
  head.next = successor

  return reverseListHead
}
```

利用反转前 N 个节点的实现，来实现反转链表的一部分

```javascript

var reverseBetween = function(head, left, right) {
  if(left === 1) {
    return reverseN(head, right)
  }

  let pre = head
  // 找到 left 节点的前置节点
  for(let i = 1; i < left-1; i++) {
    pre = pre.next
  }

  // 以第 left 个节点为起始节点，反转前 right-left+1 个节点
  const reverseListHead = reverseN(pre.next, right-left+1)
  // left 节点的前置节点，连接已经被反转过的链表
  pre.next = reverseListHead

  // 返回链表头节点
  return head
 }
```

#### 4.4、