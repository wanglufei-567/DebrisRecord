## k8s笔记（一）k8s的基本使用

### 一、前言

#### 1.1、什么是 Kubernetes？

> **Kubernetes** 是一个 **Google** 开源**容器管理平台**，用于管理「**容器化**」的应用程序和服务，它可以自动化部署、扩展和管理这些「**容器化**」应用程序
>
> **Kubernetes** 的名字来源于希腊语，意思是 “舵手” 或 “飞行员”，因为它帮助我们导航和管理「**容器化**」的应用程序

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202408231456797.png" alt="Kubernetes or k8s" style="zoom:50%;" />

> 「**容器**」是一种轻量级、独立且可隔离的应用程序「**封装技术**」
>
> 它将应用程序及其所有依赖项（代码、运行时环境、库和配置文件）打包在一个单独的「可执行单元」中，容器技术允许开发人员将应用程序与计算环境隔离开来，使其能够在不同的计算环境中保持一致性和可移植性
>
> 区别于虚拟机虚拟一套完整的「操作系统」，容器仅仅只是封装了一套「 **root** 文件系统」
>
> <img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202409241405972.jpeg" alt="img" style="zoom:60%;" />
>
> <!--操作系统分为内核和用户空间，对于 Linux 而言，内核启动后，会挂载 root文件系统为其提供用户空间支持，容器创建的image就相当于是一个root文件系统-->
>
> **Docker**是目前主流的一种「**容器化**」平台

「**容器**」解决了应用程序在不同的计算环境一致性的问题，但新的问题又出现了：如果我想要部署「多个」容器，且对这些容器的「顺序」有一定要求呢？

比如一个博客系统，当然是先启动数据库，再启动身份验证服务，最后才能启动博客 **web** 服务

当然可以按照顺序挨个部署容器，但有没有更优雅的解决方案？ 

有，可以通过定义一个 **YAML** 文件，写清楚要部署的容器有哪些，部署顺序是怎么样的，以及这些容器占用的 **cpu** 和内存等信息，再进行自动化部署，这个就是 **Docker Compose** 干的事情

> **Docker Compose** 是一个用于定义和运行多容器 **Docker** 应用的工具，它通过使用 **YAML** 文件，来定义应用程序中涉及的服务、网络和卷等配置，然后通过简单的命令来启动和管理这些容器

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202409241432668.awebp" alt="Docker compose原理" style="zoom:40%;" />

==但是 **Docker-Compose** 只能管理当前主机上的容器，不能去管理其他服务器上的服务，意思就是单机环境==

那么对于大型应用程序， **Docker-Compose**就不能满足需求了，需要的是一个能够在多服务器上进行容器管理的工具了，这时 **Kubernetes** 和 **Docker Swarm **就出现了

**Kubernetes** 和 **Docker Swarm **互为竞品，**Kubernetes **背靠谷歌并且经过大量的实践和宿主机的实验，非常的成熟，所以 **Kubernetes** 正在成为容器编排领域的领导者，其可配置性、可靠性和社区的广大支持，从而超越了 **Docker Swarm**

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202408231501044.awebp" alt="Kubernetes的位置" style="zoom: 33%;" />

**Kubernetes** 介于**应用服务**和**服务器**之间，能够通过策略，协调和管理多个应用服务，只需要一个 **yaml** 文件配置，定义应用的部署顺序等信息，就能自动部署应用到各个服务器上，还能让它们挂了自动重启，自动扩缩容

想象一下，有很多个装有应用程序的小盒子「**容器**」，**Kubernetes** 就像一个聪明的管理员，帮我们安排这些盒子在哪些地方运行，确保它们正常工作，并且在需要的时候增加或减少盒子的数量

这样，我们就不需要手动去管理每一个应用程序，而是让 **Kubernetes** 来帮我们完成这些繁琐的任务

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202409241500332.awebp" alt="Docker和k8s" style="zoom:33%;" />

现在再回过头来看下 **Docker** 的图标，是一个个**集装箱**，放在一艘船上，这一个个集装箱指的就是互相隔离的「**容器**」，而 **k8s** 的图标，则是一个轮船上的**方向盘**，意思是 **k8s** 控制着轮船的航向，其实指的就是**调度**容器 <!--很巧妙了就是说-->

#### 1.2、Kubernetes 的主要功能

1. **自动部署和回滚**：定义应用程序的期望状态，**Kubernetes** 会自动将实际状态调整到期望状态
   - 例如：如果某个容器出现故障，**Kubernetes** 会自动重新启动或替换它
2. **服务发现和负载均衡**：**Kubernetes** 可以使用 **DNS** 名称或 **IP** 地址来暴露容器，并自动进行负载均衡，确保流量均匀分布
3. **存储编排**：**Kubernetes** 可以自动挂载用户选择的存储系统
   - 例如本地存储或云存储
4. **自我修复**：**Kubernetes** 会重新启动失败的容器、替换容器，并在准备好服务之前不将其通告给客户端
5. **水平扩缩**：根据 **CPU** 使用率或其他指标，**Kubernetes** 可以自动扩展或缩减应用程序的实例数量

#### 1.3、Kubernetes 的组件

1. **Master 节点**：**Master 节点**就像是 **Kubernetes** 集群的大脑，负责管理和控制整个系统

   > 它包含三个主要部分：
   >
   > - **API Server**： **Kubernetes** 的入口，所有的命令和请求都会先到这里，就像是一个接待员，负责接收和处理所有的指令
   > - **Scheduler**：**Scheduler** 就像是一个调度员，负责决定哪些应用程序（**Pod**）应该运行在哪些计算机（**Node**）上
   > - **Controller Manager**：这个组件负责确保系统的状态符合预期，比如确保有足够的副本在运行或者在节点故障时进行恢复

2. **Node 节点**：**Node 节点**是实际运行应用程序的地方，**Node 节点**可以是一台物理服务器，也可以是云中的一台虚拟机

   > 每个 **Node 节点**上都有两个重要的组件：
   >
   > - **Kubelet**： **Node 节点**上的一个代理，负责确保容器按照计划运行，并将状态报告给 **Master 节点**
   >
   >   <!-- Kubelet 就像是一个工头，负责确保每个容器按照计划运行。如果有问题，它会报告给 Master 节点-->
   >
   > - **Kube-proxy**： **Node 节点**上的一个网络代理，负责管理网络规则，确保网络流量能够正确地到达目标容器
   >
   >   <!-- Kube-proxy 是网络管理员，负责管理网络流量，确保请求能够正确地到达目标容器 -->

3. **Pod**：**Kubernetes** 中的==**最小部署单元**==，一个 **Pod** 可以包含一个或多个容器

   - 一个 **Pod** 封装了**一个或多个紧密相关的容器**，它们共享：

     - **网络命名空间**（包括 **IP 地址**和**端口**）

       > 容器默认有自己的网络命名空间，也可以配置加入其他容器或宿主机的网络命名空间
       >
       > **Kubernetes** 利用这一机制实现 **Pod 内容器共享网络**

     - **存储卷**（可选）

     - **运行环境配置**（如**环境变量**、**Secrets**、**ConfigMaps**）

4. **Service**：为一组 **Pod** 提供统一的访问入口，方便负载均衡和服务发现

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202408231502243.png" alt="在这里插入图片描述" style="zoom:80%;" />

上图是 **Kubernetes** 的一个集群，在这个集群中包含三台宿主机，这三个宿主机形成了一个完整的集群

> 集群指的是将几台服务器集中在一起，实现同一业务，它们共同工作，以提高系统的可用性和可扩展性
>
> 在集群中，每台服务器被称为一个节点，所有节点共同构成集群，节点之间通过特定的通信协议进行交互，以确保数据一致性和服务的高可用性

-  **Kubernetes Master** 主服务器 （**Master 节点**）是整个集群的管理者

  - 它可以对整个集群的节点进行管理，通过主服务器向这些节点，发送创建容器、自动部署、自动发布等功能，
  - 所有来自外部的数据都会由 **Kubernetes Master** 进行接收并进行分配

- **Node 节点** 负责实际运行各个应用程序

  - 多个应用程序**共享**一台 **Node** 上的内存和 **CPU** 等计算资源

  - **Master 节点**直接管理 **Node 节点**，通过 **Node 节点**间接管理 **Pod**，**Node 节点** 执行 **Master 节点** 的指令，并实际运行和管理 **Pod** 

#### 1.4、Kubernetes 的优势

1. **高可用性**：通过自动化的故障恢复和负载均衡，确保应用程序的高可用性
2. **可扩展性**：可以根据需求自动扩展或缩减资源，确保资源的高效利用
3. **灵活性**：支持多种存储和网络解决方案，适用于各种应用场景
4. **跨平台**：可以在不同的云平台和操作系统上运行，具有很强的可移植性

### 二、YAML 配置文件

#### 2.1、什么是 YAML 文件？

**YAML**（**YAML Ain’t Markup Language**）是一种专门用来写配置文件的语言，它非常简洁和强大，使用起来比 **JSON** 更方便，**YAML** 文件通过缩进来表示层级关系，通常用于定义和管理 **Kubernetes** 资源

#### 2.2、YAML 文件在 Kubernetes 中的作用

在 **Kubernetes** 中，==**YAML** 文件用于定义各种资源对象的配置==，比如 **Pod**、**Service**、**Deployment** 等

通过编写 **YAML** 文件，可以描述这些资源的期望状态，然后 **Kubernetes** 会根据这些配置自动化地创建和管理资源

#### 2.3、YAML 文件的结构

一个典型的 **Kubernetes** **YAML** 文件包含以下几个部分：

1. **apiVersion**：指定 **Kubernetes API** 的版本

2. **kind**：指定资源的类型

   以下是一些常见的 **kind** 类型及其用途：

   - **Pod**：**Pod** 是 **Kubernetes** 中的最小部署单元，包含一个或多个容器

     - 它们共享相同的网络和存储资源，通常用于定义应用的运行实例

       示例：

       ```yaml
       apiVersion: v1
       kind: Pod
       metadata:
         name: example-pod
       spec:
         containers:
           - name: app-container
             image: nginx
       ```

   - **Deployment**：**Deployment** 用于管理 **Pod** 的创建、更新和销毁 <!--常用-->

     - 它支持滚动更新和回滚，确保应用程序的高可用性和版本控制

       示例：

       ```yaml
       apiVersion: apps/v1
       kind: Deployment
       metadata:
         name: example-deployment
       spec:
         replicas: 3
         selector:
           matchLabels:
             app: example
         template:
           metadata:
             labels:
               app: example
           spec:
             containers:
               - name: app-container
                 image: nginx
       ```

   - **ConfigMap**：**ConfigMap** 用于存储非机密的配置信息，供 **Pod** 使用 <!--常用-->

     - 它可以将配置信息，例如应用配置文件、环境变量等，注入到容器中

       示例：

       ```yaml
       apiVersion: v1
       kind: ConfigMap
       metadata:
         name: example-config
       data:
         config-key: "some-config-value"  # 存储配置项的键值对
         another-key: "another-value"
       ```

     - 可以通过 **ConfigMap**，将应用的配置信息（如数据库地址、服务端口、API 密钥等）注入到 **Deployment** 中的 **Pod** 中，使应用配置可动态更新，而无需重新构建镜像

       - **方法 1：通过环境变量注入配置**

         在 **Deployment** 文件中，将 **ConfigMap** 的键值对作为环境变量注入到容器中：

         ```yaml
         apiVersion: apps/v1
         kind: Deployment
         metadata:
           name: example-deployment
         spec:
           replicas: 1
           selector:
             matchLabels:
               app: example
           template:
             metadata:
               labels:
                 app: example
             spec:
               containers:
                 - name: app-container
                   image: nginx
                   env:
                     - name: CONFIG_VALUE
                       valueFrom:
                         configMapKeyRef:
                           name: example-config  # ConfigMap 名称
                           key: config-key  # ConfigMap 中的特定键
         ```

         **解释**：

         - 在容器中定义一个名为 `CONFIG_VALUE` 的环境变量，并将 `example-config` **ConfigMap** 中 `config-key` 的值赋予该环境变量
         - 应用可以通过读取环境变量获取配置数据

       - **方法 2：将 ConfigMap 挂载为文件**

         如果 **ConfigMap** 中包含多个配置项，或者应用程序需要通过文件来读取配置，可以将 **ConfigMap** 挂载为卷

         ```yaml
         apiVersion: apps/v1
         kind: Deployment
         metadata:
           name: example-deployment
         spec:
           replicas: 1
           selector:
             matchLabels:
               app: example
           template:
             metadata:
               labels:
                 app: example
             spec:
               containers:
                 - name: app-container
                   image: nginx
                   volumeMounts:
                     - name: config-volume
                       mountPath: /etc/config  # 将 ConfigMap 挂载到容器中的路径
               volumes:
                 - name: config-volume
                   configMap:
                     name: example-config  # 引用 ConfigMap
         ```

         **解释**：

         - 将 `example-config` **ConfigMap** 作为卷挂载到容器中的 `/etc/config` 目录
         - ==挂载后，每个键将成为该目录中的一个文件，文件内容为键对应的值，应用可以直接读取文件获取配置数据==

   - **Service**：**Service** 为一组 **Pod** 提供统一的访问入口，支持负载均衡和服务发现

     - 它可以将流量分发到多个 **Pod** 上，确保应用程序的可用性

3. **metadata**：包含资源的元数据，比如名称、标签等

4. **spec**：定义资源的具体配置，比如容器的镜像、端口等

#### 2.4、YAML 文件与 Kubernetes 组件的关系

1. **Master 节点**：通过 **API Server** 接收和处理 **YAML** 文件中的配置，调度和管理资源
2. **Node 节点**：根据 **Master** 节点的指令，实际运行和管理 **Pod**
3. **Pod**：**YAML** 文件中定义的最小部署单元，包含一个或多个容器
4. **Service**：通过 **YAML** 文件定义，为一组 **Pod** 提供统一的访问入口

​              

​              

