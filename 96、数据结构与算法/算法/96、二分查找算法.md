## 二分查找算法

### 一、前言

**二分查找（Binary Search**）是在**有序**（或可单调判定）的搜索空间中，通过每次将**搜索区间折半**来快速定位目标的位置或答案的算法

其时间复杂度为 $O(\log n)$，远优于线性扫描的 $O(n)$

**主要应用场景：**

- **有序数组定位**：在升序/降序数组中查找某个值或其插入位置

- **边界问题**：寻找“第一个 ≥ 目标”、“最后一个 ≤ 目标”、“第一个满足条件的位置”等

- **答案空间单调**：虽然原数据未排序，但**判定函数**关于答案是单调的

  例如：

  - 最小可行值/最大可行值（最小化最大值、最大化最小值类问题）
  - 按难度/容量/时间上界做 “是否可行” 判定（如装载、排班、带宽分配）

**核心思想**

- 明确**搜索空间**（索引区间或答案区间）
- 设计**单调判定**：一个布尔函数 `check(x)`，使得当 `x` 增大（或减小）时，`check` 结果呈单调
- 每次取中点 `mid`，依据 `check(mid)` 真/假，**丢掉一半区间**
- 循环至区间收敛，返回边界或位置

**简单分类：**

- **闭区间 [l, r] **：适合精确查找、找“最后一个满足”
- **半开区间 [l, r) **：适合找“第一个满足”（lower_bound 风格），不易越界

**模板：**

-  **经典闭区间 [l, r] 二分**：用于精确等值查找

  ```javascript
  /**
   * 若找到返回索引；否则返回 -1
   */
  function binarySearchEqual(arr, target) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
      const mid = left + Math.floor((right - left) / 2);
      if (arr[mid] === target) return mid;
      if (arr[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return -1;
  }
  ```

- **半开区间 [left, right) 二分**：**lower_bound**

  > **定义**：在一个有序数组中，找到第一个 **大于等于 target** 的元素的索引
  >
  > - 如果数组中有元素等于 target，会返回最左边的那个
  >
  > - 如果所有元素都小于 target，则返回 `arr.length`（即“插入到最后”）

  ```javascript
  /**
   * 返回“第一个 >= target 的索引”，若不存在则返回 arr.length
   */
  function lowerBound(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
      const mid = left + Math.floor((right - left) / 2);
      if (arr[mid] >= target) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    return left;
  }
  ```

  - 关键点解析：
    -  `right` 起始值是 `arr.length`
    - 条件是 `arr[mid] >= target` → 往左收缩 `right = mid`
    - 最终 `left ` 会等于 `right` 并且停在第一个满足 `arr[left] >= target` 的位置

- **半开区间 [left, right) 二分**：**upper_bound**

  > **定义**：在一个有序数组中，找到第一个 **大于 target** 的元素的索引
  >
  > - 如果数组中有多个等于 target 的元素，它会越过这些元素，返回第一个大于 target 的位置
  > - 如果所有元素都小于等于 target，则返回 `arr.length`

  ```javascript
  /**
   * 返回“第一个 > target 的索引”，若不存在则返回 arr.length
   */
  function upperBound(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
      const mid = left + Math.floor((right - left) / 2);
      if (arr[mid] > target) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    return left;
  }
  ```

  - 关键点解析：
    -  `right` 起始值是 `arr.length`
    - 条件是 `arr[mid] > target` → 往左收缩
    - 最终 `left ` 会等于 `right` 并且停在第一个满足 `arr[left] > target` 的位置

  > `lowerBound` 和 `upperBound` 经常配合使用，用来**统计某个值在有序数组中出现的次数**，或者直接把所有等于 `target` 的元素所在区间拿出来
  >
  > 原理：
  >
  > - `lowerBound(arr, target)` 会返回 **第一个 `>= target` 的位置**（最左边的索引）
  > - `upperBound(arr, target)` 会返回 **第一个 `> target` 的位置**（最右边的索引的下一个）
  >
  > 因此 `count = upperBound(arr, target) - lowerBound(arr, target);` 就等于 **数组中 `target` 出现的次数**
  >
  > 另外，找“**最后一个 <= target**”的索引，可由 `upperBound - 1` 得到

### 二、二分查找算法通用模板

二分查找算法在在「**有序数组**」中搜索一个元素 `target`，返回该元素对应的索引，通常比较简单，但当需要查找「左侧边界」和「右侧」边界时，需要注意很多细节，下面是一个二分查找算法来查找「边界」的通用模板

```javascript
// 函数 f 是关于自变量 x 的单调函数
var f = function(x) {
    // ...
}

// 主函数，在 f(x) == target 的约束下求 x 的最值
var solution = function(nums, target) {
    if (nums.length === 0) return -1;
    // 问自己：自变量 x 的最小值是多少？
    var left = ...;
    // 问自己：自变量 x 的最大值是多少？
    var right = ... + 1;

    while (left < right) {
        var mid = left + Math.floor((right - left) / 2);
        if (f(mid) === target) {
            // 问自己：题目是求左边界还是右边界？
            // 求左边界时，需要缩减右侧区间，right = mid,
            // 求右边界时，需要缩减左侧区间，left = mid + 1
        } else if (f(mid) < target) {
            // 问自己：怎么让 f(x) 大一点？是缩减左侧区间还是右侧区间？
            // 若是缩减左侧区间，left = mid + 1
            // 若是缩减右侧区间，right = mid
        } else if (f(mid) > target) {
            // 问自己：怎么让 f(x) 小一点？是缩减左侧区间还是右侧区间？
            // 若是缩减左侧区间，left = mid + 1
            // 若是缩减右侧区间，right = mid
        }
    }
    return left;
};
```

### 三、经典问题

#### 3.1、爱吃香蕉的珂珂

**描述**：

珂珂喜欢吃香蕉，这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉，警卫已经离开了，将在 `h` 小时后回来

珂珂可以决定她吃香蕉的速度 `k`（单位：根/小时）每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉

返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）

**示例：**

> ```
> 输入：piles = [3,6,7,11], h = 8
> 输出：4
> ```

**题解：**

```javascript
/**
 * @param {number[]} piles
 * @param {number} h
 * @return {number}
 */

var minEatingSpeed = function(piles, h) {
  // 最大值是 piles 中的最大值，最小值是 1
  const max = piles.reduce((acc, current) => Math.max(acc, current))
  let left = 0
  let right = max + 1

  // 计算吃香蕉的总时间
  const fn = (mid) => {
    let hours = 0
    for(let i = 0; i < piles.length; i++) {
      hours += Math.ceil(piles[i]/mid)
    }
    return hours
  }

  while(left < right) {
    let mid = left + Math.floor((right - left)/2)
    // 如果总时间大于 h，则需要增加速度，缩减左侧区间
    if(fn(mid) > h) {
     left = mid + 1
    } else {
      // 如果总时间小于等于 h，则需要减少速度，缩减右侧区间
      right = mid
    }
  }

  return left
};
```

**解析：**

- `piles` 不是需要进行二分查找的「有序数组」，吃香蕉的速度区间才是需要进行二分查找的「有序数组」，最大值是 `piles` 中的最大值，最小值是 `1`
- 吃香蕉的总时间 `f(x)` 是随着吃香蕉的速度 `k` 单调递减的，速度越快，总时间越少
- 这道题是要求取最小速度，所以是求取「左侧边界」，需要缩减右侧边界
