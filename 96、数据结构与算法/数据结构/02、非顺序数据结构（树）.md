## 非顺序数据结构（树）

### 一、树的基本概念

区别于栈、队列、链表这些「顺序数据结构」，**树**是一种「**非顺序数据结构**」，它模拟了一种层级结构，现实生活中最常见的树的例子是家谱或者是公司的组织架构

![树](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171215.png)

**树**结构由**节点**（**node**）组成，每个节点包含数据和对其他节点的引用，这些引用通常称为“**子节点**”，在树的数据结构中，有几个关键概念：

1. **根节点（Root Node）**：树的顶部节点，是唯一没有父节点的节点
   - A 节点就是根节点
2. **子节点（Child Node）**：从某个节点向下延伸的节点
3. **父节点（Parent Node）**：指向子节点的节点
4. **叶节点（Leaf Node）**：没有子节点的节点，位于树的底部
   - H、I、G、K 节点就是叶节点
5. **节点的度（degree）**：节点的子节点的数量
   - G 节点的度是 0
   - E 节点的度是 3
6. **深度（Depth）**：从根节点到某个节点的路径长度
   - 例如：A 节点到 E 节点的深度是 2
7. **高度（Height）**：从某个节点到其任意叶子节点的最长路径的长度
   - 例如：D 节点的高度是 2，D—>G—>K这条路径

#### 1.1、二叉树

树的结构不限制子节点的数量，但有一种特殊类型的树，限制每个节点最多有两个子节点，这种树被称为**二叉树**

> **二叉树（Binary Tree）**：树中各个节点的度不大于 2 个的有序树，称为二叉树
>
> 通常树中的分支节点被称为 **「左子树」** 或 **「右子树」**。二叉树的分支具有左右次序，不能随意互换位置

![二叉树](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171342.png)

根据不同的规则和特性，二叉树可以进一步分类为以下几种类型：

- **满二叉树（Full Binary Tree）**：在满二叉树中，每个节点要么有两个子节点，要么没有子节点（叶节点）所有的非叶节点都恰有两个子节点

  ![满二叉树与非满二叉树](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20220218173007.png)

- **完全二叉树（Complete Binary Tree）**：在完全二叉树中，所有的层都被完全填满，除了最后一层，在最后一层，所有的节点都尽可能地向左对齐

  ![完全二叉树与非完全二叉树](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20220218174000.png)

- **二叉搜索树（Binary Search Tree, BST）**：一种特殊的二叉树，其中每个节点的左子树只包含比当前节点小的值，右子树只包含比当前节点大的值

  ![二叉搜索树](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171406.png)

#### 1.2、二叉树的存储结构

二叉树的存储结构分为两种：「**顺序存储结构**」和「**链式存储结构**」

- **顺序存储结构**：二叉树的顺序存储结构使用一维数组来存储二叉树中的节点

  - 节点存储位置采用完全二叉树的节点层次编号，按照层次从上至下，每一层从左至右的顺序依次存放二叉树的数据元素

  - 在进行顺序存储时，如果对应的二叉树节点不存在，则设置为「空节点」

    ![二叉树的顺序存储结构](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171423.png)

    从图中可以看出节点之间的逻辑关系：

    - 如果某二叉树节点（非叶子节点）的下标为 `𝑖`，那么其左孩子节点下标为 `2∗𝑖+1`，右孩子节点下标为 `2∗𝑖+2`
    - 如果某二叉树节点（非根节点）的下标为 `𝑖`，那么其父节点下标为 `(𝑖−1)/2`

- **链式存储结构**：二叉树采用链式存储结构时，每个链节点包含一个用于数据域 `𝑣𝑎𝑙`，存储节点信息；还包含两个指针域 `𝑙𝑒𝑓𝑡`和 `𝑟𝑖𝑔ℎ𝑡`，分别指向左右两个子节点，当左子点或者右子点不存在时，相应指针域值为空

  ![二叉链节点](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171434.png)

  ![二叉树的链式存储结构](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171446.png)

### 二、二叉搜索树的链式存储实现

接下来以二叉搜索树为研究对象，实现一个二叉搜索树

二叉搜索树（**BinarySearchTree**）基本框架

```javascript
const Compare = {
  LESS_THAN: -1,
  BIGGER_THAN: 1,
}

// 比较函数
function defaultCompare(a, b) {
  if (a === b) {
    return 0
  }
  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THANz
}

// 二叉搜索树的节点
class Node {
  constructor(key) {
    this.key = key
    this.left = null
    this.right = null
  }
}

// 二叉搜索树
class BinarySearchTree {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn // 用来比较节点值
    this.root = null // 根节点
  }
  
  //...
  
}
```

#### 2.1、插入节点

给定一个待插入元素 `num` ，为了保持二叉搜索树 “左子树 < 根节点 < 右子树” 的性质，插入操作流程如图所示

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/bst_insert-20250602173133101.png)

1. **查找插入位置**：与查找操作相似，从根节点出发，根据当前节点值和 `num` 的大小关系循环向下搜索，直到越过叶节点（遍历至 `None` ）时跳出循环
2. **在该位置插入节点**：初始化节点 `num` ，将该节点置于 `None` 的位置

代码实现

```javascript
  // 向树中插入一个新的键
  insert(key) {
    if (this.root === null) {
      this.root = new Node(key)
    } else {
      this.insertNode(this.root, key)
    }
  }

  /**
   * @param {Node} node 当前节点
   * @param {any} key 新节点的值
   * 向树中插入一个新的键, 新节点的值会和当前节点的值进行比较，
   * 如果新节点的值小于当前节点的值，则向左子树插入
   * 左子树为空，则直接插入，否则递归调用 insertNode 方法, 继续向左子树插入
   * 如果新节点的值大于当前节点的值，则向右子树插入
   * 右子树为空，则直接插入，否则递归调用 insertNode 方法, 继续向右子树插入
   */
  insertNode(node, key) {
    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
      // 如果新节点的值小于当前节点的值，则向左子树插入
      if (node.left === null) {
        node.left = new Node(key)
      } else {
        // 如果左子树不为空，则递归调用 insertNode 方法, 继续向左子树插入
        this.insertNode(node.left, key)
      }
    } else {
      // 如果新节点的值大于当前节点的值，则向右子树插入
      if (node.right === null) {
        node.right = new Node(key)
      } else {
        // 如果右子树不为空，则递归调用 insertNode 方法, 继续向右子树插入
        this.insertNode(node.right, key)
      }
    }
  }
```

#### 2.2、二叉树遍历

> **二叉树的遍历**：指的是从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次
>
> 在二叉树的一些实际问题中，经常需要按照一定顺序对二叉树中每个节点逐个进行访问一次，用以查找具有某一特点的节点或者全部节点，然后对这些满足要求的节点进行处理
>
> 这里所说的「访问」就是指对该节点进行某种操作，例如：依次输出节点的数据信息、统计满足某条件的节点总数等等

回顾二叉树递归定义，二叉树是由根节点和左子树、右子树构成的；因此，如果能依次遍历这 3 个部分，就可以遍历整个二叉树

如果利用「深度优先」（**DFS**）搜索的方式，并且限制先左子树后右子树的遍历顺序，总共有 3 种遍历方式：

- **前序遍历**
- **中序遍历** 
- **后序遍历**

而如果使用广度优先（**BFS**）搜索的方式，则可以按照层序方式（按照层次从上至下，每一层从左至右）对二叉树进行遍历，这种方式叫做 **「二叉树的层序遍历」**

##### 2.2.1、中序遍历

> 二叉树的中序遍历规则为：
>
> - 如果二叉树为空，则返回
> - 如果二叉树不为空，则：
>   1. 以中序遍历的方式遍历根节点的左子树
>   2. 访问根节点
>   3. 以中序遍历的方式遍历根节点的右子树

中序遍历过程是一个递归过程，在遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后访问根节点，最后再遍历子树根节点的右子树的顺序进行遍历

如下图所示，该二叉树的中序遍历顺序为：H−D−I−B−E−A−F−J−C−K−G

![二叉树的中序遍历](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171643.png)

```javascript
  /**
   * 中序遍历是一种以从最小到最大的顺序访问所有节点的遍历方式
   * 中序遍历的一种应用就是对树进行排序操作
   *
   * 中序遍历的顺序：
   * 1. 访问树的左子树
   * 2. 访问根节点
   * 3. 访问树的右子树
   *
   * @param {Function} callback 回调函数，用于处理每个节点的值, 回调函数接收一个参数，即节点的值
   * callback
   */
  inOrderTraverse(callback) {
    this.inOrderTraverseNode(this.root, callback)
  }

  inOrderTraverseNode(node, callback) {
    // 递归算法的「基本情况」是「节点为空」，此时递归调用结束
    if (node !== null) {
      // 递归访问左子树
      this.inOrderTraverseNode(node.left, callback)
      // 访问根节点
      callback(node.key)
      // 递归访问右子树
      this.inOrderTraverseNode(node.right, callback)
    }
  }
```

##### 2.2.2、前序遍历

> 二叉树的前序遍历规则为：
>
> - 如果二叉树为空，则返回
> - 如果二叉树不为空，则：
>   1. 访问根节点
>   2. 以前序遍历的方式遍历根节点的左子树
>   3. 以前序遍历的方式遍历根节点的右子树

前序遍历过程是一个递归过程，在遍历任何一棵子树时仍然是按照先访问根节点，然后遍历子树根节点的左子树，最后再遍历子树根节点的右子树的顺序进行遍历。

如下图所示，该二叉树的前序遍历顺序为：A−B−D−H−I−E−C−F−J−G−K

![二叉树的前序遍历](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171628.png)

```javascript
  /**
   * 前序遍历的顺序：
   * 1. 访问根节点
   * 2. 访问树的左子树
   * 3. 访问树的右子树
   *
   * @param {Function} callback 回调函数，用于处理每个节点的值, 回调函数接收一个参数，即节点的值
   * callback
   */
  preOrderTraverse(callback) {
    this.preOrderTraverseNode(this.root, callback)
  }

  preOrderTraverseNode(node, callback) {
    if (node !== null) {
      // 访问根节点
      callback(node.key)
      // 递归访问左子树
      this.preOrderTraverseNode(node.left, callback)
      // 递归访问右子树
      this.preOrderTraverseNode(node.right, callback)
    }
  }
```

##### 2.2.3、后序遍历

> 二叉树的后序遍历规则为：
>
> - 如果二叉树为空，则返回
> - 如果二叉树不为空，则：
>   1. 以后序遍历的方式遍历根节点的左子树
>   2. 以后序遍历的方式遍历根节点的右子树
>   3. 访问根节点

后序遍历过程也是一个递归过程，在遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后遍历子树根节点的右子树，最后再访问根节点的顺序进行遍历

如下图所示，该二叉树的后序遍历顺序为：H−I−D−E−B−J−F−K−G−C−A

![二叉树的后序遍历](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511171658.png)

```javascript
  /**
   * 后序遍历的顺序：
   * 1. 访问树的左子树
   * 2. 访问树的右子树
   * 3. 访问根节点
   *
   * @param {Function} callback 回调函数，用于处理每个节点的值, 回调函数接收一个参数，即节点的值
   * callback
   */
  postOrderTraverse(callback) {
    this.postOrderTraverseNode(this.root, callback)
  }

  postOrderTraverseNode(node, callback) {
    if (node !== null) {
      // 递归访问左子树
      this.postOrderTraverseNode(node.left, callback)
      // 递归访问右子树
      this.postOrderTraverseNode(node.right, callback)
      // 访问根节点
      callback(node.key)
    }
  }
```

##### 2.2.4、层序遍历

> 二叉树的层序遍历规则为：
>
> - 如果二叉树为空，则返回。
> - 如果二叉树不为空，则：
>   1. 先依次访问二叉树第 11 层的节点。
>   2. 然后依次访问二叉树第 22 层的节点。
>   3. ……
>   4. 依次下去，最后依次访问二叉树最下面一层的节点。

从二叉树的层序遍历规则可以看出：遍历过程是一个广度优先搜索过程，在遍历的时候是按照第 1 层、第 2 层、…… 最后一层依次遍历的，而同一层节点则是按照从左至右的顺序依次访问的。

如下图所示，该二叉树的后序遍历顺序为：A−B−C−D−E−F−G−H−I−J−K

![二叉树的层序遍历](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/20240511175431.png)

```javascript
 // ———————————————— 层序遍历 ————————————————

  // 层序遍历是一种以从上到下、从左到右的顺序访问所有节点的遍历方式
  // 层序遍历属于「广度优先」遍历，也称「广度优先搜索」（BFS），它体现了一种「逐层推进」的遍历方式
  // 层序遍历的顺序：
  // 1. 访问根节点
  // 2. 访问树的左子树
  // 3. 访问树的右子树
  // 4. 访问树的左子树的左子树
  // 5. 访问树的左子树的右子树
  // 6. 访问树的右子树的左子树
  // 7. 访问树的右子树的右子树

  /**
   * 层序遍历
   *
   * @param {Function} callback 回调函数，用于处理每个节点的值, 回调函数接收一个参数，即节点的值
   * callback
   */
  levelOrderTraverse(callback) {
    this.levelOrderTraverseNode(this.root, callback)
  }

  levelOrderTraverseNode(node, callback) {
    if (node !== null) {
      // 初始化一个队列
      const queue = [node]
      // 初始化一个列表，用于保存遍历序列
      const list = []
      let depth = 0 // 当前层级
      while (queue.length > 0) {
        // 从队列中取出一个节点
        const current = queue.shift()
        // 保存节点值
        list.push(current.key)
        // 执行回调函数
        callback(current.key, depth)
        // 如果当前节点有左子树，则将左子树加入队列
        if (current.left !== null) {
          queue.push(current.left)
        }
        // 如果当前节点有右子树，则将右子树加入队列
        if (current.right !== null) {
          queue.push(current.right)
        }
        depth++
      }
      return list
    } else {
      return 'The tree is empty'
    }
  }
```

##### 2.2.5、查找

```javascript

  // ———————————————— 搜索树中的值 ————————————————

  // 搜索树中最常用的操作之一就是搜索树中的最小值和最大值
  // 在二叉搜索树中，最小值在树的最左边，最大值在树的最右边
  // 因此，搜索树中的最小值和最大值的搜索方式非常相似

  // 搜索树中的最小值
  min() {
    return this.minNode(this.root)
  }

  minNode(node) {
    let current = node
    while (current !== null && current.left !== null) {
      current = current.left
    }
    return current
  }

  // 搜索树中的最大值
  max() {
    return this.maxNode(this.root)
  }

  maxNode(node) {
    let current = node
    while (current !== null && current.right !== null) {
      current = current.right
    }
    return current
  }

  /**
   * 搜索树中的值
   *
   * @param {any} key 要搜索的值
   * @returns {boolean} 如果找到该值，则返回 true，否则返回 false
   */
  search(key) {
    return this.searchNode(this.root, key)
  }

  searchNode(node, key) {
    if (node === null) {
      return false
    }
    // 如果当前节点的值大于要搜索的值，则向左子树搜索
    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
      return this.searchNode(node.left, key)
    }
    // 如果当前节点的值小于要搜索的值，则向右子树搜索
    if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {
      return this.searchNode(node.right, key)
    }
  }
```

##### 2.2.6、删除

```javascript
 /**
   * 删除树中的一个值
   *
   * @param {any} key 要删除的值
   */
  remove(key) {
    this.root = this.removeNode(this.root, key)
  }

  /**
   * 删除树中的一个值
   *
   * @param {Node} node 当前节点
   * @param {any} key 要删除的值
   * @returns {Node} 返回删除后的树
   */
  removeNode(node, key) {
    if (node === null) {
      return null
    }

    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
      // 如果当前节点的值大于要删除的值，则向左子树搜索
      node.left = this.removeNode(node.left, key)
      return node
    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {
      // 如果当前节点的值小于要删除的值，则向右子树搜索
      node.right = this.removeNode(node.right, key)
      return node
    } else {
      // 如果当前节点的值等于要搜索的值，则删除该节点
      if (node.left === null && node.right === null) {
        node = null
        return node
      }

      if (node.left === null) {
        // 如果当前节点的左子树为空，则将当前节点的右子树赋值给当前节点，从而删除当前节点
        node = node.right
        return node
      } else if (node.right === null) {
        // 如果当前节点的右子树为空，则将当前节点的左子树赋值给当前节点，从而删除当前节点
        node = node.left
        return node
      }

      // 如果当前节点的左右子树都不为空，则将当前节点的右子树的最小值赋值给当前节点
      // 1. 找到当前节点的右子树的最小值
      const aux = this.minNode(node.right)
      // 2. 将当前节点的右子树的最小值赋值给当前节点
      node.key = aux.key
      // 3. 删除当前节点的右子树的最小值
      node.right = this.removeNode(node.right, aux.key)
      // 4. 返回当前节点
      return node
    }
  }
```

### 三、DFS 和 BFS 各自适用的场景

**DFS**（深度优先搜索）与 **BFS**（广度优先搜索）在图或树的遍历中用途不同，是因为它们**搜索策略的本质不同**

#### 3.1、DFS 更适合“找所有路径”

**DFS** 会**深入到底再回溯**，可以自然地构建出从起点到终点的整条路径，因此适合用来枚举“所有可能的路径”

**举例：在二叉搜索树中，找从根节点到所有叶子节点的路径**

```js
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = this.right = null;
  }
}

function findAllPaths(root) {
  const res = [];

  function dfs(node, path) {
    if (!node) return;

    path.push(node.val);

    if (!node.left && !node.right) {
      res.push([...path]); // 到达叶子节点，保存路径
    } else {
      dfs(node.left, path);
      dfs(node.right, path);
    }

    path.pop(); // 回溯
  }

  dfs(root, []);
  return res;
}
```

**DFS** 在这类问题中非常高效，因为它每次都沿着一条路径走到底，再回头探索其他路径，天然可以组合成“所有路径”的集合

#### 3.2、BFS 更适合“找最短路径”

**BFS** 是**层级逐层扩展**，最早到达目标的一定是最短路径（因为再往后层数只会增加），一旦找到目标，无需继续遍历

**举例：在二叉搜索树中找从根节点到目标值的“最短路径”**

```js
function findShortestPath(root, target) {
  if (!root) return [];

  const queue = [[root, [root.val]]];

  while (queue.length > 0) {
    const [node, path] = queue.shift();

    if (node.val === target) {
      return path;
    }

    if (node.left) {
      queue.push([node.left, [...path, node.left.val]]);
    }

    if (node.right) {
      queue.push([node.right, [...path, node.right.val]]);
    }
  }

  return []; // 未找到目标
}
```

**BFS** 会**优先访问离根最近的节点**，因此一旦遇到目标值，当前路径就是最短的；而 **DFS** 可能先走很深的分支，效率反而低
