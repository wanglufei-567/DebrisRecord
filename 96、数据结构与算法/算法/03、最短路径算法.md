## 最短路径算法

### 一、前言

**最短路径算法**是一种解决从一个节点到另一个节点的最短路径问题的算法

假设有下面这样一个**「图」**结构

```js 
图数据结构示意图：
   A ────────── B ────────── E ────────── I
   │╲           │
   │ ╲          │
   │  ╲         F
   │   ╲
   C────D────────H
   │   ╱
   │  ╱
   │ ╱
   G╱
```

从顶点 A 到顶点 H 所有不重复访问顶点路径有以下几种：

- A -> D -> H
- A -> C -> D -> H
- A -> C -> G -> D -> H

其中路径 A -> D -> H 所经过的边数量最少，为最短路径

最短路径算法就是为了找到这个最少边的路径

### 二、具体实现

#### 2.1、图数据结构

准备一个图数据结构的实现

```javascript
/**
 * 图的实现
 */
class Graph {
  constructor(isDirected = false) {
    this.isDirected = isDirected // 是否为有向图
    this.vertices = [] // 顶点列表
    this.adjList = new Map() // 邻接表
  }

  /**
   * 添加顶点
   * @param {string} vertex 顶点
   */
  addVertex(vertex) {
    // 如果顶点不存在，则添加顶点
    if (!this.vertices.includes(vertex)) {
      // 添加顶点
      this.vertices.push(vertex)
      // 添加邻接表
      this.adjList.set(vertex, [])
    }
  }

  /**
   * 添加边
   * @param {string} vertex1 顶点1
   * @param {string} vertex2 顶点2
   * 两个顶点之间建立连接，创建一条边
   */
  addEdge(vertex1, vertex2) {
    // 如果顶点不存在，则添加顶点
    if (!this.adjList.has(vertex1)) {
      this.addVertex(vertex1)
    }
    // 如果顶点不存在，则添加顶点
    if (!this.adjList.has(vertex2)) {
      this.addVertex(vertex2)
    }
    // 添加边
    this.adjList.get(vertex1).push(vertex2)
    // 如果是无向图，则添加反向边
    if (!this.isDirected) {
      this.adjList.get(vertex2).push(vertex1)
    }
  }

  /**
   * 获取邻接表
   * @returns {string[]} 邻接表
   */
  getAdjList() {
    return this.adjList
  }

  /**
   * 获取顶点
   * @returns {string[]} 顶点
   */
  getVertices() {
    return this.vertices
    }

  /**
   * 获取图的字符串表示
   * @returns {string} 图的字符串表示
   */
  toString() {
    let s = ''
    for (let i = 0; i < this.vertices.length; i++) {
      s += `${this.vertices[i]} -> ${this.adjList.get(this.vertices[i]).join(' ')}\n`
    }
    return s
  }
}
```

创建一个**「图」**

```javascript
/ 使用示例
const graph = new Graph()
const myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
for (let i = 0; i < myVertices.length; i++) {
  graph.addVertex(myVertices[i])
}
graph.addEdge('A', 'B')
graph.addEdge('A', 'C')
graph.addEdge('A', 'D')
graph.addEdge('C', 'D')
graph.addEdge('C', 'G')
graph.addEdge('D', 'G')
graph.addEdge('D', 'H')
graph.addEdge('B', 'E')
graph.addEdge('B', 'F')
graph.addEdge('E', 'I')
console.log(graph.toString())
```

创建出来的「图」的示意图

```js 
图数据结构示意图：
   A ────────── B ────────── E ────────── I
   │╲           │
   │ ╲          │
   │  ╲         F
   │   ╲
   C────D────────H
   │   ╱
   │  ╱
   │ ╱
   G╱
```

#### 2.3、三色系统

三色系统用于标注节点的访问状态

```javascript
/**
 * 颜色常量
 * 用于标注已经被访问过的顶点的状态
 *
 * 白色：未访问
 * 灰色：被访问过，但未探索过
 * 黑色：被访问过且被探索过
 */
const Colors = {
  WHITE: 0, // 未访问
  GREY: 1, // 被访问过，但未探索过
  BLACK: 2, // 被访问过且被探索过
}

/**
 * 初始化颜色
 * @param {string[]} vertices 顶点列表
 * @returns {Object} 颜色对象
 * 为每个顶点初始化颜色
 */
const initializeColor = (vertices) => {
  const color = {}
  for (let i = 0; i < vertices.length; i++) {
    color[vertices[i]] = Colors.WHITE
  }
  return color
}
```

#### 3.3、利用广度优先搜索实现最短路径算法

```javascript
/**
 * 广度优先搜索实现最短路径算法
 * @param {Graph} graph 图
 * @param {string} startVertex 起始顶点
 * @returns {Object} 每个顶点到起始顶点的距离和前溯点数组
 */
const BFS = (graph, startVertex) => {
  // 获取顶点和邻接表
  const vertices = graph.getVertices()
  const adjList = graph.getAdjList()
  // 初始化颜色
  const color = initializeColor(vertices)
  // 创建队列
  const queue = []
  // 距离
  const distances = {}
  // 前溯点
  const predecessors = {}

  // 将起始顶点加入队列
  queue.push(startVertex)

  // 初始化距离和前溯点
  for (let i = 0; i < vertices.length; i++) {
    // 每个顶点到达起始顶点的初始距离都设置为0
    distances[vertices[i]] = 0
    // 每个顶点的前溯点都设置为null
    predecessors[vertices[i]] = null
  }

  // 遍历队列
  while (queue.length > 0) {
    // 从队列中移除第一个顶点
    const u = queue.shift()
    // 获取邻接顶点
    const neighbors = adjList.get(u)
    // 标记为灰色
    color[u] = Colors.GREY
    // 遍历邻接顶点
    for (let i = 0; i < neighbors.length; i++) {
      const w = neighbors[i]
      if (color[w] === Colors.WHITE) {
        // 标记为灰色
        color[w] = Colors.GREY
        /**
         * 给当前正在访问的顶点设置「到起始顶点的距离」
         * 只需在前溯节点基础上 + 1 即可
         * 因为从起始顶点开始探索
         * 先访问的是起始顶点的邻接顶点（它的前溯节点就是起始节点），所以距离为 1
         * 后面再访问邻接顶点的邻接顶点（此时它的前溯节点就是当前正在访问的顶点），所以距离为 2
         * 以此类推
         * 需要注意的是，得益于三色系统的设计，每个顶点只会被访问一次，所以不会出现重复计算距离的情况
         */
        distances[w] = distances[u] + 1
        /**
         * 设置前溯节点，后续用于回溯路径
         */
        predecessors[w] = u
        // 将当前顶点的邻接顶点依次加入队列
        queue.push(w)
      }
    }
    // 这时当前顶点的所有邻接顶点都已经被访问过，可以将当前顶点标记为黑色，表示已经完全探索过
    color[u] = Colors.BLACK
  }
  return { distances, predecessors }
}
```

这个算法的核心思想是：

 * 从起始顶点开始，依次访问它的所有邻接顶点
 * 同时记录每个顶点到起始顶点的距离和前溯点
 * 然后依次访问这些邻接顶点的所有邻接顶点
 * 以此类推
 * 直到访问完所有顶点为止

因为广度优先搜索的特性，每个顶点只会被访问一次，所以不会出现重复计算距离的情况，也就是说每个顶点到起始顶点的距离都是最短的，这就是最短路径算法的核心思想

通过前溯点数组，还可以回溯出从起始顶点到指定顶点的完整最短路径

使用示例：

```javascript
const shortestPathA = BFS(graph, myVertices[0])
console.log(shortestPathA)
```

输出结果：

```javascript
/**
 * {
 *   distances: { A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2, I: 3 },
 *   predecessors: { A: null, B: 'A', C: 'A', D: 'A', E: 'B', F: 'B', G: 'C', H: 'D', I: 'E' }
 * }
 */
```

从结果中可以看出：

 * 顶点 A 距离 B、C、D 的距离为 1
 * 顶点 A 距离 E、F、G、H 的距离为 2
 * 顶点 A 距离 I 的距离为 3

符合预期，结果正确

#### 2.4、回溯路径

通过前溯点数组，可以回溯出从起始顶点到其他顶点的最短路径

```javascript
/**
 * @param {string} startVertex 起始顶点
 * @param {string} endVertex 结束顶点
 * @param {Object} predecessors 前溯点数组
 */
const path = (startVertex, endVertex, predecessors) => {
  const path = []
  let vertex = endVertex
  // 从结束顶点开始，回溯到起始顶点
  while (vertex !== startVertex) {
    // 将当前顶点加入路径
    path.push(vertex)
    // 将当前顶点的前溯节点加入路径
    vertex = predecessors[vertex]
  }
  // 将起始顶点加入路径
  path.push(startVertex)
  // 将路径反转并返回
  return path.reverse().join(' -> ')
}
```

使用示例：

```javascript
const shortestPathB = path(myVertices[0], myVertices[7], shortestPathA.predecessors)
console.log(shortestPathB)
```

输出结果： A -> D -> H，符合预期，结果正确

