## 堆排序算法

### 一、前言

**「堆排序」**是一种基于「堆」数据结构的比较排序算法

**核心思想：**

1. 将待排序数组构建成一个最大堆（或最小堆）
2. ==**将堆顶元素（最大值）与末尾元素交换**== 
3. **==重新调整剩余元素为堆结构==**
4. 重复「步骤 2」和「步骤 3」，直到所有元素排序完成 <!--重复步骤2和3 是精髓，不断的将堆顶的值提取出来-->

**特点：**

* 不稳定排序
* 原地排序

### 二、对一组无序数据进行排序

### 2.1、堆化方法

**堆化（heapify）**是指将一组无序的数据调整成堆结构（满足堆的性质）的过程

```javascript
// 交换元素位置的方法
function swap(array, idx1, idx2) {
  [array[idx1], array[idx2]] = [array[idx2], array[idx1]] 
}
```

```javascript

/**
 * 堆化操作
 * 确保 以某个节点为根 的子树满足堆的性质
 *
 * @param {Array} array - 要堆化的数组
 * @param {number} index - 当前要堆化的节点索引
 * @param {number} heapSize - 堆的大小
 * @param {Function} compareFn - 比较函数
 */
function heapify(array, index, heapSize, compareFn) {
  let element = index
  
  // 当前节点的左右子节点的索引
  const left = 2 * index + 1
  const right = 2 * index + 2
  
  if ( left < heapSize && compareFn(array[element], array[left])) {
    element = left
  }
  
  if ( right < heapSize && compareFn(array[element], array[right])) {
    element = right
  }
  
  if (element !== index) {
    swap(array, index, element)
    // 交换之后的节点要继续执行堆化
    heapify(array, element, heapSize, compareFn)
  }
}
```

执行过程：

* 以当前节点作为根节点，根据当前节点的索引找到左右子节点的索引
* 找出当前节点、左子节点、右子节点中的最大（小）值
* 如果最大（小）值不是当前节点，则与最大（小）值交换位置
* 递归地对交换后的位置继续执行堆化

**示例：**

输入数组：[4, 10, 3, 5, 1]

初始状态：

```markdown
        4
      /   \
     10    3
    / \
   5   1
```

执行 `heapify(0)` 后：

```markdown
        10
      /    \
     4      3
    / \
   5   1
```

#### 2.2、构堆

将一个无序数组整体堆化

```javascript
/**
 * 构建最大堆
 * 将一个数组构建为最大堆
 * @param {Array} array - 要构建最大堆的数组
 * @param {Function} compareFn - 比较函数
 */
function buildMaxHeap(array, compareFn) {
/**
 * 为什么从 Math.floor(array.length / 2) 开始？
 *
 * 最后一个非叶子节点的索引是 Math.floor(array.length/2) - 1
 * 但从 Math.floor(array.length/2) 开始遍历更简洁
 *
 * 因为：
 * 1、虽然多遍历了一个叶子节点，但 heapify 会立即返回
 * 2、不会影响最终结果，反而让代码更简洁
 */
  for (let i = Math.floor(array.length / 2); i >= 0; i--) {
    heapify(array, i, array.length, compareFn)
  }
}
```

构建最大堆过程：

* 从「**最后一个非叶子节点**」开始，执行堆化操作 

     <!--这个很重要，因为叶子节点没有子节点，不需要进行堆化-->

* 重复此过程直到根节点

    * ⚠️注意：构建最大堆后，数组并**不是完全有序的**
         * 只保证根节点是最大的
         * 只保证每个父节点大于其子节点
         * ==不保证同层节点之间的大小关系==
         * 要得到完全有序的数组，需要继续执行堆排序算法

**示例：**

输入数组：[4, 10, 3, 5, 1]

初始状态：

```markdown
       4
     /   \
     10    3
    / \
   5   1
```

执行过程：

* i = 2: 堆化节点 3（叶子节点，无操作）
* i = 1: 堆化节点 10 及其子树
* i = 0: 堆化节点 4 及其子树

最终结果：

```javascript
        10
      /    \
     5      3
    / \
   4   1
```

数组：[10, 5, 3, 4, 1]  <!--此时数组满足堆的性质，但未完全有序-->

### 2.3、堆排序

```javascript
/**
 * 堆排序算法
 * 将数组按照升序排列
 * @param {Array} array - 要排序的数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 排序后的数组
 */
function heapSort(array, compareFn = defaultCompare) {
  let heapSize = array.length

  // 构建最大堆，但未完全有序
  buildMaxHeap(array, compareFn)

  // 堆排序
  while (heapSize > 1) {
    heapSize--
    // 交换堆顶元素和堆尾元素，让最大的元素在最后，后续继续堆化剩余元素，继续找到最大的元素
    swap(array, 0, heapSize)
    
    // 堆化剩余元素，注意⚠️ 堆大小变了
    heapify(array, 0, heapSize, compareFn)
  }
  return array
}
```

堆排序过程：

1. 构建最大堆
    * 此时结果数组满足堆的性质，但并==不是完全有序的==
    * 只保证根节点是最大的，每个父节点大于其子节点
    * 不保证同层节点之间的大小关系
2. 堆排序
    * ==将根节点（最大值）与末尾元素交换== <!--这个是精髓-->
    * 对剩余部分重新堆化
    * 重复此过程直到所有元素都处理完

示例：

输入数组：[4, 10, 3, 5, 1]

第一步：构建最大堆

```markdown
        10
      /    \
     5      3
    / \
   4   1
```

数组：[10, 5, 3, 4, 1]   <!--此时数组满足堆的性质，但未完全有序-->

第二步：堆排序

1. 交换 10 和 1，堆化 [1, 5, 3, 4]
2. 交换 5 和 4，堆化 [4, 1, 3]
3. 交换 4 和 3，堆化 [3, 1]
4. 交换 3 和 1，完成

最终结果：[1, 3, 4, 5, 10]

### 三、对二维数组的元素进行排序并找到第 K 个元素

**描述：**给定一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素，请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素

**示例：**

> ```markdown
> 输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
> 输出：13
> 解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
> ```
>

**思路：**

- 二维数组中，因为每行每列元素是升序排列的，所以可以按列或者按行组成 `n` 个升序链表
- 那么这道题就变成了合并多个升序链表为一个，再找到第 K 个元素
- 这种将多个有序链表（或数组）合并为一个有序链表（或数组）的算法叫做「多路归并」

先实现一个最小堆的类

```javascript
// PriorityQueue 支持自定义比较器
class PriorityQueue {
    constructor(comparator = (a, b) => a - b) {
        this._heap = [];
        this._comparator = comparator;
    }
    enqueue(val) {
        this._heap.push(val);
        this._siftUp();
    }
    dequeue() {
        const top = this._heap[0];
        const last = this._heap.pop();
        if (this._heap.length) {
            this._heap[0] = last;
            this._siftDown();
        }
        return top;
    }
    peek() {
        return this._heap[0];
    }
    size() {
        return this._heap.length;
    }
    isEmpty() {
        return this._heap.length === 0;
    }
    _siftUp() {
        let idx = this._heap.length - 1;
        const item = this._heap[idx];
        while (idx > 0) {
            const parent = Math.floor((idx - 1) / 2);
            if (this._comparator(item, this._heap[parent]) >= 0) break;
            this._heap[idx] = this._heap[parent];
            idx = parent;
        }
        this._heap[idx] = item;
    }
    _siftDown() {
        let idx = 0;
        const length = this._heap.length;
        const item = this._heap[0];
        while (true) {
            let left = 2 * idx + 1;
            let right = 2 * idx + 2;
            let smallest = idx;
            if (left < length && this._comparator(this._heap[left], this._heap[smallest]) < 0) {
                smallest = left;
            }
            if (right < length && this._comparator(this._heap[right], this._heap[smallest]) < 0) {
                smallest = right;
            }
            if (smallest === idx) break;
            this._heap[idx] = this._heap[smallest];
            idx = smallest;
        }
        this._heap[idx] = item;
    }
}

```

利用最小堆找到二维数组升序排序之后的第 K 个元素

```javascript
// 模板：将 [元素值, 行号, 列号] 作为节点入堆
function exampleKthSmallest(matrix, k) {
    const n = matrix.length;
  
    // 小顶堆，按元素值排序
    const pq = new PriorityQueue((a, b) => a[0] - b[0]);
  
    // 初始化：每一行的第一个元素入堆
    for (let i = 0; i < n; i++) {
      // 将元素的行号和列号一起入堆
        pq.enqueue([matrix[i][0], i, 0]);
    }
  
    let res = 0;
    for (let cnt = 0; cnt < k; cnt++) {
        const [val, row, col] = pq.dequeue();
        res = val;
        // 如果该行还有下一个元素，则入堆
        if (col + 1 < n) {
            // 将当前元素的下一个元素入堆
            pq.enqueue([matrix[row][col + 1], row, col + 1]);
        }
    }
    return res;
}
```

**解析：**上面的实现中使用到了一个策略叫做：「多元组节点入堆」

- 其核心思想是：将「元素值」和「相关索引」等信息打包成一个元组（数组/对象），作为一个整体入堆，以便后续弹出时能追踪其来源和扩展下一个候选节点
