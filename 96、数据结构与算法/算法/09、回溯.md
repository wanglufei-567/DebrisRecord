## 回溯

### 一、前言

**「回溯」**是一种**算法思想**，用于在**约束条件下**通过**深度优先搜索**系统性地**枚举解**空间，并在**失败时撤销选择**

**「回溯」**本质上做的事情很简单：

> **一条路一条路地试，走不通就退回到上一个岔路口，换一条路继续试**

它关心的不是“算得快不快”，而是：1、有没有被漏掉的可能；2、能不能在发现不可能时尽早停下来

<!--其实回溯算法和 DFS 算法基本可以认为是同一种算法，只不过多了些回退操作-->

#### 1.1、回溯算法的特点

1. 本质是“带回退的尝试”

   - 回溯允许：

     - 先假设一个选择是对的
     - 往下继续推
     - 一旦发现不对，**撤销这个选择**，当作没发生过

       <!--这是回溯区别于很多算法的根本点-->

2.  天然是**深度优先**的

   - 回溯通常沿着一条路径一直走到不能再走为止，再回退：

     - 不是同时尝试所有可能

     - 而是一次只专注一条路径

     <!--这也是回溯代码几乎总是用递归实现的原因-->

3. 会“提前放弃”不可能成功的尝试

   - 如果当前状态已经违反规则，回溯会直接放弃这一整条分支：

     - 不再继续深入

     - 不再生成后续选择

     <!--这种行为通常被称为剪枝，它决定了回溯在实际中是否可用-->

#### 1.2、与其他相近算法思想的区分

| 思想     | 直观区别                                       |
| -------- | ---------------------------------------------- |
| **DFS**  | **DFS** 只是遍历；回溯会在遍历中撤销选择并剪枝 |
| 贪心     | 贪心选了就不回头；回溯随时可以回头             |
| 动态规划 | 动态规划复用结果；回溯反复尝试不同选择         |
| 分治     | 分治拆成独立子问题；回溯是在同一问题中试探选择 |

#### 1.3、代码实现

抽象地说，解决一个回溯问题，实际上就是**遍历一棵决策树的过程**，树的每个叶子节点存放着一个合法答案，把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案

站在回溯树的一个节点上，需要思考 3 个问题：

1、路径：也就是已经做出的选择

2、选择列表：也就是当前可以做的选择

3、结束条件：也就是到达决策树底层，无法再做选择的条件

```javascript
const result = []
function backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径) // 记录结果
        return

    for 选择 in 选择列表:
        if 当前选择不合法:
            continue   // 剪枝

        选择该项
        backtrack(进入下一状态)
        撤销该选择  // 回溯
```

其核心就是 `for` 循环里面的递归，在「递」的阶段「做选择」，在「归」的阶段「撤销选择」

### 二、全排列

**描述：**给定一个不含重复数字的数组 `nums` ，返回其所有可能的全排列，可以 **按任意顺序** 返回答案

**示例：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**题解：**

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const res = []
    // 记录路径
    const track = []
    // 记录元素是否被使用过
    const used = Array(nums.length).fill(false)

    function backtrack(nums, track, used) {
      // 结束条件，选择列表中所有元素都已经被选择过了
      if(track.length === nums.length) {
        res.push([...track])
        return
      }

      for(let i = 0; i < nums.length; i++) {
        // 如果当前元素已经被选择过了，则跳过
        if(used[i]) {
          continue
        }
        // 选择元素，将元素记录到路径中，同时标记该元素已经被使用过了
        track.push(nums[i])
        used[i] = true
        // 继续往下递归
        backtrack(nums, track, used)
        // 取消选择，释放元素
        track.pop()
        used[i] = false
      }
    }

    backtrack(nums, track, used)

    return res
}
```

**解析：**

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/3-20260101203931809.jpg" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/5.jpg" alt="img" style="zoom:50%;" />

- 核心逻辑在 `for` 循环中
  - 遍历「选择列表」`nums`，选择列表中有多少选项就有几颗决策树
  - 从根节点出发，将根节点添加到本次的「路径」`track` 中
  - 进入下一个节点时，仍然是 `for` 循环全量遍历「选择列表」，只不过要检查元素是否已经被选择过了
  - 递归到满足结束条件时，记录结果
    - 「递」阶段结束，开始「归」阶段，需要取消选择，释放元素
    - 一直到根节点，剩余根节点重复上述步骤
