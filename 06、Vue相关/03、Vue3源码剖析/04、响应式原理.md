

## Vue3源码剖析（四）— Vue3响应式原理

### 一、前言

**Vue3** 中的 ==**reactivity** 模块是其响应式系统的核心模块==，它允许开发者使用声明式的语法来描述状态的变化，从而在状态发生变化时自动更新相关的组件

与 **Vue 2.x** 中的响应式系统相比，**Vue3**中的**reactivity** 模块引入了一些重大改进，包括：

1. **Proxy 对象代替了 Object.defineProperty:**

   ==Vue 3 中使用 Proxy 对象来实现响应式，而不再使用 Object.defineProperty==。这使得 Vue 3 的响应式系统更加高效、灵活、并且能够支持更多种类型的数据。

2. **优化的依赖追踪：**

   ==Vue3中使用了一种新的依赖追踪算法，可以更准确地追踪状态的依赖关系，从而**避免了不必要的重新渲染**==

3. **新的 ref 和 reactive 函数：**

   Vue 3 中引入了新的 `ref` 和 `reactive` 函数，用于创建响应式的数据对象。相比 Vue 2.x 中的 data 选项，`ref` 和 `reactive` 函数更加直观和易用。

4. **新的 computed 和 watch 函数:**

   Vue 3 中重新设计了 `computed` 和 `watch` 函数，使得它们更加直观和易用

   - ==`computed` 函数使用了缓存机制，**只有在其依赖的数据发生变化时才会重新计算**==

   - ==`watch` 函数则可以监听任意数据的变化，并在变化时执行指定的回调函数==

### 二、Vue3响应式模块reactivity的实现

### 2.1、reactivity模块基本使用

**reactivity**模块有两个重要的方法：

- ==**reactive：创建响应式数据**==
  - `reactive`方法会将目标对象变成`proxy`对象
- ==**effect：副作用函数**==
  - `effect`中在使用`reactive`对象时会进行**==依赖收集==**，稍后属性变化时会==重新执行`effect`函数==

看下使用示例👇

```html
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: 'zf', age: 13, address: { num: 30 }, flag: true }

    // reactive() 会对属性进行劫持 proxy， 监听用户的获取操作和设置操作
    // reactive() 只能传入对象， 因为proxy 只支持对象格式
    const state = reactive(obj);

    // effect 函数默认会执行一次， 后续数据变化了会重新执行effect函数
    effect(() => {
      app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
    })

    setTimeout(() => {
      state.age++
    }, 1000)
  </script>
</body>
```

### 2.2、reactive方法实现

#### 2.2.1、Proxy和Reflect中的receiver

- **Reflect**

  `Reflect.get(target, name, receiver)`

  如果`name`属性设置了`getter`、`setter`方法，则`getter`、`setter`方法中的`this`指向`receiver`

  看下面👇这个例子

  ```js
  var target = {
    c: 1,
    get a() { return this.c }
  }
  
  Reflect.get(target, 'a', { c: 2 }) // 2
  ```

- **Proxy**

  `Proxy`中的`get(target, propKey, receiver)`与`set(target, propKey, value, receiver)`

   `receiver` 指向 `proxy` 本身或者继承它的对象

下面是`Proxy`和`Reflect`结合使用的例子👇

`target`对象

```js
var target = {
  get a() {
    return this.b
  }
}
```

```js
var p = new Proxy(target, {
  get(target, key, receiver) {
     if (key === 'b') { return 3 }
     return Reflect.get(target, key)
  }
})

p.a // undefined, target 本身没有 b 这个属性，所以访问到的是 undefined
```

```js
var p = new Proxy(target, {
  get(target, key, receiver) {
     if (key === 'b') { return 3 }
     return Reflect.get(p, key)
  }
})

p.a // 这样会死循环, get中会再次触发get
```

```js
var p = new Proxy(target, {
  get(target, key, receiver) {
     if (key === 'b') { return 3 }
     return Reflect.get(target, key, receiver)
  }
})

p.a // 3, 通过设置target中get a()中的this指向proxy本身，从而能够走到proxy中的get()中
```

#### 2.2.2、WeakMap使用

`WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合。

```javascript
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = {foo: 1};
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
wm2.get(k2) // "bar"
```

`WeakMap`与`Map`的区别有两点。

- `WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。

- `WeakMap`的键名所指向的对象，不计入垃圾回收机制。

`WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用

```javascript
const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [
  [e1, 'foo 元素'],
  [e2, 'bar 元素'],
];
```

上面代码中，`e1`和`e2`是两个对象，我们通过`arr`数组对这两个对象添加一些文字说明。这就形成了`arr`对`e1`和`e2`的引用。

一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用的内存。

```javascript
// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr [0] = null;
arr [1] = null;
```

上面这样的写法显然很不方便，一旦忘了写，就会造成内存泄露

`WeakMap` 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即==垃圾回收机制不将该引用考虑在内==。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

#### 2.2.3、reactive方法具体实现

> `reactive(target)`的接受参数**==必须是一个对象类型==**，否则没有任何效果
>
> `reactive(target)`实现的核心就是利用`proxy`对`target`进行代理

```typescript
// packages/reactivity/src/reactive.ts
import { isObject } from '@vue/shared';
import { mutableHandlers } from './baseHandlers';

function createReactiveObject(target: object) {
  // 只接受对象做代理
  if (!isObject(target)) {
    return target;
  }

  // 对target进行代理
  const proxy = new Proxy(target, mutableHandlers);
  return proxy;
}

// 常用的就是reactive方法
export function reactive(target: object) {
  return createReactiveObject(target, false);
}
```

```typescript
// packages/reactivity/src/baseHandlers.ts
export const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    // 等会谁来取值就做依赖收集
    const res = Reflect.get(target, key, receiver);
    return res;
  },
  set(target, key, value, receiver) {
    // 等会赋值的时候可以重新触发effect执行
    const result = Reflect.set(target, key, value, receiver);
    return result;
  }
};
```

`isObject()`的路径及实现

```typescript
// packages/shared/src/index.ts
export const isObject = (value) =>{
  return typeof value === 'object' && value !== null
}
```

以上就是`Reactive(target)`主要核心代码，很简单的代理实现

上面的`Reactive(target)`已经可以直接使用了，但是还有些特殊情况需要进行兜底逻辑处理

两个特殊情况：

1. **`Reactive(target)`中的`target`==已经被代理过了==**

   如果再次创建一个新的代理对象，未免有点浪费内存和性能，所以需要进行==缓存处理==，若`target`已经被代理过了，则直接返回代理对象

2. **`Reactive(target)`中的`target`已经是一个代理对象了**

   那完全没有必要对一个代理对象进行再次代理，所以需要增加判断`target`==是否是代理对象==的逻辑

完整代码如下👇

```typescript
// packages/reactivity/src/reactive.ts
import { isObject } from '@vue/shared';
import { ReactiveFlags, mutableHandlers } from './baseHandlers';

// 缓存列表，使用要代理的对象作key
const reactiveMap = new WeakMap();

function createReactiveObject(target: object, isReadonly: boolean) {
  // 只接受对象做代理
  if (!isObject(target)) {
    return target;
  }

  /**
   * 在进行对象代理前先进行取值，看是否已经是代理对象了
   * 若是已经代理过的对象，则target[ReactiveFlags.IS_REACTIVE]
   * 会走到getter方法，也就是mutableHandlers.get()中，
   * mutableHandlers.get()的返回值为true
   * 即target[ReactiveFlags.IS_REACTIVE]===true表示target已经被代理过了
   *
   * 若不是代理对象则target[ReactiveFlags.IS_REACTIVE]为undefined
   */
  if (target[ReactiveFlags.IS_REACTIVE]) {
    return target;
  }

  // 如果已经代理过则直接返回代理后的对象
  const existingProxy = reactiveMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }

  // 对target进行代理
  const proxy = new Proxy(target, mutableHandlers);
  // 缓存已经代理的对象
  reactiveMap.set(target, proxy);

  return proxy;
}

// 常用的就是reactive方法
export function reactive(target: object) {
  return createReactiveObject(target, false);
}
```

以上👆就是`reactive`方法的实现，主要内容就是==对目标对象`target`进行代理并返回代理的对象`proxy`==

------

对目标对象`target`的代理对象的==`getter`和`setter`方法==，在另外一个文件`packages/reactivity/src/baseHandlers.ts`中👇

```typescript
// packages/reactivity/src/baseHandlers.ts
export const enum ReactiveFlags {
  IS_REACTIVE = '__v_isReactive'
}

export const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    // 在get中增加标识，当获取IS_REACTIVE时返回true
    if (key === ReactiveFlags.IS_REACTIVE) {
      console.log('IS_REACTIVE', target)
      return true;
    }
    // 等会谁来取值就做依赖收集
    const res = Reflect.get(target, key, receiver);
    console.log('get', target, res)
    return res;
  },
  set(target, key, value, receiver) {
    // 等会赋值的时候可以重新触发effect执行
    const result = Reflect.set(target, key, value, receiver);
    return result;
  }
};
```

这里暂时只实现属性值的获取和赋值

后续这里会实现：

- **==依赖收集==**
- **==触发effect执行==**

<!--这个也是响应式原理的核心-->

使用效果

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="./reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: 'zf', age: 13, address: { num: 30 }, flag: true }

    const state = reactive(obj);
    console.log(state) // Proxy {name: 'zf', age: 13, address: {…}, flag: true}
    
    const state2 = reactive(obj);
    console.log(state === state2) // true

    const state3 = reactive(state);
    console.log(state === state3) // true
  </script>
</body>

</html>
```

可以发现对象state已经是目标对象obj的代理对象了，另外代理对象的缓存也实现了

### 2.3、effect方法实现

`effect(fn)`中的`fn`，首先默认执行一次，后续若`fn`中依赖到的`reactiveObject`的属性发生变化，则`fn`会再次执行；

<!--Vue3中的`effect()`相当于Vue2中的`watcher`，都是属性数据变化之后执行相应的回调-->

说到这里，其实就应该想到==**观察者模式**==和==**发布订阅模式**==；

- 在Vue2中使用到的便是==**观察者模式**==
  - `reactiveObject`的属性的`set()`中调用`watcher`的`update()`完成回调的执行

- 在Vue3中使用到的事==**发布订阅模式**==
  - `reactiveObject`的属性的`set()`中调用`ReactiveEffect`（调度中心）的`trigger()`方法
  - `trigger()`方法会将`ReactiveEffect`（调度中心）中的维护的==回调队列中的回调==<!--其实回调队列中是ReactiveEffect实例，实例上的run()才是effect(fn)中的fn-->拿出来一一执行

#### 2.3.1、effect方法简单实现

```js
// packages/reactivity/src/effect.ts
export let activeEffect = undefined;// 当前正在执行的effect

class ReactiveEffect {
    deps = []; // 收集effect中使用到的属性
    constructor(public fn) { }
    run() {
        // 设置成正在激活的是当前effect
        activeEffect = this;
        return this.fn();
    }
}
export function effect(fn) {
    const _effect = new ReactiveEffect(fn); // 创建响应式effect
    _effect.run(); // 让响应式effect默认执行
}
```

==每一个`effect(fn)`方法的执行都会创建一个`ReactiveEffect`实例==，实例上有两个属性

- **deps**：用于收集当前副作用函数中使用到的响应式数据
- **fn：**用于存放用户传入的回调

用户传入的回调`fn`被挂到了`ReactiveEffect`实例（ `_effect`）上了，并通过 `_effect.run()`来执行`fn`	

```js
export function effect(fn) {
    const _effect = new ReactiveEffect(fn); // 创建响应式effect
    _effect.run(); // 让响应式effect默认执行
}
```

为什么要单独实例化一个`ReactiveEffect`来执行`fn`

那是因为`ReactiveEffect`上实现了`effect`==依赖的属性==、==激活状态==等很多属性及==`effect`失活==等方法<!--这些后面会用到-->

------

其中`activeEffect`是个==全局变量==，记录的是==当前正在执行的`effect`==<!--是`ReactiveEffect`实例-->

```js
export let activeEffect = undefined;
```

所以在**reactive模块**中是可以==直接拿到并直接使用==，后续的**==依赖收集==**就是使用这个`activeEffect`全局变量在`Proxy`的`get()`中完成的

#### 2.3.2、依赖收集的track方法

所谓**==依赖收集==**就是在`effect(fn)`中`fn`默认执行（第一次执行）时，对`fn`中依赖到的响应式对象`reactiveObject`的属性`attr`==进行收集==

实际上==依赖收集是双向的==，`effect`要收集`attr`，`attr`也要收集`effect`

<!--这个很重要‼️-->

实现如下👇

先实现`track`方法

```js
// packages/reactivity/src/effect.ts

// 记录依赖关系，数据格式{target: { attr: [effect, effect]}}
const targetMap = new WeakMap();
export function track(target, key) {
  if (activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }
    // 依赖收集的存储操作
    trackEffects(deps);
  }
}

export function trackEffects(deps) {
  /**
   * 若是当前attr已经记录了此activeEffect
   * 则不再次收集
   */
  let shouldTrack = !deps.has(activeEffect);
  if (shouldTrack) {
    // attr 记录 effect
    deps.add(activeEffect);
    // effect 记录 attr 放的是set
    activeEffect.deps.push(deps);
  }
}
```

==**依赖收集**的`track`方法主要有两部分内容：==

- ==**`attr`收集`effect`**== 

  首先创建一个Map对象`targetMap`，用于存储**==所有==**依赖`reactiveObject`属性`attr`的`effect`

  ```js
  // 录依赖关系，数据格式{target: { attr: [effect, effect]}}
  const targetMap = new WeakMap();
  ```

  `targetMap`的数据格式是`{target: { attr: [effect, effect]}}`

  - `target`是`proxy`中的`target`（也就是响应式对象`reactiveObject`）

  - `attr`就是`fn`中依赖到属性

  - `[effect, effect]`是个`set`，放的是不同的`effect`<!--一个`attr`可能被好几个`effect`依赖-->

  ------

  上面实现中`trackEffects`中`deps.add(activeEffect)`便是==`attr`收集`effect`==的逻辑

  ```js
  export function trackEffects(deps) {
   ...
   // attr 记录 effect
  deps.add(activeEffect);
   ...
  }
  ```

  -  `deps`就是`attr`对应`key`的`set`

     <!--也就是`{target: { attr: [effect, effect]}}`中的`[effect, effect]`-->

  - `activeEffect`则是当前正在活跃的`effect` <!--这个需要理解‼️-->

    `activeEffect`是一个全局变量，表示==当前正在活跃的effect==，

    - 每当 `effect.run()`执行时，`activeEffect`便会被置为当前`effect`

      <!--也就是说只有当副作用函数`effect(fn)`执行时，`activeEffect`才有值-->

    - 若当前正在活跃的`effect`中依赖到了响应式数据`attr`，那么`attr`便要收集该`effect`

  ------

  假设有两个`effect`（`e1`、`e2`）都依赖了响应式对象中的属性`a`

  - 当`e1`的回调默认执行时，`a`便会收集到`e1`，此时的`targetMap`便是这样的：`{target: { a: [e1]}}`

  - 当`e2`的回调默认执行时，`a`同样会收集`e2`，此时的`targetMap`便是这样的：`{target: { a: [e1，e2]}}`

  这样便完成了`attr`收集`effect` 

- ==**`effect`收集`attr`**==

  同样的，`effect`也是要收集`attr`的，==维护在`effect.deps`中==

   <!--`deps`是个数组，因为一个`effect`可能会依赖到多个`attr`-->

  ```js
   export function trackEffects(deps) {
     ...
    // effect 记录 attr 放的是set
    activeEffect.deps.push(deps);
     ...
  }
  ```

  假设有两个`effect`（`e1`、`e2`）都依赖了属性`a`、`b`，那么==存储effect==的`targetMap`和==effect上存储attr==的`effect.deps`是什么样的？👇

  - `targetMap`：`{target: { a: [e1,e2], b:[e1,e2]}}`

  - `effect.deps`：`[[e1,e2],[e1,e2]]`

  > 看到这行代码可能会有这样的疑问： activeEffect.deps中收集的不应该是attr的key值么，==为什么activeEffect.deps中收集的是attr的所有effect？==
  >
  > 这是因为后面要实现的依赖清理中==需要将当前effect从attr收集的所有effect中清除掉==
  >
  > effect清理依赖时，不仅要清除自己的deps，还要将自己从attr收集的所有effect中清除

再在`proxy get()`中调用`track`

```js
// packages/reactivity/src/baseHandlers.ts

import { track } from './effect';
export const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    ...
    // 让当前的属性和 正在激活的effect关联起来
    track(target, key);

    const res = Reflect.get(target, key, receiver);
    ...
    return res;
  }
};
```

整个**==依赖收集==**的流程是这样的：`effect(fn)` :arrow_right:`_effect.run()`:arrow_right: `proxy get()`:arrow_right:`track()`

<!--依赖收集是发生在`proxy get()`中，这个也是为什么要对原对象进行代理的一个原因，后面`attr`的变化引起的回调执行，也是要在代理对象`reactiveObject`的`proxy set()`实现-->

#### 2.3.3、触发更新的trigger方法

触发更新就是指响应式对象`reactiveObject`中的`attr`发生变化时，==`attr`收集到`effect`会相应的再次执行==，实现如下👇

```typescript
// packages/reactivity/src/effect.ts

export function trigger(target, key, value) {
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    return; // 属性没有依赖任何的effect
  }
  let effects = depsMap.get(key);
  triggerEffects(effects);
}

export function triggerEffects(effects) {
  if (effects) {
    effects.forEach(effect => {
     /**
       * 保证要执行的effect不是当前的effect
       * 避免effect中直接改动attr引起的effect再次执行的死循环
       * 因为attr只要变化便会触发trigger
       * 这里做逻辑判断就是阻断掉effect中直接改动attr引起的trigger
       */
      if (effect !== activeEffect) {
        // 数据变化了，找到对应的effect 重新执行
        effect.run();
        }
      }
    });
  }
}
```

==**触发更新的**`trigger`方法主要有两部分内容：==

- 通过目标对象`target`和响应式式数据属性`attr`从`depsMap`中找到依赖此`attr`的所有`effects` 

  <!--effects是一个Set，里面存放了所有依赖到此attr的effect-->

- 遍历依赖此`attr`的所有`effects` <!--除了正在活跃的effect-->，调用`effect.run()`再次执行副作用函数，从而实现响应式更新

------

再在`proxy set()`中调用`trigger`

```typescript
// packages/reactivity/src/baseHandlers.ts

import { trigger } from './effect';
export const mutableHandlers: ProxyHandler<object> = {
    set(target, key, value, receiver) {
    let oldValue = target[key];
    if (oldValue !== value) {
      // 重新赋值时，若新值和老值不同则触发effect
      trigger(target, key, value);
      let result = Reflect.set(target, key, value, receiver);
      return result;
    }
  }
};
```

整个流程是这样的：`reactiveObject`的`attr`发生变化:arrow_right: `proxy set()`​ :arrow_right: `trigger()`​ :arrow_right: `effect.run()`​ :arrow_right: `effect(fn)`中的`fn`再次执行

------

上面实现中有段特殊逻辑：

```typescript
/**
 * 保证要执行的effect不是当前的effect
 * 避免effect中直接改动attr引起的effect再次执行的死循环
 * 因为attr只要变化便会触发trigger
 * 这里做逻辑判断就是阻断掉effect中直接改动attr引起的trigger
 */
if (effect !== activeEffect) {
  // 数据变化了，找到对应的effect 重新执行
 effect.run();
  }
}
```

是为了解决下面👇这种场景：

```js
// 缓存代理结果 require()
const {effect ,reactive} = VueReactivity;
const state = reactive({ age: 30 })
effect(() => { 
   if(age>30) age++;
});
age = 31;
```

直接在`effect(fn)`中对`reactiveObject`的`attr`重新赋值

试想下，若是没有上面那段判断逻辑，`age = 31` :arrow_right: `trigger()` :arrow_right:  `effect.run()` :arrow_right: `fn`再次执行 :arrow_right: `age`变化......便会陷入**==死循环==**；

那这段特殊逻辑是怎么避免了死循环的呢？是否还记得 `effect.run()`的实现

```typescript
run() {
    // 设置成正在激活的是当前effect
    activeEffect = this;
    return this.fn();
}
```

==每次`effect.run()`执行时，便会将全局变量`activeEffect`置为当前的`effect`==，那当`attr`发生变化引起的`trigger()`时，只要将当前的`effect`从`attr`收集到的`effect`中过滤掉不执行`effect.run()`便可以避免死循环；

那么上面的案例的流程就变成了这样：`age = 31` :arrow_right: `trigger()` :arrow_right:  `effect.run()` :arrow_right: `fn`再次执行 :arrow_right: `activeEffect = this` :arrow_right: `age++` :arrow_right: `trigger()` :arrow_right: `effect !== activeEffect`为`false` :arrow_right: 结束，`effect.run`不执行

<!--也就是说，若在effect的fn中直接修改attr，则此effect不会再次执行fn-->

#### 2.3.4、实现效果

以上就是Vue3响应式变化的基本实现，下面👇看下实现效果

```html
<!--  -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="./reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: '张三', age: 13, address: { num: 30 }, flag: true }
    const state = reactive(obj);

    effect(() => {
      app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
    })

    setTimeout(() => {
      state.age++
    }, 1000)
  </script>
</body>

</html>
```

运行结果

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220603181116115-20220603181158295.png" style="zoom:50%;" />

一秒之后

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220603181219615.png" alt="image-20220603181219615" style="zoom:50%;" />



### 2.4、响应式中的一些特殊逻辑

#### 2.4.1、嵌套effect的处理逻辑

先看下==嵌套`effect`==的具体场景

```js
  const obj = { name: '张三', age: 13, flag: false }
  const state = reactive(obj);

  effect(() => { // e1
    state.name
    effect(() => { // e2
      state.age
    })
    state.flag
  })
```

嵌套`effect`就是在一个`effect`中再使用一个`effect`，那么这么使用会有什么问题呢？

```typescript
// packages/reactivity/src/effect.ts
export let activeEffect = undefined;// 当前正在执行的effect

class ReactiveEffect {
    ...
    run() {
        // 设置成正在激活的是当前effect
        activeEffect = this;
        return this.fn();
    }
  ...
}
```

假设这里有两个`effect`：`e1`、`e2`，`e2`嵌套在`e1`中，

- 在`e1`初次执行到`state.name`这一行时，==全局变量`activeEffect`指向的是`e1`==
- 但接下来执行`e2`的时候，==`activeEffect`指向的就变成了`e2`==

到这里其实一切都还没问题，但当`e2`执行完成，再去执行`state.flag`时，此时的`activeEffect`指向的还是`e2`，这就有问题了，明明`flag`是`e1`依赖的属性，怎么能和`e2`绑定呢

所以这里应该有这样一段逻辑，==当`e2`执行完成时，`activeEffect`指向应该由`e2`变回`e1`==

因此需要对`activeEffect`的指向进行改造，改造之后的逻辑如下👇

```typescript
// packages/reactivity/src/effect.ts
export let activeEffect = undefined;// 当前正在执行的effect

class ReactiveEffect {
   public parent = undefined;
    ...
run() {
    try {
      // 将activeEffect设置为当前ReactiveEffect实例的父effect，用作记录存储
      this.parent = activeEffect;
      // 再将当前ReactiveEffect实例设置为activeEffect
      activeEffect = this;
      return this.fn();
    } finally {
      /**
       * 执行完毕后还原activeEffect，
       * 也就是当前的ReactiveEffect实例只对出现在自己fn方法中的属性进行依赖收集操作
       * 若不执行这一步，每一次响应式对象中有get()操作时都会将属性收集到activeEffect中
       */
      activeEffect = this.parent;
      this.parent = undefined;
    }
  }
  ...
}
```

<!--源码中其实是维护了一个effectStack数组，模拟栈，来解决嵌套effect的问题-->

#### 2.4.2、依赖更新与依赖清理cleanup

先看下这个场景

```js
const {effect ,reactive} = VueReactivity;

const state = reactive({ flag: true, name: '张三', age: 30 })
effect(() => {
    document.body.innerHTML = state.flag ? state.name : state.age
});
setTimeout(() => {
    state.flag = false;
    setTimeout(() => {
        console.log('修改name，原则上不更新')
        state.name = '李四'
    }, 1000);
}, 1000)
```

- 当`state.flag`为`true`时，`effect`依赖的是`name`属性，
- 但当`state.flag`为`false`时，`effect`就不再依赖`name`属性，而是依赖`age`属性

因此，当`name`改变时，`effect`应该不再次执行，但目前的响应式变化`trigger`中并没有将`name`属性进行==依赖移除==的逻辑，所以当`name`改变时，`effect`会再次执行

==依赖更新==是由`trigger`==触发==的，但是具体逻辑却是在`effect.run()`处理的

改造逻辑如下👇

```typescript
export function trigger(target, key, value) {
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    return; // 属性没有依赖任何的effect
  }
  let effects = depsMap.get(key);
  triggerEffects(effects);
}

export function triggerEffects(effects) {
  if (effects) {
    /**
     * 注意：这里的attr收集的effects在effect的deps中也有保存
     * 所以需要将effects复制一份，再进行操作，
     * 避免effect.run()中清理effect时的死循环
     */
    effects = new Set(effects);
    effects.forEach(effect => {
      if (effect !== activeEffect) {
        effect.run(); // 数据变化了，找到对应的effect 重新执行
      }
    });
  }
}
```

```typescript
class ReactiveEffect {
  ...
  run() {
    try {
      ...
      /**
       * 清理当前ReactiveEffect实例中的deps
       * 在下面的fn()执行时会再次收集
       * 也就是先清理在收集，为什么这么处理
       * 是因为当前ReactiveEffect实例依赖的attr可能会发生变化
       * 这样做是为了更新effect依赖的attr
       */
      cleanEffect(this);
      return this.fn();
    } finally {
      activeEffect = this.parent;
      this.parent = undefined;
    }
  }
  
/**
 * 清理effect收集的attr的deps(set集合, set存放的是effect)
 * set中存放的是attr收集的effect(是所有的effect，不只是当前的effect)
 * 这里只是从attr收集的所有effect中删除当前的effect
 * 所以这里有两步逻辑
 * 1、从attr收集的所有effect中删除当前的effect
 * 2、将当前effect的deps清空
 * 既清理了attr的依赖又清理了effect的依赖
 */
function cleanEffect(effect) {
  let deps = effect.deps;
  for (let i = 0; i < deps.length; i++) {
    deps[i].delete(effect);
  }
  effect.deps.length = 0;
}
```

依赖更新的实现其实是每次`trigger`的执行，就会==先清理依赖==，之后==再重新进行收集==

整个流程是这样的：`attr`变化 :arrow_right: `proxy set()` :arrow_right: `trigger()` :arrow_right: `effect.run()` :arrow_right: `cleanEffect()`清理依赖   :arrow_right: `this.fn()` :arrow_right: `proxy get()` :arrow_right: `track()`重新收集依赖

其中 `cleanEffect()`清理依赖的逻辑可能有点难理解

```typescript
function cleanEffect(effect) {
  let deps = effect.deps;
  for (let i = 0; i < deps.length; i++) {
    deps[i].delete(effect);
  }
  effect.deps.length = 0;
}
```

‼️**==重要==**：应该还记==得`effect.deps`中收集的不是`atrr`的`key`，而是`attr`依赖的`effect`==<!--是所有的`effect`，不只是当前的一个`effect`-->，所以`cleanEffect()`中做了两件事

- 从`attr`收集的所有`effect`中删除==当前的`effect`==
- 将==当前`effect`的`deps`清空==<!--length = 0会直接将数组清空-->

#### 2.4.3、effect停止依赖收集

 `effect`中在使用`reactive`对象时会进行依赖收集，之后属性变化时会重新执行`effect`函数，但若是想要在某一时刻想要==取消这种响应式变化==，如何处理呢？

所以应该有这样一个功能，提供一个控制`effect`==激活状态==的`api`由调用方自行决定什么时候进行响应式变化

改造逻辑如下👇

```typescript
// packages/reactivity/src/effect.ts

class ReactiveEffect {
  ...
  /**
   * 失活操作
   * 停止收集依赖
   */
  stop() {
    if (this.active) {
      this.active = false;
      cleanEffect(this);
    }
  }
}

export function effect(fn, options?) {
  // 将外部传递进来的函数设置为响应式的effect
  const _effect = new ReactiveEffect(fn);
  // 让响应式effect默认执行一次
  _effect.run();
  // 更改runner中的this
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect; // 暴露effect的实例
  // effect返回runner的目的是让用户可以自己控制渲染逻辑
  return runner; // 用户可以手动调用runner重新执行
}
```

给`ReactiveEffect`实例上增加==`stop`方法==，`stop`方法中会==将`effect`置为失活状态并进行依赖清理==，之后再通过将`effect`暴露出去的方式，让==用户可以自行调用`runner()`和`runner.effect.stop()`==进行`effect`失活与激活状态的切换

使用方式👇

```html
<!--  -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="./reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: '张三', age: 13, address: { num: 30 }, flag: false }
    const state = reactive(obj);

    const runner = effect(() => {
      app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
    })

    runner.effect.stop();

    setTimeout(() => {
      state.age++
      runner()
    }, 5000)
  </script>
</body>

</html>
```

#### 2.4.4、调度执行（实现批量更新）

先看下这个👇场景，猜测下`effect`共执行几次

```html
<!--  -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="./reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, reactive } = VueReactivity;

    const obj = { name: '张三', age: 13, address: { num: 30 }, flag: false }
    const state = reactive(obj);

    const runner = effect(() => {
      console.log('runner')
      app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
    })

    setTimeout(() => {
      state.name = '李四'
      state.age++
      state.address.num ++
    }, 5000)
  </script>
</body>

</html>
```

打印结果是4次，除去第一次默认执行，还执行了3次，也就是说`reactiveObject`的`attr`每变化一次，就会`trigger()`一次，`effect(fn)`的`fn`就会执行一次，`html`就会重新渲染一次,这样未免太浪费性能了，所以期望有一个==批量更新==的逻辑，可以实现==多次变化只执行一次渲染==

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220608232301142.png" alt="image-20220608232301142" style="zoom:50%;" />

改造逻辑如下👇

首先实现`scheduler`（调度）功能，支持用户自定义`trigger()`==之后的执行逻辑==<!--默认是执行`effect(fn)`中的`fn`-->

```typescript
// packages/reactivity/src/effect.ts
class ReactiveEffect {
  ...
  // 传递的fn、scheduler挂到this上
  constructor(public fn, public scheduler?) {}
  ...
}

export function effect(fn, options = {} as any) {
  ...
  /**
   * 将外部传递进来的函数设置为响应式的effect
   * options为用户自定义的配置项
   */
  const _effect = new ReactiveEffect(fn, options?.scheduler);
  ...                                   
}

export function triggerEffects(effects) {
  if (effects) {
    effects = new Set(effects);
    effects.forEach(effect => {
      if (effect !== activeEffect) {
        if (effect.scheduler) {
          effect.scheduler(); // 可以提供一个调度函数，用户实现自己的逻辑
        } else {
          effect.run(); // 数据变化了，找到对应的effect 重新执行
        }
      }
    });
  }
}
```

上面改造的逻辑可以让用户在使用`effect(fn, [options])`方法时，通过配置项传入自定义的`scheduler`，指定`trigger`触发时执行的逻辑；

上面的逻辑中关键的是这里，==用户若配置了`scheduler`则不再执行`effect.run()`也就是`fn`，而是执行`scheduler`==

```typescript
if (effect.scheduler) {
  effect.scheduler(); // 可以提供一个调度函数，用户实现自己的逻辑
} else {
  effect.run(); // 数据变化了，找到对应的effect 重新执行
}
```

那有了`scheduler`，用户便可以自己自己决定`trigger`触发时，==副作用函数执行的时机、次数、及执行方式==，从而实现批量更新的效果

⚠️注意：`scheduler`实现的仅仅是自定义副作用函数，也就是说每次`trigger`之后，`scheduler`都会执行一次，==Vue本身并没有做响应式变化的批量更新逻辑，但是通过`scheduler`我们是能够实现批量更新的==

批量更新使用如下👇

```js
<script src="./reactivity.global.js"></script>
<div id="app"></div>
<script>
  const { effect, reactive } = VueReactivity;

  const obj = { name: '张三', age: 13, address: { num: 30 }, flag: false }
  const state = reactive(obj);

  let waiting = false;
  const runner = effect(() => {
    console.log('runner')
    app.innerHTML = state.name + '今年' + state.age + '岁了门牌号是 ' + state.address.num
  }, {
    scheduler() { // 调度函数
      console.log('scheduler')
      if (!waiting) {
        waiting = true
        Promise.resolve().then(() => {
          runner();
          waiting = false;
        })
      }
    }
  })

  setTimeout(() => {
    state.name = '李四'
    state.age++
    state.address.num++
  }, 1000)
</script>
```

上面👆==批量更新==的关键在于`Promise.resolve().then()`的使用

我们应当明确的一点是，==Vue的`tragger`都是同步逻辑==，那当我们在一次`scheduler`中使用了`promise`之后，产生的异步逻辑，==会在所有的同步逻辑执行完之后才会执行==

也就是说，每次`tragger`都会触发`scheduler`,但`scheduler`中的异步逻辑要等到所有的`tragger`都触发之后才更新；那利用这个特性，我们便可以实现同步更新操作；

实现效果如下👇

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20220609001337257.png" alt="image-20220609001337257" style="zoom:50%;" />

### 2.5、`computed`实现

同Vue2的`computed`计算属性一样，Vue3的`computed`计算属性也是将几个`reactiveObject`的属性(`attr1`、`attr2`...)整合成一个新的`reactiveObject`的属性(`attr`)，当`attr1`、`attr2`...改变时，`attr`也会相应的改变

`computed`的使用如下👇

```js
const attr = computed(() => {
...
return attr1 + attr2
})
// 或者
const attr = computed({
  get(){
    ...
    return attr1 + attr2
  },
  set(val){
   attr1 = val;
  }
})
```

实现如下👇

```typescript
// packages/reactivity/src/computed.ts

import { isFunction } from '@vue/shared';
import {
  activeEffect,
  ReactiveEffect,
  trackEffects,
  triggerEffects
} from './effect';

export function computed(getterOrOptions) {
  // 判断传进来的是get方法还是配置项
  let isGetter = isFunction(getterOrOptions);

  // 赋值get和set方法
  let getter;
  let setter;
  const fn = () => console.warn('computed is readonly ');
  if (isGetter) {
    getter = getterOrOptions;
    setter = fn;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set || fn;
  }

  // 返回ComputedRefImpl实例
  return new ComputedRefImpl(getter, setter);
}

/**
 * ComputedRefImpl类
 * 内部封装了ReactiveEffect的实例化
 * 负责依赖收集的工作
 */
class ComputedRefImpl {
  private _value; // 用来存储计算属性的结果
  private _dirty = true; // 用来判断是否缓存，即是否重新计算
  public effect; // 计算属性对应的effect
  public deps; // 用于收集依赖当前计算属性的effect(注意：和计算属性对应effect区分开)
  constructor(getter, public setter) {

    // effect.deps 存的是属性对应的set集合
    this.effect = new ReactiveEffect(getter, () => {
      /**
       * effect 的 scheduler，
       * 这里自定义 当前计算属性依赖的 attr 发生变化后的更新逻辑
       */
      if (!this._dirty) {
        /**
         * 这里的更新逻辑是
         * 当计算属性被使用后，_dirty就会为false，使用的便是缓存值了
         * 也只有计算属性被使用后，才需要走这段更新逻辑
         */
        this._dirty = true;
        // 通知依赖当前计算属性的effect更新
        triggerEffects(this.deps);
      }
    });
  }

  get value() {
    /**
     * 有effect依赖当前计算属性的话，就将其收集到当前计算属性的deps中
     * 注意：只有当effect的副作用函数执行时，activeEffect才有值，
     * 若是当前计算属性value在被使用时，activeEffect有值的话
     * 就说明了此activeEffect是依赖当前计算属性的
     */
    if (activeEffect) {
      trackEffects(this.deps || (this.deps = new Set()));
    }

    /**
     * 只有当_dirty为true时
     * 即当前计算属性依赖的 attr 发生变化后
     * 才走计算属性的getter逻辑并更新_value
     * 否则就不更新_value直接返回（也就是缓存值）
     */
    if (this._dirty) {
      // 将_dirty置为false，表明接下来计算属性返回的是缓存值
      this._dirty = false;
      this._value = this.effect.run();
    }
    return this._value;
  }

  /**
   * 直接执行用户配置的set
   * 在set中可以直接修改 reactiveObj 的 attr
   */
  set value(newValues) {
    this.setter(newValues);
  }
}

```

计算属性`computed`的实现中，`ComputedRefImpl`类上有两个很重要的属性：

-  **public effect**：==当前计算属性自己对应的effect==

  - 计算属性`computed`中使用到的==响应式数据`attr`==，会收集==此计算属性自己的`effect`==

  - 当使用到的响应式数据`attr`发生变化会触发此`effect`更新 <!--执行scheduler-->

    ```js
    () => {
      /**
       * effect 的 scheduler，
       * 这里自定义 当前计算属性依赖的 attr 发生变化后的更新逻辑
       */
      if (!this._dirty) {
        /**
         * 这里的更新逻辑是
         * 当计算属性被使用后，_dirty就会为false，使用的便是缓存值了
         * 也只有计算属性被使用后，才需要走这段更新逻辑
         */
        this._dirty = true;
        // 通知依赖当前计算属性的effect更新
        triggerEffects(this.deps);
      }
    }
    ```

- **public deps**：==依赖当前计算属性的effect== <!--注意：和计算属性对应effect区分开-->

  - 所有使用此计算属性的`effect`都会被收集到当前计算属性的`deps`上

    ```js
    get value() {
      /**
       * 有effect依赖当前计算属性的话，就将其收集到当前计算属性的deps中
       * 注意：只有当effect的副作用函数执行时，activeEffect才有值，
       * 若是当前计算属性value在被使用时，activeEffect有值的话
       * 就说明了此activeEffect是依赖当前计算属性的
       */
      if (activeEffect) {
        trackEffects(this.deps || (this.deps = new Set()));
      }
    }
    ```

计算属性更新的流程是这样的：

- **收集依赖阶段**：
  - `effect`中使用此计算属性 ➡️ 执行`get value()`获取属性值 ➡️ 执行`trackEffects`收集当前`effect`到此计算属性的`deps`上
- **响应更新阶段**：
  - 响应式数据`attr`发生变化 ➡️ 触发计算属性`effect`的更新 ➡️ 执行`scheduler` ➡️ 执行`triggerEffects`，触发所有依赖此计算属性的effect更新

------

‼️`computed`实现中两个核心的点：

- ==`computed`本身就是个`effect`==
  - `computed`中使用到的响应式数据收集依赖时会将此`effect`进行收集
  - 但计算属性本身又收集了其他使用计算属性`computed`的`effect`，用作响应式更新
- `computed`缓存值的实现

### 2.6、`watch`实现

`watch`的核心就是观测一个响应式数据，当数据变化时通知并执行回调 （那也就是说它本身就是一个`effect`）

```js
watch(state,(oldValue,newValue)=>{ // 监测一个响应式值的变化
    console.log(oldValue,newValue)
})
// 或者
watch(state => stae[key],(oldValue,newValue)=>{ // 监测一个响应式值的变化
    console.log(oldValue,newValue)
})
```

`watch`的使用有几个关键主要注意⚠️：

- `watch`如果监控的是一个对象那么，对象是无法拿到老值的，`oldValue`内的数据会是更新之后的（vue2也是一样) ，这个是因为对象是引用类型的，`oldValue`,`newValue`指向的是同一个对象
- vue3 中`watch`监控的是一个对象的时候默认会深度监控，对象内的所有属性都会被监控，所以尽量不要采用这种直接监控对象的方式 <!--默认会递归访问对象的属性，所以不建议用-->
- ==如果监控的是某个属性的话，需要写成函数的格式==

`watch`的实现如下

```typescript
// packages/reactivity/src/baseHandler.ts

//判断是否是响应式对象
export function isReactive(value) {
  return value && value[ReactiveFlags.IS_REACTIVE];
}
```

```typescript
import { ReactiveEffect } from './effect';
import { isReactive } from './baseHandler';
import { isFunction, isObject } from '@vue/shared';

/**
 * 用来递归访问对象属性
 * set用来存放已经迭代过的对象
 */
function traversal(value, set = new Set()) {
  if (!isObject(value)) {
    return value;
  }

  if (set.has(value)) {
    // 此对象已经被迭代过了
    return value;
  }
  set.add(value);

  for (let key in value) {
    // 递归逻辑，value[key] 访问所有属性
    traversal(value[key], set);
  }

  return value;
}

export function watch(source, cb, { immediate } = {} as any) {
  let get; // 用来存放要监控的对象，函数形式
  let oldValue; // 存放老值
  let cleanup; // 用于清理上一次watch操作的

  if (isReactive(source)) {
    /**
     * 若是传进来的是个ReactiveObj,
     * 则生成一个遍历访问的fn,供后续new ReactiveEffect(fn, scheduler)使用
     * 创建一个effect，让这个effect收集source中的所有属性
     */
    get = () => traversal(source);
  } else if (isFunction(source)) {
    // 若传进来的是一个函数则直接使用、
    get = source;
  }

  /**
   * onCleanup(fn),接收用户传入的方法作为参数，并赋值给cleanup
   */
  const onCleanup = fn => {
    cleanup = fn;
  };

  /**
   * scheduler方法，数据变化后调用
   */
  const job = () => {
    /**
     * 第一次执行时cleanup是undefined
     * 如果cleanup有值，则是上一次赋值的
     * 所以这里的cleanup是上一次的，利用了的闭包原理
     */
    cleanup && cleanup();

    // 数据变化后重新调用effect.run函数，会获得最新的值
    let newValue = effect.run();

    // 执行用户传进来的回调，并传入参数
    cb(newValue, oldValue, onCleanup);

    // 回调执行完之后，将这一次执行的新值赋值给oldValue
    oldValue = newValue;
  };

  const effect = new ReactiveEffect(get, job);

  if (immediate) {
    // 需要立即执行，则立刻执行任务
    job();
  }

  // 默认调用run方法会执行get函数，此时source作为了第一次的老值（get的返回值是source）
  oldValue = effect.run();
}

```

`watch`实现的核心在于利用了`effect`的实现原理

```typescript
 const effect = new ReactiveEffect(get, job);
```

创建了一个`effect`，完成对`watch`中使用到的`attr`==依赖收集==，并对用户==传入的回调进行封装==，封装后的方法作为`scheduler`方法，用于数据变化后调用

上面实现中还有一个关键的地方，`cleanup`的实现

可以看下`cleanup`的使用场景

<!--连续触发watch时需要清理之前的watch操作-->

```js
const state = reactive({ age: 30 })
let i = 2000;
function getData(timer){
    return new Promise((resolve,reject)=>{
        setTimeout(() => {
            resolve(timer)
        }, timer);
    })
}
watch(()=>state.age,async (newValue,oldValue,onCleanup)=>{
    let clear = false;
    onCleanup(()=>{
        clear = true;
    })
    i-=1000;
    let r =  await getData(i); // 第一次执行1s后渲染1000， 第二次执行0s后渲染0， 最终应该是0
    if(!clear){document.body.innerHTML = r;}
 
},{flush:'sync'});

state.age = 31;
state.age = 32;
```

用户传入的`onCleanup`是在下一次`watch`触发时才执行的，所以可以利用`onCleanup`完成一些取消上一次请求结果等类似的操作

### 2.7、`ref`的实现

因为`reactive`==只能接受一个对象作为参数==，那么基本数据类型的数据便无法成为响应式数据了么？

答案是否定，只不过是通过`ref`来将基本数据类型的数据值变为响应式数据

==`ref`接受一个参数值并返回一个响应式且可改变的 `ref` **对象**==，`ref` **对象**拥有一个指向内部值的单一属性 `value`

```html
// packages/reactivity/dist/09、ref使用.html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="../../../node_modules/@vue/reactivity/dist/reactivity.global.js"></script>
  <div id="app"></div>
  <script>
    const { effect, ref } = VueReactivity;

    // 基本类型，不具备响应式能力, 用ref将基本类型变成对象类型，具备响应式能力
    let flag = ref(false);
    let obj = ref({ name: '张三' })

    effect(() => {
      console.log('runner')
      app.innerHTML = flag.value + obj.value.name
    })

    setTimeout(() => {
     // 改value的时候可以触发effect重新执行
      flag.value = true;
      obj.value.name = '李四'
    }, 1000)

  </script>
</body>

</html>
```

`ref` 跟 `reactive` 都是响应系统的核心方法，作为整个系统的入口

可以将 `ref` 看成 `reactive` 的一个变形版本，这是由于 `reactive` 内部采用 `Proxy` 来实现，==而 `Proxy` 只接受对象作为入参，这才有了 `ref` 来解决基础类型的数据响应==，如果传入 `ref` 的是一个对象，内部也会调用 `reactive` 方法进行深层响应转换

#### 2.7.1、`ref`实现

`ref`的实现如下👇

```typescript
// packages/reactivity/src/ref.ts

import { isObject } from '@vue/shared';
import { activeEffect, trackEffects, triggerEffects } from './effect';
import { reactive } from './reactive';

/**
 * 用于将对象转换成ReactiveObj
 */
export function toReactive(value) {
  return isObject(value) ? reactive(value) : value;
}

/**
 * 对传入进来的基础类型数据、对象进行代理到value属性上
 * (用到的其实是defineProperty方法)
 * (es6 class中的get、set编译成es5的话就是defineProperty)
 * 并对value属性设置响应式逻辑
 * get时收集依赖 trackEffects
 * set时触发更新 triggerEffects
 */
class RefImpl {
  private _value;
  private dep;
  private __v_isRef = true;
  constructor(public rawValue, public _shallow) {
    // 浅ref不需要再次代理
    this._value = _shallow ? rawValue : toReactive(rawValue);
  }

  get value() {
    if (activeEffect) {
      trackEffects(this.dep || (this.dep = new Set())); // 收集依赖
    }
    return this._value;
  }

  set value(newVal) {
    if (newVal !== this.rawValue) {
      this.rawValue = newVal; // rawValue为原始数据，会保留在ref对象上
      this._value = this._shallow ? newVal : toReactive(newVal);
      triggerEffects(this.dep); // 触发更新
    }
  }
}

/**
 * 将原始数据进行装包，转变成响应式数据
 */
function createRef(rawValue, shallow) {
  return new RefImpl(rawValue, shallow);
}

/**
 * 将原始类型包装成对象, 同时也可以包装对象 进行深层代理
 */
export function ref(value) {
  return createRef(value, false);
}

/**
 * 创建浅ref 不会进行深层代理
 */
export function shallowRef(value) {
  return createRef(value, true);
}
```

`ref`的实现中核心逻辑是

- ==将用户传入的`rawValue`，挂在`ref`对象(`RefImpl`实例)的`value`属性上==

- ==并在`value`属性的`get`、`set`上完成响应式的逻辑==

  - 对`ref`对象的`value`创建`getter`访问器：`get value()`

    - 完成依赖收集

      ```js
      trackEffects(this.dep || (this.dep = new Set()))
      ```

      将使用到`ref.value`的`effect`收集到`ref.deps`上

  - 对`ref`对象的`value`创建`setter`访问器：`set value()`

    - 完成响应式更新

      ```js
      triggerEffects(this.dep); // 触发更新
      ```

<!--ref的作用就是将不是响应式的数据变成响应式的-->

#### 2.7.2、 `toRef` & `toRefs`实现

先看一个响应式丢失现象

```js
const { effect, reactive } = VueReactivity;
const state = reactive({name: '张三', age: 30 })
let person = {...state}
effect(()=>{
    document.body.innerHTML = person.name +'今年' + person.age +'岁了'
})
setTimeout(()=>{
    person.age = 31;
},1000)
```

如果对`ReacttiveObj`进行==解构操作则会丢失响应式的特性==

这是因为对对响应式对象进行解构，相当于是进行了==浅拷贝==，那在`effect`中==使用浅拷贝的对象是走不到`ReacttiveObj`的`get`中的==，那也就不会进行依赖收集（其实不光没有收集，修改数据之后也不会走到`set`，也就是不会走`trigger`）

> <!--解构是浅拷贝，所以嵌套的对象依然具备响应式特性-->
>
> ```js
> const { effect, reactive } = VueReactivity;
> 
> const state = reactive({ address: { num: 199 } })
> let person = { ...state }
> 
> effect(() => {
>   document.body.innerHTML = person.address.num
> })
> 
> setTimeout(() => {
>   person.address.num = 888 // 会触发更新，重新执行effect
> }, 1000)
> ```

为了解决这一问题，Vue提供`toRef` & `toRefs`这两个api，下面看下具体实现👇

```typescript
// packages/reactivity/src/ref.ts

/**
 * 对传入进来的ReactiveObj进行代理,将ReactiveObj[key]挂到value属性上
 * 这里不需要做响应式逻辑，因为ReactiveObj[key]本身就有响应式特性
 * 这里只是完成对ReactiveObj 的 attr的使用而已
 * 会走到ReactiveObj Proxy中的get和set
 */
class ObjectRefImpl {
  private __v_isRef = true;
  constructor(public object, public key) {}
  get value() {
    return this.object[this.key];
  }
  set value(newValue) {
    this.object[this.key] = newValue;
  }
}

export function toRef(object, key) {
  return new ObjectRefImpl(object, key);
}

/**
 * 遍历object，每个属性都生成一个ref
 */
export function toRefs(object) {
  let result = {};
  for (let key in object) {
    result[key] = toRef(object, key);
  }
  return result;
}
```

实现的逻辑很简单，==响应式丢失是因为使用的是新变量==，没有直接使用`ReactiveObj`，那做一层代理，通过`ref.value`直接访问`ReactiveObj`便可以了

==有了 `toRef` & `toRefs`便可以随意使用解构操作了==

```js
const { effect, reactive, ref, toRef, proxyRefs } = VueReactivity;

const state = reactive({ name: '张三', age: 30 })
let nameRef = toRef(state, 'name')

effect(() => {
  console.log('runner')
  document.body.innerHTML = nameRef.value + '今年' + ageRef.age + '岁了'
})

setTimeout(() => {
  nameRef.value = '李四'
}, 1000)
```

#### 2.7.3、`proxyRefs`实现

以上三个API`ref`、 `toRef` 、 `toRefs`，在使用`ref`对象时，都需要这样使用`ref.value`，这样未免有些==不够直观==，若是能够直接`ref[key]`岂不是更好，看下面👇实现

```typescript
/**
 * 做一层代理，若是ref对象，则直接使用value属性
 */
export function proxyRefs(object) {
  return new Proxy(object, {
    get(target, key, receiver) {
      let r = Reflect.get(target, key, receiver);
      return r.__v_isRef ? r.value : r;
    },
    set(target, key, value, receiver) {
      if (target[key].__v_isRef) {
        target[key].value = value;
        return true;
      }
      return Reflect.set(target, key, value, receiver);
    }
  });
}
```

==实现很简单，就是帮我们省掉访问`value`这一步==

看使用效果

```js
const { effect, reactive, ref, toRef, proxyRefs } = VueReactivity;

const state = reactive({ name: '张三', age: 30 })
let nameRef = toRef(state, 'name') // 使用value访问

let ageRef = proxyRefs({ age: toRef(state, 'age') }) // 使用key访问


effect(() => {
  console.log('runner')
  document.body.innerHTML = nameRef.value + '今年' + ageRef.age + '岁了'
})

setTimeout(() => {
  nameRef.value = '李四'
  ageRef.age = 31;
}, 1000)
```

### 三、Vue3响应式原理总结

- ==`reactive`适用于对象的响应式处理，非对象不能使用，因为不是对象的不能被proxy代理==
- ==`ref` 、`toRef` 、`toRefs` 适用于非对象类型数据的响应式处理（对象也可以），取值要使用`ref.value`的形式， 若不想使用`ref.value`可以采用`proxyRefs`代理取值==.
- `computed` 、 `watch` 都是基于`ReactiveEffect`
  - `computed`中是具备缓存的`dirty`, 依赖的值变化了会执行`effect`并更新`dirty`属性（ 计算属性会收集依赖）
  - `watch` 就是数据变化了触发内部的`scheduler`，提供`onCleanup`可以用来清理上次`watch`操作

