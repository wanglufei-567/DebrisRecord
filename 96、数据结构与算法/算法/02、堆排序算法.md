## 堆排序算法

### 一、前言

**「堆排序」**是一种基于「堆」数据结构的比较排序算法

核心思想：

* 将待排序数组构建成一个最大堆（或最小堆）
* 将堆顶元素（最大值）与末尾元素交换
* 重新调整剩余元素为堆结构
* 重复步骤2-3，直到所有元素排序完成

特点：

* 不稳定排序
* 原地排序

### 二、实现

### 2.1、堆化方法

堆化（heapify）是指将一组无序的数据调整成堆结构（满足堆的性质）的过程

```javascript

/**
 * 堆化操作
 * 确保 以某个节点为根 的子树满足堆的性质
 *
 * @param {Array} array - 要堆化的数组
 * @param {number} index - 当前要堆化的节点索引
 * @param {number} heapSize - 堆的大小
 * @param {Function} compareFn - 比较函数
 */
function heapify(array, index, heapSize, compareFn) {
  let element = index
  const left = 2 * index + 1
  const right = 2 * index + 2
  if (
    left < heapSize &&
    compareFn(array[element], array[left]) === Compare.BIGGER_THAN
  ) {
    element = left
  }
  if (
    right < heapSize &&
    compareFn(array[element], array[right]) === Compare.BIGGER_THAN
  ) {
    element = right
  }
  if (element !== index) {
    swap(array, index, element)
    heapify(array, element, heapSize, compareFn)
  }
}
```

执行过程：

* 先找出当前节点、左子节点、右子节点中的最大（小）值
* 如果最大（小）值不是当前节点，则与最大（小）值交换位置
* 递归地对交换后的位置继续执行堆化

**示例：**

输入数组：[4, 10, 3, 5, 1]

初始状态：

```markdown
        4
      /   \
     10    3
    / \
   5   1
```

执行 `heapify(0)` 后：

```markdown
        10
      /    \
     4      3
    / \
   5   1
```

#### 2.2、构堆

将一个无序数组整体堆化

```javascript
/**
 * 构建最大堆
 * 将一个数组构建为最大堆
 * @param {Array} array - 要构建最大堆的数组
 * @param {Function} compareFn - 比较函数
 */
function buildMaxHeap(array, compareFn) {
/**
 * 为什么从 Math.floor(array.length / 2) 开始？
 * 在完全二叉树中，索引大于 Math.floor(array.length/2) 的节点都是叶子节点
 * 叶子节点没有子节点，不需要进行堆化操作
 *
 * 最后一个非叶子节点的索引是 Math.floor(array.length/2) - 1
 * 但从 Math.floor(array.length/2) 开始遍历更简洁
 *
 * 因为：
 * 1、虽然多遍历了一个叶子节点，但 heapify 会立即返回
 * 2、不会影响最终结果，反而让代码更简洁
 */
  for (let i = Math.floor(array.length / 2); i >= 0; i--) {
    heapify(array, i, array.length, compareFn)
  }
}
```

构建最大堆过程：

* 从「**最后一个非叶子节点**」开始，执行堆化操作 

     <!--这个很重要，因为叶子节点没有子节点，不需要进行堆化-->

* 重复此过程直到根节点

    * ⚠️注意：构建最大堆后，数组并**不是完全有序的**
         * 只保证根节点是最大的
         * 只保证每个父节点大于其子节点
         * ==不保证同层节点之间的大小关系==
         * 要得到完全有序的数组，需要继续执行堆排序算法

**示例：**

输入数组：[4, 10, 3, 5, 1]

初始状态：

```markdown
       4
     /   \
     10    3
    / \
   5   1
```

执行过程：

* i = 2: 堆化节点 3（叶子节点，无操作）
* i = 1: 堆化节点 10 及其子树
* i = 0: 堆化节点 4 及其子树

最终结果：

```javascript
        10
      /    \
     5      3
    / \
   4   1
```

数组：[10, 5, 3, 4, 1]  <!--此时数组满足堆的性质，但未完全有序-->

### 2.3、堆排序

```javascript
/**
 * 堆排序算法
 * 将数组按照升序排列
 * @param {Array} array - 要排序的数组
 * @param {Function} compareFn - 比较函数
 * @returns {Array} - 排序后的数组
 */
function heapSort(array, compareFn = defaultCompare) {
  let heapSize = array.length

  // 构建最大堆，但未完全有序
  buildMaxHeap(array, compareFn)

  // 堆排序
  while (heapSize > 1) {
    heapSize--
    swap(array, 0, heapSize)
    // 堆化剩余元素，注意⚠️ 堆大小变了
    heapify(array, 0, heapSize, compareFn)
  }
  return array
}
```

堆排序过程：

1. 构建最大堆
    * 此时结果数组满足堆的性质，但并==不是完全有序的==
    * 只保证根节点是最大的，每个父节点大于其子节点
    * 不保证同层节点之间的大小关系
2. 堆排序
    * ==将根节点（最大值）与末尾元素交换== <!--这个是精髓-->
    * 对剩余部分重新堆化
    * 重复此过程直到所有元素都处理完

示例：

输入数组：[4, 10, 3, 5, 1]

第一步：构建最大堆

```markdown
        10
      /    \
     5      3
    / \
   4   1
```

数组：[10, 5, 3, 4, 1]   <!--此时数组满足堆的性质，但未完全有序-->

第二步：堆排序

1. 交换 10 和 1，堆化 [1, 5, 3, 4]
2. 交换 5 和 4，堆化 [4, 1, 3]
3. 交换 4 和 3，堆化 [3, 1]
4. 交换 3 和 1，完成

最终结果：[1, 3, 4, 5, 10]
