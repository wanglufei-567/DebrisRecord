## 二叉树相关算法

### 一、前言

**二叉树（Binary Tree）**：树中各个节点的度不大于 2 个的有序树，称为二叉树

通常树中的分支节点被称为 **「左子树」** 或 **「右子树」**二叉树的分支具有左右次序，不能随意互换位置

![image-20251120134023689](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/image-20251120134023689.png)

**二叉树**类型问题的解题思路：

- **遍历：是否可以通过遍历一遍二叉树得到答案？**

  - 二叉树「深度遍历」代码模板

    <!--一般需要使用一个 traverse 函数配合外部变量来实现-->

    ```javascript
    // 二叉树的遍历框架
    const traverse = function(root) {
        if (root === null) {
            return;
        }
        // 前序位置
        traverse(root.left);
        // 中序位置
        traverse(root.right);
        // 后序位置
    };
    ```

    前中后序遍历的区别:

    **「前序位置」**的代码在刚刚**进入一个二叉树节点的时候执行**

    **「中序位置」**的代码在一个二叉树节点左子树都遍历完，**即将开始遍历右子树的时候执行**

    **「后序位置」**的代码在将要**离开一个二叉树节点的时候执行**

    - **「后序位置」**处不仅可以获取到参数，还可以获取到左右子树的处理结果

    - 遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置处理 <!--有点像递归-->

    <img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/2.jpeg" alt="img" style="zoom: 25%;" />

  - 二叉树「广度遍历」代码模板

    ```javascript
    // 输入一棵二叉树的根节点，层序遍历这棵二叉树
    var levelTraverse = function(root) {
      if (root == null) return;
      
      // 维护一个栈
      var q = [root];
    
      var depth = 1;
      // 从上到下遍历二叉树的每一层
      while (q.length > 0) {
        // 这里用 size 保存栈长度很重要，写在 for 循环里会出问题
        var size = q.length;
        // 从左到右遍历每一层的每个节点，同时将当前节点的左右子节点压入栈
        for (var i = 0; i < size; i++) {
            var cur = q.shift();
    
            // 将下一层节点放入队列
            if (cur.left != null) {
                q.push(cur.left);
            }
            if (cur.right != null) {
                q.push(cur.right);
            }
        }
        depth++;
      }
    }
    ```
    
    两个循环：
    
    - 第一个 `while` 循环，只要栈里还有节点，就开启一轮循环，此时栈里的节点同属于一层
    - 第二个 `for` 循环，遍历栈里的所有节点并取出，同时依次将下一层的子节点压入栈，循环结束时，栈里保存的就是下一层的节点，以便开启下一轮  `while` 循环

- **分治：是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？**

  - 二叉树递归代码模板

    ```javascript
    const recursion = function(root) {
      // 基准情况
      if (root === null) {
            return;
      }
      // 子问题
      const leftRes = recursion(root.left)
      const rightRes = recursion(root.right)
      // 将子问题的结果合并成最终结果
      return fn(leftRes, rightRes)
    }
    ```


> **动态规划**/**DFS**/**回溯算法**都可以看做二叉树问题的扩展，只是它们的关注点不同：
>
> - **动态规划算法**属于「分解问题（分治）」的思路，它的关注点在整棵**「子树」**
> - **回溯算法**属于「遍历」的思路，它的关注点在节点间的**「树枝」**
> - **DFS 算法**属于「遍历」的思路，它的关注点在单个**「节点」**

「遍历」和「分治」的两种思路的区别：

- 遍历：没有返回值，靠更新外部变量来计算结果
- 分治：一般会有返回值，返回值是子问题的计算结果

### 二、翻转二叉树

**描述:**

给定一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/invert1-tree.jpg" alt="img" style="zoom:50%;" />

**示例:**

```markdown
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**题解 1:**

用「遍历」的思路解决，遍历到每一个节点的时候，交换其左右子节点，前中后序都可以

```javascript
// 主函数
var invertTree = function(root) {
    traverse(root);
    return root;
};

const traverse = function(root) {
    if (root == null) {
        return;
    }

    // 前序位置 
    // 每一个节点需要做的事就是交换它的左右子节点
    let tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 继续遍历左右子树的节点
    traverse(root.left);
    traverse(root.right);

}
```

解析：

- 创建一个 **traverse** 函数
- 遍历到每个节点的时候，交换其左右子节点
- 直到所有的节点都遍历到

**题解 2：**

用「分治」的思路解决，先解决子问题，再合并结果得到最终结果

```javascript
var invertTree = function(root) {
  if (root == null) {
      return root;
  }
    
  const left = invertTree(root.left)
  const right = invertTree(root.right)
  
  root.left = right
  root.right = left
  
  return root;
};
```

解析：先明确基准情况，再获取子问题结果，最后合并结果

### 三、填充每个节点的下一个右侧节点指针

**描述：**

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点，二叉树定义如下：

```java
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 `next` 指针，让这个指针指向其下一个右侧节点，如果找不到下一个右侧节点，则将 `next` 指针设置为 `NULL`，初始状态下，所有 `next` 指针都被设置为 `NULL`

**示例：**

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/116_sample.png" alt="img" style="zoom:50%;" />

```markdown
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点
如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束
```

**题解：**

通过「层序遍历」解决

```javascript
var connect = function(root) {
  if (!root) return root;

  // 维护一个栈
  const queue = [root];

  // 开始遍历栈里的节点
  while (queue.length > 0) {
    let size = queue.length;
    // 用于记录上一个节点
    let prev = null;
    // 从左到右遍历每一层的每个节点，同时将当前节点的左右子节点压入栈
    for (let i = 0; i < size; i++) {
      let node = queue.shift();
      // 左边的节点的 next 指针指向当前节点
      if (prev) {
        prev.next = node;
      }
      prev = node;
      // 将当前节点的左右子节点压入栈
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
  }

  return root;
};
```

**解析：**通过「层序遍历」可以完美的找到同一层的节点

### 四、将二叉树展开为链表

**描述：**

给定二叉树的根结点 `root` ，将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同

**示例：**

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/flaten.jpg" alt="img" style="zoom:50%;" />

```markdown
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**题解：**

最简单的做法是，创建一个新的链表，再通过前序遍历，依次将节点添加到链表上；

但此题要求原地展开，即不能创建新的链表，所以用「遍历」的思路就行不通了

尝试用「分治」的思路解决，假设某个节点的左右子树都已经拉平，那接下来只需要将左右子树连接起来即可

```javascript
var flatten = function(root) {
    // 定义：将以 root 为根的树拉平为链表
    // 基准情况
    if (root == null) return;

    // 利用定义，把左右子树拉平
    flatten(root.left);
    flatten(root.right);

    // 1、左右子树已经被拉平成一条链表
    var left = root.left;
    var right = root.right;

    // 2、将左子树作为右子树
    root.left = null;
    root.right = left;

    // 3、找到当前右子树（原来的左子树）的末尾节点，再将原先的右子树接到当前右子树的末端
    var p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
};
```

**解析：**

- 将左子树作为当前节点的右子树
- 再找到当前右子树的末尾节点，连接原来的右子树即可

### 五、构建最大二叉树

**描述：**

给定一个不重复的整数数组 `nums` ，**最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树

返回 `nums` 构建的**最大二叉树 **

**示例 ：**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/tree1.jpg)

```markdown
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
```

**题解：**

每个二叉树节点都可以认为是一棵子树的「根节点」，先构造根节点，再构建它的左右子树即可

```javascript
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
    if(nums.length === 0) return null

    // 先找大当前区间里面的最大值
    const max = Math.max(...nums)
    const index = nums.indexOf(max)

    // 用最大值构建 root 节点
    const root = new TreeNode(max)

    // 最大值左右区间再分别构建子树
    root.left = constructMaximumBinaryTree(nums.slice(0, index))
    root.right = constructMaximumBinaryTree(nums.slice(index+1, nums.length))

    return root
};
```

解析：

- 先遍历数组把找到最大值 `maxVal`，从而构建根节点 `root` 
- 然后对 `maxVal` 左边的数组和右边的数组进行递归构建，作为 `root` 的左右子树

### 六、反序列化二叉树

反序列化二叉树：给定遍历结果，还原原始二叉树

当二叉树中节点的值不存在重复时：

1. 序列化结果中**不包含空指针的信息**，且只给出**一种**遍历顺序，无法还原出唯一的一棵二叉树

2. 序列化结果中**不包含空指针的信息**，且会给出**两种**遍历顺序，分两种情况：

   2.1. 前序和中序，或者后序和中序，可以还原出唯一的一棵二叉树

   2.2. 前序和后序，无法还原出唯一的一棵二叉树

3. 序列化结果中**包含空指针的信息**，且只给出**一种**遍历顺序，也要分两种情况：

   3.1. 前序或者后序，可以还原出唯一的一棵二叉树

   3.2. 中序，无法还原出唯一的一棵二叉树

#### 6.1、从前序与中序遍历序列构造二叉树

**描述：**

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点

**示例 :**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/tree.jpg)

```markdown
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**题解：**

「先序遍历」和「中序遍历」的元素分布具备以下特点

- 先序遍历：[ 根 | 左子树 | 右子树 ]
  - 前序的第一个节点，就是根节点
- 中序遍历：[ 左子树 | 根 | 右子树 ]
  - 中序的根节点是在中间的位置，索引未知
  - 以根节点为界，左右子区间就是其左右子树

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/1-20251126165143133.jpeg)

- 已知 **preorder[0] 是根节点 root**，那么便可以在 **inorder** 中找到 **root** 的位置 **idx**

  - **inorder** 左侧部分 = 左子树的节点

  -  **inorder** 右侧部分 = 右子树的节点

- 根据左子树节点数量，划分左子树的 **preorder** 对应区域

  - 找到左子树的 **preorder**，同理，第一个元素就是左子树的根节点 **root**

- 递归构造子树

  <!--有点像二分法，不断的对原来的 inorder 进行划分为左右子树，再通过左右子树的节点数量，从 preorder 中找到左右子树各自的 preorder，然后再划分 inorder-->

- 同样的方式递归构造右子树即可

```javascript
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
  // 创建一个哈希表，用以保存中序结果的 value - key 的映射，用于后续左右子树的划分
  const indexMap = new Map()
  for(let i = 0; i < inorder.length; i++) {
    indexMap.set(inorder[i], i)
  }

  // 重要索引，每次递归中，树的根节点在原始前序结果中的索引
  let preIndex = 0
  const build = (left, right) => {
    if(left > right) return null

    // 找到根节点
    const rootVal = preorder[preIndex++]
    const root = new TreeNode(rootVal)

    // 找到根节点在中序结果中的索引
    const idx = indexMap.get(rootVal)

    // 中序结果中，以根节点为界，左右两侧的节点就是左右子树的节点
    // 分别构建左右子树
    root.left = build(left, idx - 1)
    root.right = build(idx + 1, right)

    return root
  }

  return build(0, inorder.length-1)
};
```

解析：

- 先构建 **inorder** 的 `value-key` 的映射
  - 用于后续根据 **inorder** 确认左右子树的区域
-  `preIndex` 是个重要的索引，构建时其实也是按照「前序遍历」的顺序进行子树的构建的
  - 前序的元素分布 [ 根, 左子树根,  左子树的左子树的根, ... 右子树的根  ]

#### 6.2、从中序与后序遍历序列构造二叉树

**描述：**

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的**中序遍历**， `postorder` 是同一棵树的**后序遍历**，请构造二叉树并返回其根节点

**示例 :**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/tree-20251126172746858.jpg)

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

**题解：**

「中序遍历」和「后序遍历」的元素分布具备以下特点

- 中序遍历：[ 左子树 | 根 | 右子树 ]
  - 中序的根节点是在中间的位置，索引未知
  - 以根节点为界，左右子区间就是其左右子树
- 后序遍历：[左子树 | 右子树 ｜根 ]
  - 前序的第一个节点，就是根节点

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/5.jpeg)

```javascript
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
  const indexMap = new Map()
  for(let i = 0; i < inorder.length; i++) {
    indexMap.set(inorder[i], i)
  }

  let postIndex = postorder.length -1
  const build = (left, right) => {
    if(left > right) return null

    const rootVal = postorder[postIndex--]
    const root = new TreeNode(rootVal)

    const idx = indexMap.get(rootVal)

    root.right = build(idx+1, right)
    root.left = build(left, idx-1)

    return root
  }
  return build(0, inorder.length - 1)
};
```

解析：和使用「前序」、「中序」构建的解法类似，只不过构建顺序改成后序遍历的倒序，即先构建右子树

#### 6.3、从前序与后序遍历序列构造二叉树

**描述：**

给定两个整数数组，`preorder` 和 `postorder` ，其中 `preorder` 是一个具有 **无重复** 值的二叉树的前序遍历，`postorder` 是同一棵树的后序遍历，重构并返回二叉树

如果存在多个答案，可以返回其中 **任何** 一个

**示例：**

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/lc-prepost.jpg)

```
输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出：[1,2,3,4,5,6,7]
```

**题解：**

「先序遍历」和「后序遍历」的元素分布具备以下特点

- 先序遍历：[ 根 | 左子树根 | 左子树的左子树根| 右子树 ]
  - 前序的第一个节点，就是根节点
- 后序遍历：[ 左子树的左子树根|左子树根 | 右子树 ｜根 ]
  - 前序的第一个节点，就是根节点

通过前序中序或者后序中序遍历结果构建二叉树，可以轻松通过中序结果，确认左右子树的区间

但通过前序后序遍历结果构建二叉树，就需要通过通过计算同一个节点在前序后序遍历结果中的位置来计算左右子树的区间

```javascript
/**
 * @param {number[]} preorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var constructFromPrePost = function(preorder, postorder) {
  const indexMap = new Map()
  for(let i = 0; i < postorder.length; i++) {
    indexMap.set(postorder[i], i)
  }

  const build = (preL, preR, postL, postR) => {
    if(preL > preR) return null
    // 当前区间只剩一个节点时，直接构造一个叶子节点返回
    if(preL === preR) return new TreeNode(preorder[preL])

    // 先构建根节点
    const root = new TreeNode(preorder[preL])

    // 再找到左子树的根节点
    const leftVal = preorder[preL+1]
    const idx = indexMap.get(leftVal)

    // 计算左子树的大小
    const leftSize = idx - postL + 1

    // 左子树的区间范围 前序：[preL + 1, preL + leftSize] 后序：[postL, idx]
    // preL 是根节点，不属于左子树，preL + 1 是左子树的根节点
    root.left = build(preL + 1, preL + leftSize, postL, idx)
    // 右子树的区间范围 前序：[preL + leftSize + 1, preR] 后序：[idx + 1, postR - 1]
    // postR 是根节点，不属于右子树
    root.right = build(preL + leftSize + 1, preR, idx + 1, postR - 1);

    return root
  }

  return build(0, preorder.length -1, 0, postorder.length -1)
};
```

解析：

```javascript
if(preL === preR) return new TreeNode(preorder[preL])
```

- 这段逻辑是关键，确保在当前区间只剩一个节点时，直接构造一个叶子节点返回
  - 不再有左右子树
  -  防止继续使用 `preL + 1` 从 **preorder** 读取越界

### 七、二叉树最近的公共祖先

**描述：**

给定一棵**不含重复值**的二叉树，以及**存在于树中的**两个节点 `p` 和 `q`，计算 `p` 和 `q` 的最近公共祖先节点

比如输入这样一棵二叉树：

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/2-20251209195225513.jpg" alt="img" style="zoom:50%;" />

如果 `p` 是节点 `6`，`q` 是节点 `7`，那么它俩的 `LCA` 就是节点 `5`：

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/3.jpg" alt="img" style="zoom:50%;" />

当然，`p` 和 `q` 本身也可能是 `LCA`，比如这种情况 `q` 本身就是 `LCA` 节点：

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/4.jpg" alt="img" style="zoom:50%;" />

两个节点的最近公共祖先其实就是这两个节点向根节点的「延长线」的交汇点，那么对于任意一个节点，它怎么才能知道自己是不是 `p` 和 `q` 的最近公共祖先？

**如果一个节点能够在它的左右子树中分别找到 `p` 和 `q`，则该节点为 `LCA` 节点**

**题解：**

```javascript
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  // 若当前节点是给定节点或者 null 就结束递归
  // 情况 1：遍历到底了
  // 情况 2：找到目标节点了
  if(root === null || root === p || root === q) {
    return root
  }

  // 去左右子树中找给定的两个节点
  const left = lowestCommonAncestor(root.left, p, q)
  const right = lowestCommonAncestor(root.right, p, q)

  // 若当前节点的左右子树分别找到了给定的两个节点，说明当前节点就是 LCA
  // 因为这里采用的是后序遍历，当前节点是离给定两个节点最近的祖先节点
  if(left && right) {
    return root
  }

  // 若是只找到一个，说明当前节点不是 LCA 需要将找到的节点往上返回
  return left || right
};
```

**解析：**

- 为什么是“后序遍历”？
  - 因为 **LCA** 的判断依赖左右子树的返回值
  - 父节点要 **等左右都处理完** 才能判断是否为 **LCA**，所以必须是 **后序**（左 → 右 → 根）
- 关键判断
  - 如果当前节点就是目标节点
    - 直接返回当前节点
  - 递归左右子树，得到结果：
    - `left = dfs(root.left)`
    - `right = dfs(root.right)`
      - **如果 left 和 right 都非空**
        - 说明目标节点分别在左右子树
        - 当前节点就是它们的 **LCA**
      - **如果只有一侧非空**
        - 返回非空的那一侧（表示该侧找到了目标节点 或 **LCA**）
      - **两侧都空**
        - `return null`（完全没找到）

### 八、二叉搜索树升序遍历

二叉搜索树的任意节点的左子树所有值都小于该节点，右子树所有值都大于该节点，所以二叉搜索树的**「中序遍历」**结果是有序的且是**升序的**

**描述：**

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）

**示例 ：**

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/kthtree1.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**题解：**

```javascript
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function(root, k) {
    let res
    let index = 0

    const traverse = (root) => {
      if(root === null) return null
      traverse(root.left)
      index++
      if(index === k) {
        res = root.val
        return
      }
      traverse(root.right)
    }

    traverse(root)
    return res
};
```

### 九、验证二叉搜索树

**描述：**

给定一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树

**题解：**

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {

  function valid( root, min, max) {
    if(root === null) return true
    // 保证当前值受到约束
    if(min !== null && root.val <= min) return false
    if(max !== null && root.val >= max) return false

    // 将父节点的约束往下传递，并更新子节点的约束
    return valid(root.left, min, root.val) && valid(root.right, root.val, max)
  }

  return valid(root, null, null)
};
```

**解析：**

- 一个节点只能直接约束自己的左右子节点，将约束条件继续往下传递，才能保证更深的节点受到最上层父节点的约束

