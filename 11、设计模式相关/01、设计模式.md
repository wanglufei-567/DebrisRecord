

# 设计模式

### 前言

**什么是设计模式？**

> 设计模式 Design Pattern 的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案

通俗的一点说，==设计模式是在某种场合下对某个问题的一种解决方案==，再通俗点一点说，设计模式就是给开发过程中一些好的设计取个名字

在软件设计中，一个好的设计方案有了名字之后，才能更好的传播，人们才有更多的机会去分享和学习它们

------

**为什么要学习设计模式**：

好的程序具有以下四个特征

- **==易维护==**
- **==易拓展==**
- **==易复用==**
- **灵活性好**

怎么去理解这四个特征呢？以活字印刷为例：

- 易维护 ➡️ 当要修改文字的时候只需替换对应的字模即可，不需大改动
- 易拓展 ➡️ 新增文字只需另外刻字加入字模即可
- 易复用 ➡️ 字模可以在印刷不同的文章时复用
- 灵活性好 ➡️ 字模排版无论是横排还是竖排只需移动字模即可

学习设计模式的目的就是帮助我们写出易维护、以拓展、易复用、灵活性好的程序。

<!--设计模式的核心就是 解耦 将变化的逻辑和不变的逻辑封装隔离-->

------

**JavaScript中的设计模式：**

> 《设计模式》这本书最初是讲的静态类型语言中的设计模式，==但设计模式实际上是解决某些问题的一种思想，与具体使用的语言无关==
>
> JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承
>
> JavaScript也没有在语言层面提供对抽象类和接口的支持
>
> 正因为存在这些==与传统面向对象语言不一致==的地方，我们在使用设计模式编写代码的时候，更要跟传统面向对象语言加以区别

------

**设计模式的核心原则：**

> 所有的设计模式的实现都遵循一条原则，即“==找出程序中变化的部分，并将变化封装起来”==
>
> 一个程序的设计总是可以分为==可变的部分==和==不可变的部分==，当我们找出可变的部分，并把这些部分分装起来，那么==剩下的就是不变和稳定的部分==，这些不变和稳定的部分是非常==容易复用的==

------

**如何合理使用设计模式：**

> 设计模式被人误解的一个重要原因是人们对它的==误用和滥用==，在不该使用模式的地方刻意使用模式，有个很==经典的锤子理论：当我们有了一把锤子，看什么都是钉子==
>
> 有很多设计模式的类图和结构很相似，但这并不重要，==辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题==
>
> 有种理论叫做“鸭子类型”，通俗的说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子”

## 一、设计模式原则

### 1.1 SOLID五大设计原则

| 首字母 |         指代         | 概念                                                         |
| :----- | :------------------: | :----------------------------------------------------------- |
| S      | **==单一职责原则==** | ==单一功能原则认为对象应该仅具有一种***单一功能***的概念==   |
| O      | **==开放封闭原则==** | ==开闭原则认为“***软件体应该是对于扩展开放的，但是对于修改封闭的***”的概念== |
| L      |     里氏替换原则     | 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念<br />参考契约式设计 |
| I      |     接口隔离原则     | 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。 |
| D      |     依赖反转原则     | 依赖反转原则认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念<br />依赖注入是该原则的一种实现方式 |

- **S 单一职责原则 Single responsibility principle**
  - 一个程序只做好一件事
  
  - 如果功能特别复杂就进行拆分
  
- **O 开放封闭 Open Closed Principle**
  - 对扩展开放，对修改关闭
  
  - 增加需求时，扩展新代码，而非修改已有代码
  - 这是软件设计的终极目标
  
-  **L 里氏替换原则 Liskov Substitution Principle**

  - 子类能覆盖父类

  - 父类能出现的地方子类就能出现
  - JS使用比较少

- **I 接口隔离原则 Interface Segregation Principle**

  - 保持接口的单一独立，避免出现胖接口

  - JS中没有接口，使用较少
  - 类似于单一职责原则，更关注接口

- **D 依赖倒置原则 Dependence Inversion Principle**

  - 面向接口编程，依赖于抽象而不依赖于具体实现

  - 使用方只关注接口而不关注具体类的实现
  - JS中使用较少 <!--没有接口，弱类型，但是依赖控制的思想可以借鉴，React中的将组件作为props传递就是一种控制反转-->


### 1.2 迪米特法则 Law of Demeter，LOD

有时候也叫做==最少知识原则==，一个软件实体应当尽可能少地与其它实体发生相互作用

迪米特法则的初衷在于降低类之间的耦合，类定义时尽量要实现内聚,少使用`public`修饰符，尽量使用`private`、`protected` 等

![Demeter](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/6.Demeter.png)

### 1.3 合成复用原则

#### 1.3.1 类的关系

- 类之间有三种基本关系，分别是关联(聚合和组合)、泛化和依赖
- 如果一个类单向依赖另一个类，那么它们之间就是单向关联。如果彼此依赖,则为相互依赖,即双向关联
- 关联关系包括两种特例：聚合和组合
  - 聚合，用来表示整体与部分的关系或者`拥有`关系，代表部分的对象可能会被整体拥有，但并不定定会随着整体的消亡而销毁，比如班级和学生
  - 合成或者说组合要比聚合关系强的多，部分和整体的生命周期是一致的，比如人和器官之间

![composite](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/7.composite.png)

#### 1.3.2 合成复用原则

- 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的
- 新对象可以调用已有对象的功能，从而达到复用
- 原则是尽量首先使用组合/聚合的方式，而不是使用继承
- 专业人做专业事

### 1.4 总结

- ==**开闭原则**是核心，对修改关闭，对扩展开放是软件设计的基石==
- ==**单一职责**要求我们设计接口和模块功能的时候尽量保证单一性和原子性，修改一条不影响全局和其它模块==
- 里氏替换原则和依赖倒置原则要求面向接口和抽象编程,不要依赖具体实现，否则实现一改，上层调用者就要对应修改

==原则只是一种指导，没有哪条原则是在实际开发中必须遵守的==

## 二、设计模式分类

### 2.1设计模式分类

根据设计模式的**用途**，设计模式可分为**创建型(Creational)**，**结构型(Structural)**和**行为型(Behavioral)**三种

- ==**创建型模式(Creational Pattern)**==：主要用于描述如何==**创建**对象==，对类的实例化过程进行了抽象，能够将模块中**对象的创建和对象的使用分离**

  为了使结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则

  1. 工厂模式(工厂方法模式、抽象工厂模式、简单工厂模式)  <!--重要-->
  2. 建造者模式 <!--重要-->
  3. 单例模式 <!--重要-->
  4. 原型模式

- ==**结构型模式(Structural Pattern)**==：主要用于描述如何实现类或==对象的**组合**==，描述如何**将类或者对象结合在一起形成更大的结构**

  就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构

  1. 适配器模式 <!--重要-->
  2. 装饰器模式 <!--重要-->
  3. 代理模式 <!--重要-->
  4. 外观模式
  5. 桥接接模式  <!--重要-->
  6. 组合模式
  7. 享元模式

- ==**行为型模式(Behavioral Pattern)**==：主要用于描述==类或对象怎样**交互**==以及怎样分配职责，是对在**不同的对象之间划分责任和算法的抽象化**

  - 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用
  - 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互
  
  1. 策略模式 <!--重要-->
  2. 模版方法模式 <!--重要-->
  3. 观察者模式 <!--重要-->
  4. 迭代器模式
  5. 职责链模式 <!--重要-->
  6. 命令模式
  7. 备忘录模式
  8. 状态模式 <!--重要-->
  9. 访问者模式
  10. 中介者模式
  11. 解释器模式

## 三、23种设计模式

### 3.1 简单工厂模式

==**简单工厂（Simple Factory）**是一种**创建型**设计模式==，它提供了一个简单的接口来实例化不同的对象，而不需要暴露对象的创建逻辑。简单工厂通过一个工厂类，==根据输入参数来创建相应的对象==，并返回给调用者

简单工厂模式并不遵循***开放封闭***原则，每次新增一种产品类就需要去修改工厂

<!--工厂可以是个类也可以是个方法（讲道理类不也是个方法嘛，只不过返回值是个对象），这种模式的核心思想是解耦，即具体的逻辑实现不与业务代码耦合，业务代码只和工厂交互，通过工厂拿到具体的逻辑实现-->

#### 3.1.1 类图

![simplefactory](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192757_d81529bf_1720749.jpeg)

#### 3.1.2 代码

```js
// 简单工厂函数
function createProduct(type) {
  let product;

  // 根据类型创建不同的产品对象
  if (type === 'A') {
    product = new ProductA();
  } else if (type === 'B') {
    product = new ProductB();
  } else if (type === 'C') {
    product = new ProductC();
  } else {
    throw new Error('无效的产品类型');
  }

  return product;
}

// 产品类A
class ProductA {
  constructor() {
    this.name = 'Product A';
  }

  // 其他方法
}

// 产品类B
class ProductB {
  constructor() {
    this.name = 'Product B';
  }

  // 其他方法
}

// 产品类C
class ProductC {
  constructor() {
    this.name = 'Product C';
  }

  // 其他方法
}

// 使用简单工厂创建产品对象
const productA = createProduct('A');
console.log(productA.name); // 输出: Product A

const productB = createProduct('B');
console.log(productB.name); // 输出: Product B

const productC = createProduct('C');
console.log(productC.name); // 输出: Product C

```

在这个例子中，`createProduct` 函数作为简单工厂，==根据输入的产品类型参数来创建相应的产品对象，并返回给调用者==

调用者只需要传入产品类型参数，而不需要关心产品对象的创建细节。这样可以==实现对象的创建和调用者的解耦==，使得代码更加灵活和可维护。

#### 3.1.3 经典场景

**React**中创建虚拟**DOM**

```js
let h1 = <h1 className="title">hello</h1>;
let h1 = React.createElement('h1', { className: 'title' }, 'hello');
//h1就是虚拟DOM
class Vnode{
    constructor(tag,attrs,children){
        this.tag = tag;
        this.attrs = attrs;
        this.children = children;
    }
}
React.createElement = function(tag,attrs,children){
  return new Vnode(tag,attr,children);
}
```

#### 3.1.4、简单工厂、工厂方法、抽象工厂的区别

**简单工厂模式**、**工厂方法模式**和**抽象工厂模式**都属于**创建型**设计模式，用于创建对象，但它们之间有以下区别：

1. **简单工厂模式（Simple Factory Pattern**）：简单工厂模式通过一个工厂类，根据输入参数来创建相应的对象
   - 工厂类负责对象的创建，调用者只需要传入参数，无需关心对象的创建细节。
   - ==简单工厂模式适用于**对象创建逻辑相对简单的场景**，但缺点是当需要添加新的产品时，需要修改工厂类的代码，违反了开闭原则==
2. **工厂方法模式（Factory Method Pattern**）：工厂方法模式通过定义一个抽象的工厂类，让子类来决定创建哪个具体的产品对象
   - 每个产品都有一个对应的工厂类，负责创建该产品的实例
   - 工厂方法模式通过增加新的产品类只需要新增对应的工厂类，不需要修改现有的工厂类，符合开闭原则
3. **抽象工厂模式（Abstract Factory Pattern）**：抽象工厂模式提供了一种将一组相关的产品对象的创建封装起来的方式
   - 抽象工厂定义了一个接口或者抽象类，包含了多个工厂方法，每个工厂方法负责创建一种产品的实例。
   - 不同的具体工厂类实现了抽象工厂接口，负责创建不同产品族的产品
   - 抽象工厂模式适用于创建一组相关的产品对象，例如创建不同操作系统的界面风格（Windows、Mac、Linux等），可以通过切换不同的抽象工厂来创建不同风格的界面。

简而言之，

- 简单工厂模式适用于简单的对象创建场景
- 工厂方法模式适用于需要更灵活和可扩展的对象创建场景
- 抽象工厂模式适用于创建一组相关的产品对象场景

### 3.2 工厂方法模式

- 工厂方法模式，又称多态性工厂模式
- 在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做

#### 3.2.1 类图

![factorymethod](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192757_4be3dac2_1720749.jpeg)

#### 3.2.2 代码

```js
class Plant{
    constructor(name) {
        this.name=name;
    }
    grow() {
        console.log('growing~~~~~~');    
    }
}
class Apple extends Plant{
    constructor(name) {
        super(name);
        this.taste='甜';
    }
}
class Orange extends Plant{
    constructor(name) {
        super(name);
        this.taste='酸';
    }
}
class AppleFactory{
    create() {
        return new Apple();
    }
}
class OrangeFactory{
    create() {
        return new Orange();
    }
}
const settings={
    'apple': AppleFactory,
    'orange':OrangeFactory
}
let apple=new settings['apple']().create();
console.log(apple);
let orange=new settings['orange']().create();
console.log(orange);
```

### 3.3 抽象工厂模式

- 抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式
- 抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象

#### 3.3.1 类图

![abstractfactory](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192757_7dc3c74a_1720749.jpeg)

#### 3.3.2 代码

```js
class Button{
    render() {

    }
}
class AppleButton{
    render() {
       console.log('苹果按钮');
    }
}
class WindowButton{
    render() {
       console.log('Windows按钮');
    }
}

class Icon{
    render() {

    }
}
class AppleIcon{
    render() {
       console.log('苹果图标');
    }
}
class WindowIcon{
    render() {
       console.log('Windows图标');
    }
}
class Factory{
    createButton() {}
    createIcon() {}
}
class AppleFactory{
    createButton() {
        return new AppleButton();
    }
    createIcon() {
        return new AppleButton();
    }
}
class WindowsFactory{
    createButton() {
        return new WindowButton();
    }
    createIcon() {
        return new WindowIcon();
    }
}
const settings={
    'apple': AppleFactory,
    'windows':WindowsFactory
}
let appleFactory=new settings['apple']();
appleFactory.createButton().render();
appleFactory.createIcon().render();

let windowsFactory=new settings['windows']();
windowsFactory.createButton().render();
windowsFactory.createIcon().render();
```

<!-- 简单工厂：一般就是一个函数返回产品的实例；工厂方法：多了工厂类，要想创建产品，需要先创建此工厂的实例，再通过此工厂来创建产品；在抽象工厂中：一个工厂可以创建多种产品-->

### 3.4 单例模式

#### 3.4.1 类图

![img](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/singleobject.jpg)

#### 3.4.2 代码

##### 3.4.2.1 typescript

```js
class Window {
    constructor(name) {
        this.name = name;
    }
    static getInstance(name) {
        if (!this.instance) {
            this.instance = new Window(name);
        }
        return this.instance;
    }
}

var w1 = Window.getInstance();
var w2 = Window.getInstance();
console.log(w1 === w2);
```

##### 3.4.2.2 ES5单例模式

```js
let  Window = function(name) {
    this.name=name;
}
Window.prototype.getName=function () {
    console.log(this.name);
}
Window.getInstance=(function () {
    let window=null;
    return function (name) {
        if (!window)
           window=new Window(name);
        return window;
    }
})();
let window=Window.getInstance('zfpx');
window.getName();
```

##### 3.4.2.3 透明单例

```js
let Window=(function () {
    let window;
    let Window=function (name) {
        if (window) {
            return window;
        } else {
            this.name=name;
            return (window=this);
        }
    }
    Window.prototype.getName=function () {
        console.log(this.name);
    }
    return Window;
})();

let window1=new Window('zfpx');
let window2=new Window('zfpx');
window1.getName();
console.log(window1 === window2)
```

##### 3.4.2.4 单例与构建分离

```js
function Window(name) {
    this.name=name;
}
Window.prototype.getName=function () {
    console.log(this.name);
}

let createSingle=function (Constructor) {
    let instance;
    return function (args) {
        if (!instance) {
            instance = new Constructor(args)
        }
        return instance;
    }
};
let CreateWindow=createSingle(Window);
let window1=new CreateWindow('zfpx');
let window2=new CreateWindow('zfpx');
window1.getName();
console.log(window1 === window2)
```

#### 3.4.3 场景

##### 3.4.3.1 jQuery

```js
if(window.jQuery!=null){
  return window.jQuery;
}else{
    //init~~~~~~~

```

##### 3.4.3.2 store

```js
// 只有一个store，只有一个state
function createStore(reducer) {
    let state;
    let listeners=[];
    function getState() {
        return state;
    }
    function dispatch(action) {
        state=reducer(state,action);
        listeners.forEach(l=>l());
    }
    function subscribe(listener) {
        listeners.push(listener);
        return () => {
            listeners = listeners.filter(item => item!=listener);
            console.log(listeners);
        }
    }
    dispatch({});
    return {
        getState,
        dispatch,
        subscribe
    }
}
let store = createStore();
```

### 3.5 适配器模式

- 旧的接口和使用者不兼容
- 中间加一个适配器转换接口

![adaptor](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192757_60d9b4d0_1720749.jpeg)

#### 3.5.1 类图

![adapter](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_7cb9542a_1720749.jpeg)

#### 3.5.2 代码

```js
class Power{
    charge() {
        return '220V';
    }
}

class Adapter{
    constructor() {
        this.power=new Power();
    }
    charge() {
        let power=this.power.charge();
        return `${power} => 12V`;
    }
}

class Client{
    constructor() {
        this.adapter=new Adapter();
    }
    use() {
        console.log(this.adapter.charge());
    }
}
new Client().use();
```

#### 3.5.3 场景

##### 3.5.3.1 computed

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://cdn.bootcss.com/vue/2.5.17/vue.js"></script>
    <title>vue</title>
</head>
<body>
<div id="root">
<p>{{name}}</p>
<p>{{upperName}}</p>
</div>    
<script>
let vm=new Vue({
    el: '#root',
    data: {
        name:'zfpx'
    },
    computed: {
        upperName() {
            return this.name.toUpperCase();
        }
    }
});
</script>
</body>
</html>
```

### 3.6 装饰器模式

- 在不改变其原有的结构和功能为对象添加新功能
- 装饰比继承更加灵活

> **装饰器模式**的一个常见例子是咖啡店的咖啡制作。假设你去咖啡店，点了一杯基础的美式咖啡，这就是一个基础对象。然后，你可能想要在这杯咖啡上加一些东西，比如牛奶、糖、摩卡、奶泡等，这些就是装饰器。
>
> 每添加一个装饰器，咖啡的味道就会有所改变。这就是装饰器模式的精髓，即在==不改变原有对象的基础上，通过添加装饰器来增加对象的功能==

![装饰设计模式](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202405171024703.png)

#### 3.6.1 类图

![decorator](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_4ef3d187_1720749.png)

#### 3.6.2 代码

```js
class Duck{
    eat(food) {
        console.log('吃${food}');
    }
}

class TangDuck{
    constructor() {
        this.duck=new Duck();
    }
    eat() {
        this.duck.eat();
        console.log('谢谢');
    }
}
```

#### 3.6.3 包装器

装饰器模式是将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。请求随着这条链条依次传递到所有的对象，每个对象有处理这个请求的机会。

```js
class Coffee{
  make(water){
    return `${water}+咖啡`;
  }
  cost(){
      return 10;
  }
}

class MilkCoffee{
    constructor(parent){
        this.parent = parent;
    }
    make(water){
        return `${this.parent.make(water)}+牛奶`;
    }
    cost(){
        return this.parent.cost()+1;
    }
}

class SugerCoffee{
    constructor(parent){
        this.parent = parent;
    }
    make(water){
        return `${this.parent.make(water)}+糖`;
    }
    cost(){
        return this.parent.cost()+2;
    }
}
let coffee = new Coffee();
let milkCoffee = new MilkCoffee(coffee);
let milksugerCoffee = new SugerCoffee(milkCoffee);
console.log(milksugerCoffee.make('水')+'='+milksugerCoffee.cost());
```

#### 3.6.4 AOP

- 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程
- 可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术

![springaop](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_281046e5_1720749.jpeg) ![businessaop](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_c7aedff9_1720749.jpeg)

```js
Function.prototype.before = function (beforeFn) {
  // before 被buy调用，因此this指向buy这个函数
  let _this = this;
  return function () {
    beforeFn(arguments);
    return _this(arguments);
  };
};
Function.prototype.after = function (afterFn) {
  let _this = this;
  return function () {
    _this(arguments);
    afterFn(arguments);
  };
};
function buy(money, goods) {
  console.log(`花${money}买${goods}`);
}

buy = buy.before(function () {
  console.log(`向媳妇申请1块钱.`);
});

buy = buy.after(function () {
  console.log(`把剩下的2毛钱还给媳妇.`);
});
buy(0.8, '盐');
// 向媳妇申请1块钱
// 花0.8买盐
// 把剩下的2毛钱还给媳妇
```

#### 3.6.5 场景

##### 3.6.5.1 埋点

埋点分析，是网站分析的一种常用的数据采集方法

- 埋点方式
  - 服务器层面的：主要是通过客户端的请求进行分析
  - 客户端层面的：通过埋点进行相应的分析
    - 代码埋点
    - 自动化埋点：通过AOP思想对相应的方法进行统计
    - 第三方实现 百度、友盟等...

```html
<body>
    <button data-name="西瓜" id="watermelon">西瓜</button>
    <button data-name="苹果" id="apple">苹果</button>
<script>
 let watermelon = document.getElementById('watermelon');
 let apple = document.getElementById('apple');
 Function.prototype.after = function(afterFn){
    let _this = this;
    return function(){
         _this.apply(this,arguments);
        afterFn.apply(this,arguments);
    }
}

 function click(){
     console.log('点击'+this.dataset.name);
 }
 click = click.after(function(){
     let img = new Image();
     img.src = `http://localhost:3000?name=${this.dataset.name}`;
 });
 Array.from(document.querySelectorAll('button')).forEach(function(button){
    button.addEventListener('click',click);
 });
let express = require('express');
let app = express();
app.get('/',function(req,res){
   console.log('name',req.query.name);
   res.end('ok');
});
app.listen(3000);
```

##### 3.6.5.2 表单校验

```html
<body>
    <form action="">
        用户名<input type="text" name="username" id="username">
        密码<input type="text" name="password" id="password">
        <button id="submit-btn" >提交</button>
    </form>
    <script>
         Function.prototype.before = function(beforeFn){
            let _this = this;
            return function(){
                let ret = beforeFn.apply(this,arguments);
                if(ret)
                _this.apply(this,arguments);
            }
        }
      function submit(){
          alert('提交表单');
      }
      submit= submit.before(function(){
          let username = document.getElementById('username').value;
          if(username.length<6){
              return alert('用户名不能少于6位');
          }
          return true;
      });
      submit = submit.before(function(){
          let username = document.getElementById('username').value;
          if(!username){
              return alert('用户名不能为空');
          }
          return true;
      });


      document.getElementById('submit-btn').addEventListener('click',submit);
```

### 3.7 代理模式

- 由于一个对象不能直接引用另外一个对象，所以需要通过代理对象在这两个对象之间起到中介作用

- 可以在使用者和目标对象之间加一个代理对象,通过代理可以实现控制

  

- 代理模式 VS 适配器模式 适配器提供不同接口，代理模式提供一模一样的接口

- 代理模式 VS 装饰器模式 装饰器模式原来的功能不变还可以使用，代理模式改变原来的功能

#### 3.7.1 类图

![proxy](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_e26dc7bc_1720749.jpeg)

#### 3.7.2 代码

```js
class Goole{
    constructor() {    }
    get() {
        return 'google';
    }
}

class Proxy {
    constructor() {
        this.google=new Goole();
    }
    get() {
        return this.google.get();
    }
}
let proxy = new Proxy();
let ret = proxy.get();
console.log(ret);
```

#### 3.7.3 场景

##### 3.7.3.1 代理缓存 [#](http://www.zhufengpeixun.com/strong/html/53.design.html#t898.3.5 代理缓存)

缓存代理可以为开销大的计算结果提供暂时的存储

```js
0!=1，n!=(n-1)!×n
```

```js
// 没有使用代理
let m = function (n) {
    if (n<=1) {
        return 1;
    } else {
        return n*m(n-1);
    }
}
function sum(n) {
    let result=0;
    for (let i=1;i<=n;i++){
        result+=m(i);
    }
    return result;
}
console.log(sum(4));
```

```js
// 使用代理
let m = function (n) {
    if (n<=1) {
        return 1;
    } else {
        return n*m(n-1);
    }
}
let sum=(function () {
    let cache={};
    return function sum(n) {
        let result=0;
        for (let i=1;i<=n;i++){
            let r=cache[i];
            if (r) {
                result+=r;
            } else {
                r=m(i);
                cache[i]=r;
                result+=r;
            }
        }
        return result;
    }
})()

console.log(sum(4));
```

##### 3.7.3.2 Proxy

- Proxy 用于修改某些操作的默认行为
- Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

```js
let wang={
    name: 'wangy',
    age: 29,
    height:165
}
let wangMama=new Proxy(wang,{
    get(target,key) {
        if (key == 'age') {
            return wang.age-1;
        } else if (key == 'height') {
            return wang.height+5;
        }
        return target[key];
    },
    set(target,key,val) {
        if (key == 'boyfriend') {
            let boyfriend=val;
            if (boyfriend.age>40) {
                throw new Error('太老');
            } else if (boyfriend.salary<20000) {
                throw new Error('太穷');
            } else {
                target[key]=val;
                return true;
            }
        }
    }
});
console.log(wangMama.age);
console.log(wangMama.height);
wangMama.boyfriend={
    age: 41,
    salary:3000
}
```

###  3.8 外观模式

该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用

- 门面角色：外观模式的核心
  - 它被客户角色调用，它熟悉子系统的功能
  - 内部根据客户角色的需求预定了几种功能的组合
- 子系统角色：实现了子系统的功能
  - 它对客户角色和Facade时未知的
- 客户角色:通过调用Facede来完成要实现的功能

![facade22](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_281c9c59_1720749.jpeg)

#### 3.8.1 类图

![facade](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_519053fe_1720749.jpeg)

#### 3.8.2 代码

```js
class Sum{
    sum(a,b) {
        return a+b;
    }
}
class Minus{
    minus(a,b) {
        return a-b;
    }
}
class Multiply{
    multiply(a,b) {
        return a * b;
    }
}
class Calculator{
    constructor() {
        this.sumObj=new Sum();
        this.minusObj=new Minus();
        this.multiplyObj=new Multiply();
    }
    sum(...args) {
        this.sumObj.sum(...args);
    }
    minus(...args) {
        this.minusObj.minus(...args);
    }
    multiply(...args) {
        this.multiplyObj.multiply(...args);
    }
}
let calculator=new Calculator();
calculator.sum(1,2);
calculator.minus(1,2);
calculator.multiply(1,2);
```

#### 3.8.2.3 场景

- 为复杂的模块或子系统提供外界访问的模块
- 子系统相互独立

##### 3.8.2.3.1 redux

- [redux](https://github.com/reduxjs/redux/blob/master/src/index.js)

### 3.9 观察者模式

- 被观察者供维护观察者的一系列方法
- ==观察者提供更新接口==
- **==观察者把自己注册到被观察者里==**
- ==**在被观察者发生变化时候，调用观察者的更新方法**==

#### 3.9.1 类图

- 主题对象(Subject) 该角色又称为被观察者,可以增加和删除观察者对象,它将有关状态存入具体观察者对象，在具体主题的内部状态改变时，给所有登记过(关联了观察关系)的观察者发出通知
- 观察者(Observer)角色：定义一个接收通知的接口(update),在得到主题的通知时更新自己

![observer](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_7fdaa324_1720749.jpeg)

#### 3.9.2 代码

```js
/* 观察者模式的特征就是观察者和被观察者耦合在一起的，被观察者进行消息通知时要调用观察者的更新方法 */
class Star{
    constructor(name) {
        this.name=name;
        this.state='';
        this.observers=[];
    }
    getState() {
        return this.state;
    }
    setState(state) {
        this.state=state;
        this.notifyAllObservers();
    }
    attach(observer) {
        this.observers.push(observer);
    }
    notifyAllObservers() {
        this.observers.forEach(observer=>observer.update());
    }
}
class Fan{
    constructor(name,subject) {
        this.name=name;
        this.subject=subject;
        this.subject.attach(this);
    }
    update() {
        console.log(`${this.subject.name}有新的状态-${this.subject.getState()},${this.name}正在更新`);    
    }
}
let star=new Star('赵丽颖');
let fan1=new Fan('姜老师',star);
star.setState('结婚');
```

#### 3.9.3 场景

##### 3.9.3.1 node中的events模块

自定义事件

```js
const EventEmitter=require('./events');
let subject=new EventEmitter();
subject.on('click',function (name) {
    console.log(1,name);
});
subject.on('click',function (name) {
    console.log(2,name);
});
subject.emit('click','zfpx');
```

```js
class EventEmitter{
    constructor() {
        this._events={};
    }
    on(type,listener) {
        let listeners=this._events[type];
        if (listeners) {
            listeners.push(listener);
        } else {
            this._events[type]=[listener];
        }
    }
    emit(type) {
        let listeners=this._events[type];
        let args=Array.from(arguments).slice(1);
        listeners.forEach(listener => listener(...args));
    }
}
module.exports = EventEmitter;
```

##### 3.9.3.2  生命周期以及vue watch

![vuelifecycle](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_ac466dd3_1720749.jpeg)

```js
<body>
<div id="root">
      <p>FullName: {{fullName}}</p>
      <p>FirstName: <input type="text" v-model="firstName"/></p>
      <p>LastName: <input type="text" v-model="lastName"/></p>
</div>
<script src="https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.min.js"></script>
<script>
new Vue({
  el:'#root',
  data: {
    firstName:'张',
    lastName: '三',
    fullName:'张三'
  },
  watch: {
    firstName(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    }
  } 
})
</script>
```

#### 3.9.4发布订阅模式

##### 3.9.4.1 区别

***观察者模式*** 和 ***发布订阅模式*** 的区别：

- ==订阅者把自己想订阅的事件注册到调度中心==
- ==当该事件触发时候，发布者发布该事件到调度中心,由调度中心统一调度订阅者注册到调度中心的处理代码==
- 虽然两种模式都存在订阅者和发布者（观察者可认为是订阅者、被观察者可认为是发布者）
- ==但是观察者模式是由被观察者调度的，而发布/订阅模式是统一由调度中心调的==
- ==所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会==

![subscribepattern](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/subscribepattern.jpg)

##### 9.4.2 类图

![publishsubscribe](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/publishsubscribe.png)

```js
/* 
发布订阅模式的特征是，发布者和订阅者解藕了，订阅者在订阅时将回调传给调度中心，调度中心管理订阅者的回调，发布者在调度中心发布消息时，调度中心将指定类型的回调拿出来执行，
不会像观察者模式那样，需要被观察者管理观察者，发布消息时，再去将观察者拿出来执行观察者的更新方法，
两种模式还是很像的，简单理解就是观察者模式队列中是观察者本身，发布订阅模式队列中是订阅者传进来的回调 
*/

class Pubsub {
  keys={};

  subscribe(key,fn) {
    if(!this.keys[key]){
      this.keys[key] = [];
    }
    this.keys[key].push(fn)
  }

  publish(key,data){
    this.keys[key].forEach(element => element(data));
  }
}

const pubsub = new Pubsub();

// 订阅者向调度中心订阅事件
pubsub.subscribe('key1', (data) => {
  console.log('我订阅了key1', data)
})

pubsub.subscribe('key1', (data) => {
  console.log('我也订阅了key1', data)
})

// 发布者发布事件到调度中西
pubsub.publish('key1', '我发布了一些消息')
```

订阅者把自己想订阅的事件注册到调度中心 

当该事件触发时候，发布者发布该事件到调度中心,由调度中心统一调度订阅者注册到调度中心的处理代码。

```js
class Agency{
    constructor() {
        this._topics={};
    }
    subscribe(topic,listener) {
        let listeners=this._topics[topic];
        if (listeners) {
            listeners.push(listener);
        } else {
            this._topics[topic]=[listener];
        }
    }
    publish(topic) {
        let listeners=this._topics[topic];
        let args=Array.from(arguments).slice(1);
        listeners.forEach(listener => listener(...args));
    }
}
let agent=new Agency();
class Landlord{
    constructor(name) {
        this.name=name;
    }
    lend(agent,area,money) {
        agent.publish('house',area,money);
    }
}

class Tenant{
    constructor(name) {
        this.name=name;
    }
    rent(agent) {
        agent.subscribe('house', (area,money)=> {
            console.log(`有新房源了, ${area}平米, ${money}元`);
        });
    }
}
let t1=new Tenant('房客1');
let t2=new Tenant('房客2');
let l1=new Landlord('房东1');
t1.rent(agent);
t2.rent(agent);
l1.lend(agent,30,2000);
```

### 3.10 迭代器模式

- 顺序访问一个集合
- 使用者无需知道集合的内部数据结构

#### 3.10.1 类图

![iterator](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_27475743_1720749.jpeg)

#### 3.10.2 代码

```js
function createIterator(arr) {
    let index=0;
    return {
        next() {
            return index<arr.length?
                {value: arr[index++],done: false}:
                {done:true}
        }
    }
}
let it=createIterator([1,2]);
console.log(it.next());
console.log(it.next());
console.log(it.next());
```

#### 3.10.3 场景

##### 3.10.3 Iterator

- 在ES6中有序集合数据类型有Array、Map、Set、String、TypedArray、arguments、NodeList

- 我们需要有一个统一的遍历接口来遍历所有的数据类型

- 他们都有 [Symbol.Iterator]属性，属性是一个函数，执行函数会返回迭代器

- 迭代器就有next方法顺序返回子元素

  ```js
  Array.prototype[Symbol.iterator]=function () {
    let index=0;
    return {
        next:()=> {
            return index<this.length?
                {value: this[index++],done: false}:
                {done:true}
        }
    }
  }
  let arr=[1,2];
  let it=arr[Symbol.iterator]();
  console.log(it.next());
  console.log(it.next());
  console.log(it.next());
  ```

```js
let result={};
while (!result.done) {
    result=it.next();
    console.log(result);
}
for (let item of arr) {
    console.log(item);
}
```

### 3.11 状态模式

- 当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象
- 对象有自己的状态
- 不同状态下执行的逻辑不一样
- 明确状态和每个状态下执行的动作
- 用来减少`if...else`子句

#### 3.11.1 类图

![state](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_c048eb45_1720749.jpeg)

#### 3.11.2 代码

```js
class Battery{
    constructor() {
        this.amount='high';
    }
    show() {
        if (this.amount == 'high') {
            console.log('绿色');
            this.amount='middle';
        }else if (this.amount == 'middle') {
            console.log('黄色');
            this.amount='low';
        }else{
            console.log('红色');
        }
    }
}
let battery=new Battery();
battery.show();
battery.show();
battery.show();
```

- `show`违反开放-封闭原则
- `show`方法逻辑太多太复杂
- 颜色状态切换不明显
- 过多的 `if/else` 让代码不可维护

```js
class Battery {
    constructor(state) {
        this.amount = 'high';
        this.state = new SuccessState(this);
    }
    show() {
        this.state.show();
        if (this.amount == 'high') {
            this.amount='middle';
            this.setState(new WarningState(this));
        } else if(this.amount=='middle'){
            this.amount='low';
            this.setState(new DangerState(this));
        }
    }
    setState(state) {
        this.state = state;
    }
}
class SuccessState {
    constructor(battery){
        this.battery = battery;
    }
    show() {
        console.log(`绿色 ${battery.amount}`);

  }
}
class WarningState {
    constructor(battery){
        this.battery = battery;
    }
    show() {
        console.log(`黄色 ${battery.amount}`);
  }
}
class DangerState {
    constructor(battery){
        this.battery = battery;
    }
    show() {
        console.log(`红色 ${battery.amount}`);
  }
}

let battery=new Battery();
battery.show();
battery.show();
battery.show();
```

#### 3.11.3 场景

##### 3.11.3.1 有限状态机

事物拥有多种状态，任一时间只会处于一种状态不会处于多种状态；

动作可以改变事物状态，一个动作可以通过条件判断，改变事物到不同的状态，但是不能同时指向多个状态，一个时间，就一个状态

状态总数是有限的；

一个常用的js 有限状态机的三方库[javascript-state-machine](https://github.com/jakesgordon/javascript-state-machine)

```js
//有限状态机 Finite-state machine
//var StateMachine=require('javascript-state-machine');
class StateMachine {
    constructor(options) {
        let {init,transitions,methods} =options;
        this.state=init;
        transitions.forEach(transition => {
            let {from,to,name}=transition;
            this[name]=function () {
                if (this.state == from) {
                    this.state=to;
                    let onMethod='on'+name.slice(0,1).toUpperCase()+name.slice(1);
                    methods[onMethod]&&methods[onMethod]();
                }
            }
        });
    }
}
var fsm = new StateMachine({
    init: 'solid',
    transitions: [{
            name: 'melt',
            from: 'solid',
            to: 'liquid'
        },
        {
            name: 'freeze',
            from: 'liquid',
            to: 'solid'
        },
        {
            name: 'vaporize',
            from: 'liquid',
            to: 'gas'
        },
        {
            name: 'condense',
            from: 'gas',
            to: 'liquid'
        }
    ],
    methods: {
        onMelt: function () {
            console.log('I melted')
        },
        onFreeze: function () {
            console.log('I froze')
        },
        onVaporize: function () {
            console.log('I vaporized')
        },
        onCondense: function () {
            console.log('I condensed')
        }
    }
});
fsm.melt();
```

### 3.12 策略模式

**策略模式（Strategy Pattern）**是一种**行为型**设计模式，==用于在运行时动态选择算法或行为==，使得对象能够根据不同情况选择不同的策略进行处理，而不需要在对象内部硬编码这些策略

策略模式将每个算法或行为封装成一个独立的类，并使它们==可以相互替换==，从而使得系统更加灵活、可扩展和易维护

- 将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化
- 避免大量的if else 或 swith case

> 策略模式的一个常见例子是购物应用的支付方式
>
> 假设你在一个购物应用上购买了一些商品，当你结账时，你可以选择多种支付方式，比如信用卡支付、支付宝支付、微信支付等。这些支付方式就是策略，你可以根据你的需求和情况选择最适合你的支付策略
>
> 这就是策略模式的精髓，即定义一系列的算法，并将每一个算法封装起来，使它们可以==相互替换== （运行时）

![策略设计模式](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202405171025809.png)

以下是一个使用JavaScript实现策略模式的示例：

```js
// 定义策略接口
class PaymentStrategy {
  pay(amount) {
    // 策略接口，具体的支付方式需实现该方法
  }
}

// 定义具体的支付策略类
class CashPaymentStrategy extends PaymentStrategy {
  pay(amount) {
    console.log(`支付现金：${amount} 元`);
  }
}

class CreditCardPaymentStrategy extends PaymentStrategy {
  constructor(cardNumber, cvv) {
    super();
    this.cardNumber = cardNumber;
    this.cvv = cvv;
  }

  pay(amount) {
    console.log(`使用信用卡支付：${amount} 元，卡号：${this.cardNumber}，CVV：${this.cvv}`);
  }
}

class AlipayPaymentStrategy extends PaymentStrategy {
  constructor(alipayAccount) {
    super();
    this.alipayAccount = alipayAccount;
  }

  pay(amount) {
    console.log(`使用支付宝支付：${amount} 元，支付账号：${this.alipayAccount}`);
  }
}

// 定义上下文类，用于选择并执行不同的支付策略
class PaymentContext {
  constructor(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }

  setPaymentStrategy(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }

  pay(amount) {
    this.paymentStrategy.pay(amount);
  }
}

// 使用示例
const cashPayment = new CashPaymentStrategy();
const creditCardPayment = new CreditCardPaymentStrategy('1234567890123456', '123');
const alipayPayment = new AlipayPaymentStrategy('example@example.com');

const paymentContext = new PaymentContext(cashPayment);
paymentContext.pay(100); // 输出：支付现金：100 元

paymentContext.setPaymentStrategy(creditCardPayment);
paymentContext.pay(200); // 输出：使用信用卡支付：200 元，卡号：1234567890123456，CVV：123

paymentContext.setPaymentStrategy(alipayPayment);
paymentContext.pay(300); // 输出：使用支付宝支付：300 元，支付账号：example@example.com
```

在上面的示例中，我们定义了一个策略接口 `PaymentStrategy`，并实现了三种不同的支付策略类：`CashPaymentStrategy`、`CreditCardPaymentStrategy`和`AlipayPaymentStrategy`

然后我们定义了一个**==上下文类==** `PaymentContext`，==用于根据不同的情况选择并执行不同的支付策略==。通过设置不同的支付策略，我们可以在运行时动态选择不同的支付方式进行支付，从而实现了策略模式

#### 3.12.1 类图

![strategy](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_cccc2ab0_1720749.jpeg)

#### 3.12.2 代码

```js
// 不使用策略模式的写法
class Customer{
    constructor(type) {
        this.type=type;
    }
    pay(amount) {
        if (this.type == '会员顾客') {
            return amount*.9;
        }else if (this.type == 'VIP顾客') {
            return amount*.8;
        } 
        return amount;
    }
}
let c1=new Customer('普通顾客');
console.log(c1.pay(100));
let c2=new Customer('会员顾客');
console.log(c2.pay(100));
let c3=new Customer('VIP顾客');
console.log(c3.pay(100));
```

```js
// 使用策略模式的写法
class Customer{
    constructor(kind) {
        this.kind=kind;
    }
    cost(amount) {
        return this.kind.discount(amount);
    }
}
class Kind{

}
class Normal extends Kind{
    discount(amount) {
        return amount;
    }
}
class Member extends Kind{
    discount(amount) {
        return amount*.9;
    }
}
class VIP extends Kind{
    discount(amount) {
        return amount*.8;
    }
}
let c1=new Customer(new Normal());
console.log(c1.cost(100));
c1.kind=new Member();
console.log(c1.cost(100));
c1.kind=new VIP();
console.log(c1.cost(100));
```

把算法封装在策略对象中，指定算法调用即可

```js
class Customer{
    constructor() {
        this.kinds={
            normal: function (price) {
                return price;
            },
            member: function (price) {
                return price*.9;
            },
            vip: function (price) {
                return price*.8;
            }
        }
    }
    cost(kind,amount) {
        return this.kinds[kind](amount);
    }
}
let c=new Customer();
console.log(c.cost('normal',100));
console.log(c.cost('member',100));
console.log(c.cost('vip',100));
```

#### 3.11.3 场景

##### 3.11.3.1 表单校验

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <form  id="userform">
      用户名 <input type="text" name="username"/>
      密码 <input type="text" name="password"/>
      手机号 <input type="text" name="mobile"/>
      <input type="submit">
    </form>
<script>
let Validator = (function(){
    let rules = {
        notEmpty(val,msg){
            if(val == ''){
                return msg;
            }
        },
        minLength(val,length,msg){
            if(val==''||val.length <length){
                return msg;
            }
        },
        maxLength(val,length,msg){
            if(val==''||val.length > length){
                return msg;
            }
        },
        isMobile(val,msg){
            if(!/^1\d{10}/.test(val)){
                return msg;
            }
        }
    }
    function addRule(name,rule){
        rules[name] = rule;
    }
    let checks = [];
    function add(element,rule){
        checks.push(function(){
            let name = rule.shift();
            rule.unshift(element.value);
            return rules[name]&&rules[name].apply(element,rule);
        });
    }
    function start(){
        for(let i=0;i<checks.length;i++){
            let check = checks[i];
            let msg = check();
            if(msg){
                return msg;
            }
        }
    }
    return {
        add,
        start,
        addRule
    }
})();

let form = document.getElementById('userform');
form.onsubmit = function(){
    Validator.add(form.username,['notEmpty','用户名不能为空']);
    Validator.add(form.password,['minLength',6,'密码小于6位最少长度']);
    Validator.add(form.password,['maxLength',8,'密码大于8位最大长度']);
    Validator.add(form.mobile,['isMobile','手机号不合法']);
    let msg =   Validator.start();
    if(msg) {
        alert(msg);
        return false;
    }
    alert('校验通过');
    return true;
}
</script>

</body>
</html>
```

**策略模式**和**状态模式**的区别

- 策略模式和状态模式都有上下文，**有策略或者状态类**，上下文把这些请求委托给这些类来执行
- 策略模式中各个类是**平等**的，没有关系，客户端需要知道算法**主动切换**
- 状态模式中，**状态的切换和行为被封装好了**，客户不需要了解细节

### 3.13 原型模式

- 原型模式是一个创建型的模式
- 创建基类的时候，简单差异化的属性放在构造函数中，消耗资源相同的功能放在基类原型中

#### 3.13.1 类图

![myprototype](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_40ff81b7_1720749.jpeg)

#### 3.13.2 代码

```js
function Person(name) {
    this.name=name;
    this.getName=function () {
        console.log(this.name);
    }
}
let p1 = new Person('张三');
let p2=new Person('李四');
console.log(p1.getName===p2.getName);
function Person(name) {
    this.name=name;
}
Person.prototype.getName = function () {
    console.log(this.name);
}
let p1 = new Person('张三');
let p2=new Person('李四');
console.log(p1.getName===p2.getName);
```

#### 3.13.3 JavaScript中的原型

##### 3.13.3.1 函数和对象

- 函数是一种对象
- 对象都是通过函数创建的

```js
//函数是一种对象
function Person() {}
console.log(Person instanceof Object);

//对象都是通过函数创建的
let p1=new Person();
let obj1={name: 'zfpx'}
let obj=new Object();
obj2.name='zfpx';
```

##### 3.13.3.2 prototype

- 每个函数都有一个属性叫做`prototype`
- `prototype`的属性值是一个对象,默认的只有一个叫做`constructor`的属性，指向这个函数本身
- 每个对象都有一个隐藏的属性`__proto__`,这个属性引用了创建这个对象的函数的`prototype`

![__proto__](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_82db32b7_1720749-20220517085734273.png)

- 自定义函数的prototype是由Object创建，所以它的**proto**指向的就是Object.prototype
- Object.prototype的**proto**指向的是null

![object.prototype](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192758_c8e0b1cf_1720749-20220517085745332.png)

- 自定义函数`Foo.__proto__`指向`Function.prototype`

- `Object.__proto__`指向`Function.prototype`

-  `Function.__proto__`指向`Function.prototype`

  ```js
  let sum = new Function('a','b','return a+b');
  ```

![function.prototype](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_01cd602d_1720749.png)

- `Function.prototype`的`__proto__`也指向`Object.prototype`

![function.prototype.__proto__](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_a5a04401_1720749.png)

##### 3.13.3.3 instanceof

- Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B

- Instanceof的判断规则是：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回`true`。如果找到终点还未重合，则返回`false`

  ```js
  console.log(Object instanceof Function);
  console.log(Function instanceof Object);
  console.log(Function instanceof Function);
  ```

![fullprototype](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_a727097d_1720749.png)

##### 3.13.3.4 原型链

- 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着`__proto__`这条链向上找，这就是原型链
- `hasOwnProperty`可以区分一个属性到底是自己的还是从原型中找到

```js
function Foo(){
    this.a = 10;
}
Foo.prototype.b = 20;

let f1  = new Foo();
console.log(f1.a);
console.log(f1.b);
```

##### 3.13.3.5 原型优势

- 可以随意扩展
- 可以重写继承的方法

```js
let obj = {};
console.log(obj.toString());
let arr = [1,2,3];
console.log(arr.toString());
```

#### 3.13.4 场景

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            margin:0;
            padding:0;
        }
        canvas{
            border:1px solid #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1000" height="600"></canvas>
    <script>
    //随机颜色，十六进制方法；
        function getRandomColor( ) {
          var rand = Math.floor(Math.random( ) * 0xFFFFFF).toString(16);
          if(rand.length == 6){        
            return '#'+rand;
          }else{
            return getRandomColor();
          }
        }
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let circles = [];
        function Circle(x,y,radius){
                this.x=x;
                this.y=y;
                this.radius= radius;
                circles.push(this);
        }
        Circle.prototype.update = function() {
                this.radius--;
                if(this.radius>0){
                    return true;
                }
        }
        Circle.prototype.render = function(){
            ctx.beginPath();
            ctx.arc(this.x,this.y,this.radius,0,2*Math.PI);
            ctx.fillStyle = getRandomColor();
            ctx.fill();
        }

        let circle = new Circle(0,0,30);
        canvas.onmousemove = function(event){
            circles.push(new Circle(event.clientX,event.clientY,30));
        }
        setInterval(function(){
            ctx.clearRect(0,0,1000,600);
            circles.forEach(item=>{
                item.update()&&item.render(); 
            });
            circles = circles.filter(item=>item.radius>0);
        },20);
    </script>
</body>
</html>
```

### 3.15 桥接模式

- 将抽象部分与他的实现部分分离,这样抽象化与实现化解耦,使他们可以独立的变化
- 应用场景是实现系统可能有多个角度分类,每一种角度都可能变化.
- 桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响

> **桥接模式**的一个常见例子是电视和遥控器。假设你有一个电视，这个电视有一个基本的功能，就是播放节目。但是，你可能希望通过不同的方式来控制这个电视，比如使用普通的遥控器，或者使用语音遥控器，甚至使用手机遥控器
>
> 这就是桥接模式的精髓，即将抽象部分（电视）和实现部分（遥控器）分离，使它们可以独立地变化

![桥接设计模式](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202405171023632.png)

#### 3.15.1 类图

![bridge](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_03de8d50_1720749.jpeg)

#### 3.15.2 代码

```js
class A {
    constructor(bridge) {
        this.bridge=bridge;
    }
    go() {
        console.log(`从${this.from()}到${this.bridge.to()}`);
    }
}
class A1 extends A {
    from() {
        return 'A1';
    }
}
class A2 extends A {
    from() {
        return 'A2';
    }
}
class A3 extends A {
    from() {
        return 'A3';
    }
}

class B {
    to() {}
}
class B1 extends B {
    to() {
        return 'B1';
    }
}
class B2 extends B {
    to() {
        return 'B2';
    }
}
class B3 extends B {
    to() {
        return 'B3';
    }
}
let b=new B3();
let a=new A2(b);
a.go();
```

#### 3.15.3 应用场景

##### 3.15.3.1 事件监听

- 解耦

```js
let express=require('express');
let path=require('path');
let app=express();
app.get('/',(req,res) => {
    res.sendFile(path.join(__dirname,'4.html'));
});
app.get('/user/:id',function (req,res) {
    let id = req.params.id;
    res.json({id,name:`${id}_name`});
});
app.listen(8888);
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>bridage</title>
</head>
<body>
    <ul>
      <li data-id="1" >1</li>
      <li data-id="2" >2</li>
    </ul>
    <p id="content">

    </p>
<script>
  let lis = document.querySelectorAll('li');
  for(let i=0;i<lis.length;i++){
      lis[i].addEventListener('click',getUserById);
  }
  function getUserById(event){
     //依赖this 2.操作DOM的操作，只能在浏览器里跑
      let id = this.dataset.id;
      let xhr = new XMLHttpRequest;
      xhr.open('GET',`/user/${id}`,true);
      xhr.responseType = 'json';
      xhr.onreadystatechange = function(){
          if(xhr.readyState ===4 && xhr.status == 200){
            let user = xhr.response;
            document.getElementById('content').innerHTML = user.name;
          }
      }
      xhr.send();
  }
</script>    
</body>
</html>

```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <ul>
      <li data-id="1" >1</li>
      <li data-id="2" >2</li>
    </ul>
    <p id="content">

    </p>
<script>
  let lis = document.querySelectorAll('li');
  for(let i=0;i<lis.length;i++){
      lis[i].addEventListener('click',addBridage);
  }

  function addBridage(){
      let id = this.dataset.id;
      getUserById(id,function(user){
         document.getElementById('content').innerHTML = user.name;
      });
  }

  function getUserById(id,callback){
      let xhr = new XMLHttpRequest;
      xhr.open('GET',`/user/${id}`,true);
      xhr.responseType = 'json';
      xhr.onreadystatechange = function(){
          if(xhr.readyState ===4 && xhr.status == 200){
            let user = xhr.response;
            callback(user);
          }
      }
      xhr.send();
  }
</script>    
</body>
</html
```

##### 3.15.3.2 分离变化

- 分离多维变化

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>html</title>
    <style>
        * {
            margin:0;
            padding:0;
        }
        canvas{
            border:1px solid #000;
        }
    </style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<script>
//形状 颜色 坐标
function Position(x,y) {
  this.x=x;
  this.y=y;
}

function Color(color) {
    this.color=color;
}


function Ball(x,y,color) {
    this.position=new Position(x,y);
    this.color=new Color(color);
}
Ball.prototype.draw=function () {
  let canvas = document.getElementById('canvas');
  let ctx = canvas.getContext('2d');
  ctx.beginPath();
  ctx.arc(this.position.x,this.position.y,100,0,2*Math.PI);
  ctx.fillStyle = this.color.color;
  ctx.fill();
}
new Ball(300,300,'red').draw();
</script>    
</body>
</html>
```

## 3.16 组合模式

- 又称整体-部分模式
- 将对象组合成树形结构以表示部分-整体的层次结构
- 客户可以使用统一的方式对待组合对象和叶子对象

> 组合模式的一个典型例子是文件系统
>
> 在文件系统中，一个文件夹可以包含其他文件夹和文件，这是一种树形结构，层级结构分明。当你需要对一个文件夹进行操作（比如复制、删除）时，你不需要关心这个文件夹是空的，还是包含了其他文件或文件夹。
>
> 你可以直接对这个文件夹进行操作，如果这个文件夹包含了其他文件或文件夹，这些操作会自动应用到它们上
>
> 这就是组合模式的精髓，即将对象组合成树形结构以表示“整体-部分”的层次结构，使用户对单个对象和组合对象的使用具有一致性

![组合设计模式](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/202405171026648.png)

### 3.16.1 类图

![compose](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_5fb1222e_1720749.jpeg)

### 3.16.2 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title></title>
    <style>
    .red{
        color:red;
    }
    </style>
</head>
<body>
<div id="root"></div>    
<script>
function ReactElement(type,props) {
    this.type = type;
    this.props = props;
}
let React = {
    createElement(type,props={},...childrens){
        childrens.length===1?childrens = childrens[0]:void 0
        return new ReactElement(type,{...props,children:childrens})
    }
};
let render = (eleObj,container)=>{
    // 先取出第一层 进行创建真实dom
    let {type,props} = eleObj;
    let elementNode = document.createElement(type); // 创建第一个元素
    for(let attr in props){ // 循环所有属性
        if(attr === 'children'){ // 如果是children表示有嵌套关系
            if(typeof props[attr] == 'object'){ // 看是否是只有一个文本节点
                props[attr].forEach(item=>{ // 多个的话循环判断 如果是对象再次调用render方法
                    if(typeof item === 'object'){
                        render(item,elementNode)
                    }else{ //是文本节点 直接创建即可
                        elementNode.appendChild(document.createTextNode(item));
                    }
                })
            }else{ // 只有一个文本节点直接创建即可
                elementNode.appendChild(document.createTextNode(props[attr]));
            }
        }else if(attr === 'className'){ // 是不是class属性 class 属性特殊处理
            elementNode.setAttribute('class',props[attr]);
        }else{
            elementNode.setAttribute(attr,props[attr]);
        }
    }
    container.appendChild(elementNode)
};
//ReactDOM.render(<div>hello<span>world</span></div>);
//ReactDOM.render(React.createElement("div",null,"hello,",React.createElement("span",null,"world")));
render(React.createElement("div",null,"hello,",React.createElement("span",{class:"red"},"world")),document.getElementById('root'));

</script>
</body>
</html>
```

### 3.16.3 应用场景

#### 3.16.3.1 文件夹和文件

```js
function Folder(name) {
    this.name=name;
    this.children=[];
    this.parent=null;
    this.level=0;
}
Folder.prototype.add=function (child) {
    child.level=this.level+1;
    child.parent=this;
    this.children.push(child);
}
Folder.prototype.show=function () {
    console.log(' '.repeat(this.level)+'文件夹'+this.name);
    for (let i=0;i<this.children.length;i++){
        this.children[i].show();
    }
}
Folder.prototype.remove=function () {
    if (!this.parent) return;
    for (let i=0;i<this.parent.children.length;i++){
        let current=this.parent.children[i];
        if (current === this) {
            return this.parent.children.splice(i,1);
        }
    }
}

function File(name) {
    this.name=name;
}
File.prototype.add=function () {
    throw new Error(`文件下面不能再添加文件`);
}
File.prototype.show=function () {
    console.log(' '.repeat(this.level)+'文件'+this.name);
}

let folder=new Folder('视频');
let vueFolder=new Folder('Vue视频');
let reactFolder=new Folder('React视频');
let vueFile=new File('Vue从入门到精通');
let reactFile=new File('React从入门到精通');
folder.add(vueFolder);
folder.add(reactFolder);
vueFolder.add(vueFile);
reactFolder.add(reactFile);

folder.show();
vueFolder.remove();
folder.show();
```

#### 3.16.3.2 绘制表单

```js
class FormContainer {
    constructor(type) {
        this.element = document.createElement(type);
        this.children = [];
    }
    add(child) {
        this.children.push(child);
        this.element.appendChild(child.element);
        return this;
    }
}
class FieldContainer {
    constructor(type) {
        this.element = document.createElement(type);
        this.children = [];
    }
    add(child) {
        this.children.push(child);
        this.element.appendChild(child.element);
        return this;
    }
}
class LabelItem {
    constructor(title) {
        this.element = document.createElement('label');
        this.element.innerHTML = title;
    }
}
class InputItem {
    constructor(title) {
        this.element = document.createElement('input');
        this.element.name = title;
    }
}
class TipItem {
    constructor(title) {
        this.element = document.createElement('span');
        this.element.innerHTML = title;
    }
}
let userform = new FormContainer('form').add(
    new FieldContainer('p').add(
        new LabelItem('用户名')
    ).add(
        new InputItem('username')
    ).add(
        new TipItem('用户名长度为6-8位')
    )
).add(new FieldContainer('p').add(
    new LabelItem('密码')
).add(
    new InputItem('password')
).add(
    new TipItem('确认密码')
));
document.body.appendChild(userform.element);
```

### 3.17 命令模式

- 执行命令时，发布者和执行者分开
- 中间加入命令对象，作为中转站

三种角色

- `Receiver`接受者角色：该角色就是干活的角色，命令传递到这里是应该被执行的
- `Command`命令角色：需要执行的所有命令都在这里声明
- `Invoker`调用者角色：接收到命令，并执行命令

### 3.17.1 类图

![command](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_3f5aa289_1720749.jpeg)

### 3.17.2 代码

```js
class Cooker{
    cook() {
        console.log(`做饭`);    
    }
}
class Cleaner{
    clean() {
        console.log(`清洁`);    
    }
}


class CookCommand{
    constructor(cooker) {
        this.cooker=cooker;
    }
    execute() {
        this.cooker.cook();
    }
}
class CleanCommand{
    constructor(cleaner) {
        this.cleaner=cleaner;
    }
    execute() {
        this.cleaner.clean();
    }
}

class Customer{
    constructor(command) {
        this.command=command;
    }
    setCommand(command) {
      this.command = command
    }
    cook() {
        this.command.execute();
    }
    clean() {
        this.command.execute();
    }
}
let cooker=new Cooker();
let cookCommand=new CookCommand(cooker);
let c=new Customer(cookCommand);
c.cook();
let cleaner=new Cleaner();
let cleanCommand = new CleanCommand(cleaner);
c.setCommand(cleanCommand)
c.clean();
```

### 3.17.3 应用场景

#### 3.17.3.1 计数器

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>计数器</title>
</head>
<body>
    <p id="number">0</p>
    <button id="addBtn">点击按钮</button>
<script>
 let addBtn = document.getElementById('addBtn');
 let number = document.getElementById('number');

 let worker = {
  add(){
   number.innerHTML = parseInt(number.innerHTML)+1;
  }
 }

 class AddCommand{
     constructor(receiver){
         this.receiver = receiver;
     }
     execute(){
         this.receiver.add();
     }
 }

let addCommand = new AddCommand(worker);
addBtn.onclick = ()=>addCommand.execute();
</script>    
</body>
</html>
```

#### 3.17.3.2 撤销和重做

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹出菜单</title>
</head>
<body>
    <p id="number">0</p>
    <button id="addBtn">+</button>
    <button id="undoBtn">undo</button>
<script>
 let addBtn = document.getElementById('addBtn');
 let undoBtn = document.getElementById('undoBtn');
 let number = document.getElementById('number');

 let worker = {
  lastVal:-1,
  add(){
   let oldVal = parseInt(number.innerHTML);     
   worker.lastVal = oldVal; 
   number.innerHTML = oldVal+1;
  },
  undo(){
      number.innerHTML = worker.lastVal;
  }
 }

 class AddCommand{
     constructor(receiver){
         this.receiver = receiver;
     }
     execute(){
         this.receiver.add();
     }
 }

 let addCommand = new AddCommand(worker);
 class UndoCommand{
     constructor(receiver){
         this.receiver = receiver;
     }
     execute(){
         this.receiver.undo();
     }
 }

 let undoCommand = new UndoCommand(worker);
 addBtn.onclick = ()=>addCommand.execute();
 undoBtn.onclick = ()=>undoCommand.execute();
</script>    
</body>
</html>
```

#### 13.17.3.3 多步撤销和重做

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>弹出菜单</title>
</head>
<body>
    <p id="number">0</p>
    <button id="addBtn">+</button>
    <button id="undoBtn">undo</button>
    <button id="redoBtn">undo</button>
<script>
 let addBtn = document.getElementById('addBtn');
 let undoBtn = document.getElementById('undoBtn');
 let redoBtn = document.getElementById('redoBtn');
 let number = document.getElementById('number');

 let worker = {
  history:[],
  index:-1,
  add(){
   let oldVal = parseInt(number.innerHTML);     
   let newVal = oldVal + 1;
   worker.history.push(newVal);
   worker.index = worker.history.length-1;
   number.innerHTML = newVal;
   console.log(worker);
  },
  undo(){
      if(worker.index-1>=0){
          worker.index--;
        number.innerHTML = worker.history[worker.index];
        console.log(worker);
      }
  },
  redo(){
      if(worker.index+1<worker.history.length){
        worker.index++;  
        number.innerHTML = worker.history[worker.index];
        console.log(worker);
      }
  }
 }

 class AddCommand{
     constructor(receiver){
         this.receiver = receiver;
     }
     execute(){
         this.receiver.add();
     }
 }

 let addCommand = new AddCommand(worker);
 class UndoCommand{
     constructor(receiver){
         this.receiver = receiver;
     }
     execute(){
         this.receiver.undo();
     }
 }

 let undoCommand = new UndoCommand(worker);
 class RedoCommand{
     constructor(receiver){
         this.receiver = receiver;
     }
     execute(){
         this.receiver.redo();
     }
 }

let redoCommand = new RedoCommand(worker);
addBtn.onclick = ()=>addCommand.execute();
undoBtn.onclick = ()=>undoCommand.execute();
redoBtn.onclick = ()=>redoCommand.execute();
</script>    
</body>
</html>
```

### 3.18 享元模式

- 共享内存，节约内存空间
- 相同的数据共享使用
- 主要还是对数据、方法共享分离，将数据的方法分为内部数据、内部方法和外部数据、外部方法。
- 内部状态保存在对象内部，通常不会改变，可以共享
- 外部状态保存在对象外部，可以随场景改变，不可以共享。

### 3.18.1 类图

![flyweight](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_f42650d7_1720749.jpeg)

### 3.18.2 代码

```js
function Person(name,age) {
    this.name=name;
    this.age=age;
}
Person.prototype.getAge=function () {
    console.log(this.age)
}
Person.prototype.getName=function () {
    console.log(this.name)
}
```

### 3.18.3 场景

#### 3.18.3.1 对象

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

<input type="radio" value="red" name="color" checked/>红 
<input type="radio" value="yellow" name="color"/>黄 
<input type="radio" value="blue" name="color"/>蓝

<button onclick="draw()">绘制</button>

<div id="container">

</div>

<script>
let container = document.getElementById('container');
class MyDiv{
    constructor(){
      this.element = document.createElement('div');
    }
    setColor(color){
        this.element.style = `width:100px;height:100px;background-color:${color}`; 
    }
}
let div = new MyDiv();
function draw(){
  let color = Array.from(document.getElementsByName('color')).find(item=>item.checked).value||'red';
  div.setColor(color);
  container.appendChild(div.element);
}
</script>
</body>
</html>
```

#### 3.18.3.2 分页

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<ul id="news">

</ul>
<button id="nextPage" onclick="goNext()">下一页</button>
<script>
let list = [];
for(let i=0;i<20;i++){
    list[i]=`新闻${i+1}`
}
let pageNum = 0;
let pageSize = 5;
let news = document.getElementById('news');
for(let i=0;i<list.length;i++){
    let li = document.createElement('li');
    li.innerHTML = `新闻${i+1}`;
    li.style.display = 'none';
    news.appendChild(li);
}
function goNext(){
  pageNum++;
  let start = (pageNum -1)*pageSize;
  let lis = document.getElementsByTagName('li');
  for(let i=0;i<=lis.length;i++){
     let li = lis[i];
     if(i>=start && i<start+pageSize){
         li.style.display = 'block';
     }else{
         li.style.display = 'none';
     }
  }
}
goNext();
</script>
</body>
```

```html
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<ul id="news">

</ul>
<button id="nextPage" onclick="goNext()">下一页</button>

<script>
let list = [];
for(let i=0;i<20;i++){
    list[i]=`新闻${i+1}`
}
let getLi = (function(){
    let lis = [];
    return function(){
        let element;
        if(lis.length<5){
            element = document.createElement('li');
            lis.push(element);
        }else{
            element = lis.shift();
            lis.push(element);
        }
            return element;
    }
})();

let pageNum = 0;
let pageSize = 5;
let news = document.getElementById('news');
function goNext(){
  pageNum++;
  let start = (pageNum -1)*pageSize;
  for(let i=1;i<=5;i++){
      let element = getLi();
      element.innerHTML = `新闻${start+i}`;
      news.appendChild(element);
  }
}
goNext();

</script>
</body>
</html>
```

### 3.19 模版方法

- 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中
- 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现
- 一般有两部分组成，第一部分是抽象父类，第二部分是具体的实现子类
- 好莱坞原则，子类放弃了控制权，改由父类来调用
  - 发布订阅
  - 回调函数

### 3.19.1 类图

![template](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/192759_375f96b8_1720749.jpeg)

### 3.19.2 代码

```js
class Person{
    dinner() {
        this.buy();
        this.cook();
        this.eat();
    }
    buy() {}
    cook() {}
    eat() {}
}
class Jiangwen extends Person{
    buy() {console.log('买黄瓜');}
    cook() {console.log('拍黄瓜');}
    eat() {console.log('吃黄瓜');}
}
let j=new Jiangwen();
j.dinner();
```

### 3.19.3 场景

#### 3.19.3.1 提示框

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="3.css">
</head>
<body>

<script src="3.js"></script>    
<script>
let dialog = new ConfirmDialog({
    title:'标题',
    content:'内容'
});
</script>
</body>
</html>

<style>
  .dialog{
    width:400px;
    height:300px;
    position: absolute;
    padding:20px;
    top:50%;
    left:50%;
    margin-left:-200px;
    margin-top:-150px;
    border:1px solid#000;
    background-color: #EEE;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.dialog button{
    width:100px;
    height:30px;
    position: absolute;
    border: none;
    outline: none;

}
.dialog .confirm-button {
    right:140px;
    bottom:20px;
}
.dialog .cancel-button {
    right:20px;
    bottom:20px;
}
</style>
```

```js
class Dialog{
    constructor(options) {
        this.title = options.title||'标题';
        this.content = options.content||'内容';
        this.onConfirm = options.onConfirm||this.hide;
        this.onCancel = options.onCancel||this.hide;
        this.init();
        this.initEventHandler();
    }
    init() {
        this.panel=document.createElement('div');
        this.panel.className='dialog';

        this.titleP=document.createElement('p');
        this.titleP.innerHTML=this.title;
        this.panel.appendChild(this.titleP);

        this.contentP=document.createElement('p');
        this.contentP.innerHTML=this.content;
        this.panel.appendChild(this.contentP);

        this.confirmBtn=document.createElement('button');
        this.confirmBtn.className='button confirm-button';
        this.confirmBtn.innerHTML='确定';
        this.panel.appendChild(this.confirmBtn);

        this.cancelBtn=document.createElement('button');
        this.cancelBtn.className='button cancel-button';
        this.cancelBtn.innerHTML='取消';
        this.panel.appendChild(this.cancelBtn);

        document.body.appendChild(this.panel);
    }
    inithttp://image.bubuko.com/info/201807/20180712173511381297.pngntListener('click',() => {
            this.onConfirm();
            this.hide();
        });
        this.cancelBtn.addEventListener('click',() => {
            this.onCancel();
            this.hide();
        });
    }
    show() {
        this.panel.style.display='block';
    }
    hide() {
        this.panel.style.display='none';
    }
}

class ContentDialog extends Dialog{
    init() {
        super.init();
        this.titleP.parentNode.removeChild(this.titleP);
    }
}

class ConfirmDialog extends Dialog{
    init() {
        super.init();
        this.cancelBtn.parentNode.removeChild(this.cancelBtn);
    }
}
```

