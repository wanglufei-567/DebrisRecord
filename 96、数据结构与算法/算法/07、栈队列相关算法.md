## 栈/队列相关算法

### 一、栈

**「栈」**主要考察**「先进后出**」特点的运用，比如表达式运算、括号合法性检测等问题
对原子元素执行入栈和出栈操作，最终对栈中剩余元素进行处理，得到最终结果

### 1.1、简化路径

**描述：**给定一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），将其转化为更加简洁的规范路径

**示例：**

```markdown
输入：path = "/a/./b/../../c/"
输出："/c"
```

**题解：**

```javascript
var simplifyPath = function(path) {
  // 维护一个路径栈
  const stk = [];
  // 将路径以 “/” 分割成数组
  const parts = path.split("/");

  // 借助栈计算最终的文件夹路径
  for (const part of parts) {
    // 如果当前路径为空或者当前路径为 “.” 无需操作跳过本次遍历，继续遍历下一个路径
    if (part === "" || part === ".") {
        continue;
    }

    // 如果当前路径为 “..” 则需要回退到上一级目录，如果栈不为空则弹出栈顶元素
    if (part === "..") {
        if (stk.length > 0) stk.pop();
        continue;
    }

    // 将当前路径压入栈中
    stk.push(part);
  }

  // 栈中存储的文件夹组成路径
  const newPath = `/${arr.join('/')}`
  return newPath === "" ? "/" : newPath
};
```

**解析：**

- 将路径以 “/” 分割成数组，遍历数组，对路径执行入栈和出栈操作
- 遇到空路径或“.” 则直接跳过，无需入栈
- 遇到“..”，说明需要回退到上一级目录，因此需要将路径栈栈顶元素弹出
- 最后将栈中存储的文件夹组成路径，返回结果

### 1.2、括号匹配问题

**描述：**给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合
2. 左括号必须以正确的顺序闭合
3. 每个右括号都有一个对应的相同类型的左括号

**示例：**

```markdown
输入：s = "()[]{}"
输出：true

输入：s = "(]"
输出：false
```

**题解：**

```javascript
var isValid = function(str) {
  // 维护一个左括号栈
  let left = [];
  // 遍历字符串
  for (let c of str) {
    if (c === '(' || c === '{' || c === '[') {
      // 字符 c 是左括号，入栈
      left.push(c);
    } else {
      if (left.length !== 0 && leftOf(c) === left.at(-1)) {
        // 如果栈不为空且栈顶元素与当前字符匹配，则说明括号是匹配的，弹出栈顶元素
        left.pop();
      } else {
        // 如果栈为空或栈顶元素与当前字符不匹配，则返回 false
        return false;
      }
    }
  }

  // 是否所有的左括号都被匹配了
  return left.length === 0;
};

var leftOf = function(c) {
  if (c === '}') return '{';
  if (c === ')') return '(';
  return '[';
};
```

**解析：**

- 遇到左括号，则将左括号入栈
- 遇到右括号，则判断栈顶元素是否与当前字符匹配，如果匹配则弹出栈顶元素，否则返回 false
- 最后判断栈是否为空，如果为空则返回 true，否则返回 false

### 1.3、逆波兰表达式求值

**描述：**根据 逆波兰表示法，求表达式的值，有效的算符包括 `+`、`-`、`*`、`/` 每个运算对象可以是整数，也可以是另一个逆波兰表达式

**示例：**

```markdown
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**题解：**

```javascript
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  let res
  // 维护一个栈，用于存储数字
  const arr = []

  // 遍历 tokens 数组
  for(let i = 0; i < tokens.length; i++) {
    const token = tokens[i]

    // 如果 token 是运算符，则弹出栈顶两个元素，进行运算，将结果压入栈中
    if(['+', '-', '*', '/'].includes(token)) {
      let b = Number(arr.pop())
      let a = Number(arr.pop())
      // 根据运算符进行运算
      switch (token) {
        case '+': {
          res = a + b
          break;
        }
        case '-' : {
          res = a - b
          break
        }
        case '*' : {
          res = a * b
          break
        }
        case '/' : {
          // 两个整数之间的除法只保留整数部分
          res = Math.trunc(a / b)
          break
        }
      }
      // 将运算结果压入栈
      arr.push(res)
    } else {
      // 若是数字则直接压入栈
      arr.push(token)
    }
  }
  return Number(arr[0])
};
```

**解析：**

- 遍历 tokens 数组，如果 token 是运算符，则弹出栈顶两个元素，进行运算，将结果压入栈中
- 如果 token 是数字，则直接压入栈
- 最后返回栈顶元素

### 1.4、文件的最长绝对路径

**描述：**假设文件系统存储在单层文件系统中，简化路径需遵循下述规则：

1. 绝对路径 `root` 在根文件系统下，因此以 `/` 开头
2. 任意两个文件名用 `'/'` 隔开
3. 至多一个 `'.'` ，表示当前目录本身
4. 至多一个 `'..'` ，表示将返回至上一级目录
5. 所有路径为绝对路径，即不以 `'/'` 开头

**示例：**

```markdown
输入：input = "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"
输出：32
解释：存在两个文件：
"dir/subdir1/file.ext" ，路径长度 21
"dir/subdir2/subsubdir2/file.ext" ，路径长度 32

输入：input = "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
输出：32
解释：存在两个文件：
"dir/subdir1/file.ext" ，路径长度 21
"dir/subdir2/subsubdir2/file.ext" ，路径长度 32
```

**题解：**

```javascript
/**
 * @param {string} input
 * @return {number}
 */
var lengthLongestPath = function(input) {
  // 维护一个栈，用于存储当前目录的父路径
  let stack = [];
  // 维护一个变量，用于存储最长路径长度
  let maxLen = 0;

  // 将输入字符串按 “\n” 分割成数组
  let parts = input.split("\n");

  // 遍历 parts 数组
  for (let part of parts) {
      // 获取当前目录的层级，有多少个 “\t” 就有多少级
      // 根目录由于没有 “\t”， part.lastIndexOf("\t") 返回 -1，所以其 level 为 0
      // 其他目录由于有 “\t”， 比如 "\tsubdir1"，part.lastIndexOf("\t") 返回 0，所以其 level 为 1，正好对应目录的层级
      let level = part.lastIndexOf("\t") + 1;

      // 让栈中只保留当前目录的父路径，level 是当前目录的层级，stack.length - 1 是栈顶目录的层级
      while (level <= stack.length - 1) {
        // 如果当前目录的层级小于栈顶目录的层级，说明栈顶目录是比当前目录更深的目录，需要弹出栈顶目录
        // 直到当前目录的层级大于栈顶目录的层级，说明栈顶目录是比当前目录更浅的目录，也就是当前目录的父路径
          stack.pop();
      }

      // 将当前目录压入栈，part 形如 "\t\t\tfile2.ext"，slice(level) 就是 "file2.ext"
      stack.push(part.slice(level));

      // 如果是文件，就计算路径长度
      if (part.includes(".")) {
          let sum = stack.reduce((acc, val) => acc + val.length, 0);
          // 加上父路径的分隔符
          sum += stack.length - 1;
          maxLen = Math.max(maxLen, sum);
      }
  }
  return maxLen;
};
```

**解析：**

- 将输入字符串按 “\n” 分割成数组，遍历 `parts` 数组，获取当前目录的层级，有多少个 “\t” 就有多少级
  - 比如，"\tsubdir1"只有 1 个 “\t”，所以其 level 为 1
- 如果当前目录的层级小于栈顶目录的层级，则弹出栈顶目录，让栈中只保留当前目录的父路径
  - 比如，"\tsubdir1"的层级为 1，"\tsubdir"的层级也为 1，说明二者位于同一级，所以需要弹出栈顶目录，让栈中只保留当前目录的父路径
- 将当前目录压入栈
- 如果是文件，就计算路径长度，加上父路径的分隔符，更新最长路径长度
- 最后返回最长路径长度

### 1.5、单调栈

**「单调栈」**是一种特殊用途的栈，要求栈内元素必须保持 **单调递增** 或 **单调递减** 的顺序

**单调栈的本质：**

- **栈里的元素保持单调性**（递增或递减），保证栈中只保留有用的信息
- **栈顶元素代表最近的、最直接可能影响当前元素的值**
- 当新元素到来时：
  - 如果打破单调性，就弹出不再有用的栈顶元素；
  - 弹出元素时，可以立即得到答案（例如下一个更大/更小元素，跨度等）

<!--通过这种方式，单调栈能在一次遍历中解决原本可能需要多重循环的问题-->

**代码模板：**

```javascript
// 计算下一个更大元素
var calculateGreaterElement = function(nums) {
    var n = nums.length;
    // 存放答案的数组
    var res = new Array(n);
    // 维护一个单调栈，用于存储索引，保持 nums[stack[i]] 单调递减
    var stack = [];
    // 从右往左遍历数组，倒着将元素索引入栈
    for (var i = n - 1; i >= 0; i--) {
      /**
       * 这里是关键
       * 每次遍历都要用当前元素和栈顶元素进行对比
       * 若是当前元素打破了单调性，则弹出栈顶元素，继续对比，直到当前元素不再打破单调性，或者栈为空为止
       * 此时再将当前元素压入栈
       *
       * 这里是找右侧第一个更大元素
       * 若是当前元素大于栈顶元素，说明当前栈顶元素不是右侧第一个更大元素，将其弹出栈
       * 直到某一个栈顶元素大于当前元素
       * 因为是从右往左进行遍历的，所以此时栈顶元素就是当前元素的右侧第一个更大元素
       * 这时将其记录到结果数组中，再将当前元素压入栈
       *
       * 依次类推，直到当前元素不再打破单调性，或者栈为空为止
       */
        while (stack.length > 0 && nums[i] >= nums[stack.at(-1)] ) {
            stack.pop();
        }
        // 若栈为空，说明当前元素没有右侧第一个更大元素，记录 -1
        // 若栈不为空，说明当前元素有右侧第一个更大元素，栈顶元素就是当前元素的右侧第一个更大元素
        res[i] = stack.length == 0 ? -1 : nums[stack.at(-1)];
        stack.push(i);
    }
    return res;
}

// 用例
console.log(nextGreaterRight([2,1,2,4,3])); // [4,2,4,-1,-1]
```

**解析：**

- 遍历到 3 时，栈为空，说明其右侧没有更大元素，记录 -1，将 3 压入栈
- 遍历到 4 时，4 大于栈顶元素 3，将栈顶元素 3 弹出，此时栈为空，说明其右侧没有更大元素，记录 -1，将 4 压入栈
- 遍历到 2 时，2 小于栈顶元素 4，说明栈顶元素 4 就是当前元素 2 的右侧第一个更大元素，记录 4，将 2 压入栈
- 遍历到 1 时，1 小于栈顶元素 2，说明栈顶元素 2 就是当前元素 1 的右侧第一个更大元素，记录 2，将 1 压入栈
- 遍历到 2 时
  - 2 大于栈顶元素 1，将栈顶元素 1 弹出，此时栈中元素 [2, 4]，继续比较
  - 2 等于栈顶元素 2，将栈顶元素 2 弹出，此时栈中元素 [4]，继续比较
  - 2 小于栈顶元素 4，说明栈顶元素 4 就是当前元素 2 的右侧第一个更大元素，记录 4，将 2 压入栈
- 最后返回 [4,2,4,-1,-1]

> 从右往左反向遍历是精髓，栈的特点是先进后出，所以从右往左遍历，倒着入栈，也就是正着出栈，而且可以将不符合条件的中间元素弹出，只保留有用的元素
>
> leetcode [1944] 队列中可以看到的人数
>
> 输入：heights = [10,6,8,5,11,9]
>
> 输出：[3,1,2,1,1,0]
>
> 第 0 个人能看到编号为 1 ，2 和 4 的人
>
> 第 1 个人能看到编号为 2 的人
>
> 第 2 个人能看到编号为 3 和 4 的人
>
> 第 3 个人能看到编号为 4 的人
>
> 第 4 个人能看到编号为 5 的人
>
> 第 5 个人谁也看不到因为他右边没人
>
> 第 5 个人谁也看不到因为他右边没人
>
> 从右往左遍历，遍历到 8 时，栈中元素为 [11, 5]，会将无效元素 5 弹出，仅保留有用元素 11
>
> 那遍历到 10 时，栈中元素便为 [6, 8, 11]，这时对于元素 10 来说，其正好只能看到这三个元素
>
> 元素 5 因为被元素 8 挡着，元素 10 是看不到元素 5 的
>
> 但若选择从左往右遍历，虽然同样能找到元素 10 的右侧第一个更大元素 11，但却无法将元素 5 排除，得不到正确答案
#### 1.5.1、每日温度

**描述：**给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指在第 `i` 天之后，才会有更高的温度，如果气温在这之后都不会升高，请在该位置用 `0` 来代替


**示例：**

```markdown
输入：temperatures = [73,74,75,71,69,72,76,73]
输出：[1,1,4,2,1,1,0,0]
```

**题解：**

```javascript
// dailyTemperatures: 输入 temperatures，返回等待天数数组
function dailyTemperatures(temperatures) {
  const n = temperatures.length;
  // 初始化结果数组，所有位置都初始化为 0，表示没有等待天数
  const res = new Array(n).fill(0);
  // 维护一个单调栈，用于存储索引，保持 temperatures[stack[i]] 单调递减
  const stack = [];

  // 遍历温度数组
  for (var i = n - 1; i >= 0; i--) {
    while (stack.length > 0 && temperatures[i] >= temperatures[stack.at(-1)]) {
      // 弹出栈顶元素，获取栈顶元素的索引
      const idx = stack.pop();
    }

    res[i] = stack.length == 0 ? 0 : stack.at(-1) - i;
    // 将当前元素的索引压入栈
    stack.push(i);
  }
  return res;
}

// 用例
console.log(dailyTemperatures([73,74,75,71,69,72,76,73]));
// 输出: [1,1,4,2,1,1,0,0]
```

**解析：**

- 栈里面存储的是温度数组的索引
- 每次遍历都要用当前温度和栈顶温度进行对比，当前温度大于栈顶温度时，说明找到了当前温度对应的下一个更高温度，将栈顶温度弹出，同时将当前温度压入栈

### 二、队列

