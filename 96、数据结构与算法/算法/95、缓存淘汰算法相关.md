## 缓存淘汰算法

### 一、前言

#### 1.1、缓存与淘汰问题的本质

**缓存（Cache）**的核心目标是：**用有限的存储空间，尽可能提高数据访问命中率**

无论是 **CPU Cache**、浏览器缓存、本地内存缓存，还是 **Redis** 这类分布式缓存系统，都面临一个不可回避的问题：**容量是有限的**

当缓存已满而新的数据需要写入时，就必须决定：“谁该被删除，谁该被保留”，用于做出这一决策的规则与策略，统称为**缓存淘汰算法（Cache Eviction Algorithm）**

#### 1.2、常见的缓存淘汰算法

工程实践中，常见的缓存淘汰算法包括：

| 算法 | 全称                  | 淘汰依据     | 特点               |
| ---- | --------------------- | ------------ | ------------------ |
| FIFO | First In First Out    | 写入顺序     | 实现简单，效果有限 |
| LRU  | Least Recently Used   | 最近使用时间 | 最常用，适应性强   |
| LFU  | Least Frequently Used | 使用频率     | 保留长期热点       |

在绝大多数业务系统中，**LRU 与 LFU 是最具代表性、也是最常用的两类算法

### 二、LRU（Least Recently Used）

**LRU** 的核心是：

> **如果一个数据最近被访问过，那么在不久的将来它仍然有较高的被访问概率**

因此，当缓存空间不足时，**LRU** 会优先淘汰**“最久没有被访问”的数据项**

**LRU 实现方式：**

在算法层面，一个合格的 **LRU** 实现必须保证：

- `get` 操作时间复杂度为 `O(1)`
- `put` 操作时间复杂度为 `O(1)`

为满足这一要求，**最经典实现方案是：哈希表 + 双向链表**

- **哈希表（Map）**：实现 `key → 节点` 的**快速定位**

- **双向链表**：**维护访问顺序**，支持 `O(1)` 插入、删除和移动
  - 「单向链表」删除任意节点需要找前一个节点，其复杂度是 `O(n)`
  - 「双向链表」直接删除即可，其复杂度是 `O(1)`

```js
// 节点结构
class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}

class LRUCache {
  constructor(capacity) {
    // 缓存的容量
    this.capacity = capacity;
    this.map = new Map();

    // 哨兵节点，避免边界判断
    this.head = new Node(null, null); // 最近使用
    this.tail = new Node(null, null); // 最久未使用
    
    // 初始化双向链表的数据
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  get(key) {
    // 根据 key 找到对应的 node
    const node = this.map.get(key);
    if (!node) return -1;
    // 再将 node 移到链表头部
    this._moveToHead(node);
    return node.value;
  }

  put(key, value) {
    // 先检查 key 对应的 node 是否存在，若存在着则更新 value，同时移到链表头部
    const node = this.map.get(key);
    if (node) {
      node.value = value;
      this._moveToHead(node);
      return;
    }

    // 若是不存在，则新建 node 并放置链表头部
    const newNode = new Node(key, value);
    this.map.set(key, newNode);
    this._addToHead(newNode);

    // 若是已经超出缓存容量，则将链表尾部的节点给删除
    if (this.map.size > this.capacity) {
      const lru = this._removeTail();
      this.map.delete(lru.key);
    }
  }

  // 将节点添加到链表头部
  _addToHead(node) {
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next.prev = node;
    this.head.next = node;
  }

  // 将节点删除
  _removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }

  // 将节点先删除，再移动至链表头部
  _moveToHead(node) {
    this._removeNode(node);
    this._addToHead(node);
  }

  // 将链表尾部节点删除
  _removeTail() {
    const node = this.tail.prev;
    this._removeNode(node);
    return node;
  }
}
```

### 三、LFU（Least Frequently Used）

**LFU** 的核心假设是：

> **被访问次数越多的数据，长期来看价值越高**

因此，在缓存需要淘汰数据时，**LFU** 会优先删除**访问频率最低**的缓存项

**LFU 的实现方式**

**LFU** 的典型实现需要同时满足：

- `get` / `put` 操作 `O(1)`
- 能快速找到当前最小访问频次

**核心数据结构：**

- **keyMap**：`key → 节点`
- **freqMap**：`freq → 双向链表`
- **minFreq**：当前缓存中的最小频次

```js
/**
 * 缓存节点
 * 每个节点除了 key / value，还必须记录：
 * - freq：当前访问频次
 * - prev / next：用于双向链表（同频次 LRU）
 */
class Node {
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.freq = 1;       // 新节点初始访问频次必须是 1
    this.prev = null;
    this.next = null;
  }
}

/**
 * 双向链表
 * 作用：在同一个 freq 下，维护 LRU 顺序
 * - 头部：最近使用
 * - 尾部：最久未使用
 *
 * 使用哨兵节点，避免大量边界判断
 */
class DoublyLinkedList {
  constructor() {
    this.head = { prev: null, next: null }; // 虚拟头节点
    this.tail = { prev: null, next: null }; // 虚拟尾节点
    this.head.next = this.tail;
    this.tail.prev = this.head;
    this.size = 0;
  }

  /**
   * 将节点插入到链表头部（最近使用）
   */
  addToHead(node) {
    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;
    this.size++;
  }

  /**
   * 从链表中移除指定节点
   */
  removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
    this.size--;
  }

  /**
   * 移除尾部节点（最久未使用）
   * LFU 淘汰时会用到
   */
  removeTail() {
    if (this.size === 0) return null;
    const node = this.tail.prev;
    this.removeNode(node);
    return node;
  }
}


class LFUCache {
  constructor(capacity) {
    // 缓存容量
    this.capacity = capacity;
    this.size = 0;

    // key -> Node，用于 O(1) 定位节点
    this.nodeMap = new Map();

    // freq -> DoublyLinkedList
    // 每个频次对应一个 LRU 链表
    this.freqMap = new Map();

    // 当前缓存中的最小访问频次
    this.minFreq = 0;
  }
  
  
  /**
   * 提升节点访问频次
   * 这是 LFU 的核心逻辑
   */
  _increaseFreq(node) {
    const freq = node.freq;
    const list = this.freqMap.get(freq);

    // 从原频次链表中移除
    list.removeNode(node);

    /**
     * 如果：
     * - 当前频次等于 minFreq
     * - 且该频次链表已空
     * 则 minFreq 必须 +1
     */
    if (freq === this.minFreq && list.size === 0) {
      this.minFreq++;
    }

    // 提升频次
    node.freq++;

    // 加入新的频次链表
    let nextList = this.freqMap.get(node.freq);
    if (!nextList) {
      nextList = new DoublyLinkedList();
      this.freqMap.set(node.freq, nextList);
    }
    nextList.addToHead(node);
  }

  /**
   * 获取缓存值
   * - 若不存在，返回 -1
   * - 若存在，访问频次 +1，并更新位置
   */
  get(key) {
    if (!this.nodeMap.has(key)) return -1;

    const node = this.nodeMap.get(key);
    this._increaseFreq(node);
    return node.value;
  }

  /**
   * 写入缓存
   */
  put(key, value) {
    if (this.capacity === 0) return;

    // key 已存在：更新值 + 提升频次
    if (this.nodeMap.has(key)) {
      const node = this.nodeMap.get(key);
      node.value = value;
      this._increaseFreq(node);
      return;
    }

    // 缓存已满，需要淘汰
    if (this.size === this.capacity) {
      // 一定从 minFreq 对应的链表中淘汰
      const list = this.freqMap.get(this.minFreq);
      const removedNode = list.removeTail();
      this.nodeMap.delete(removedNode.key);
      this.size--;
    }

    // 插入新节点
    const newNode = new Node(key, value);
    this.nodeMap.set(key, newNode);

    // freq = 1 的链表
    let list = this.freqMap.get(1);
    if (!list) {
      list = new DoublyLinkedList();
      this.freqMap.set(1, list);
    }
    list.addToHead(newNode);

    // 新节点一定是最小频次
    this.minFreq = 1;
    this.size++;
  }
}
```
