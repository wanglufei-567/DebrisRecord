## 丑数专题

### 一、丑数的定义

**丑数（Ugly Number）**是指只包含质因数 2、3、5 的正整数，换句话说，丑数只能被 2、3、5 整除，不能包含其他质因数

最小的丑数是 1（有些定义不包括 1，但 LeetCode 题目通常包含 1 作为第一个丑数）

常见的丑数序列如下：

```
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, ...
```

丑数的性质：
- 任意一个丑数都可以表示为 `2^x * 3^y * 5^z`（x, y, z 均为非负整数）的形式
- 丑数序列是递增的

### 二、如何判断一个数是丑数

#### 1. 题目描述

> 给定一个整数 n ，判断 n 是否为丑数。如果是，返回 true ；否则，返回 false 
> 丑数就是只包含质因数 2、3、5 的正整数。

#### 2. 解题思路

- 不断用 2、3、5 去整除 n，直到不能整除为止。
- 如果最后剩下 1，则说明 n 只包含 2、3、5 这三个质因数，是丑数。
- 如果最后剩下的不是 1，说明 n 包含其他质因数，不是丑数。

#### 3. 代码实现

```javascript
var isUgly = function(n) {
    if (n <= 0) return false;
    const factors = [2, 3, 5];
    for (const factor of factors) {
        while (n % factor === 0) {
            n /= factor;
        }
    }
    return n === 1;
};
```

#### 4. 复杂度分析
- 时间复杂度：O(log n)
- 空间复杂度：O(1)

### 三、如何求第 n 个丑数

#### 1. 题目描述

> 给定一个整数 n ，找出并返回第 n 个丑数。

#### 2. 解题思路

- 使用三个指针分别追踪下一个要被乘以 2、3、5 的丑数。
- 每次取三个候选丑数中的最小值，加入丑数序列。
- 谁“贡献”了最小值，谁的指针往前走一步。
- 保证丑数序列递增且无重复。

#### 3. 代码实现

```javascript
var nthUglyNumber = function(n) {
    // 丑数序列，ugly[0] = 1
    const ugly = [1];
    // 三个指针，分别指向下一个要被乘以 2、3、5 的丑数在 ugly 数组中的下标
    let i2 = 0, i3 = 0, i5 = 0;
    // 生成 n 个丑数
    for (let k = 1; k < n; k++) {
        // 下一个候选丑数分别是 2、3、5 乘以对应指针指向的丑数
        const next2 = ugly[i2] * 2;
        const next3 = ugly[i3] * 3;
        const next5 = ugly[i5] * 5;
        // 取最小值作为下一个丑数
        const nextUgly = Math.min(next2, next3, next5);
        ugly.push(nextUgly);
        // 谁贡献了最小值，谁的指针往前走一步（可能有多个指针同时前进，避免重复）
        if (nextUgly === next2) i2++;
        if (nextUgly === next3) i3++;
        if (nextUgly === next5) i5++;
    }
    // 返回第 n 个丑数
    return ugly[n - 1];
};
```

#### 4. 复杂度分析
- 时间复杂度：O(n)
- 空间复杂度：O(n)