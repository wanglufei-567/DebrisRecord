## 从输入 URL 到 Web 页面加载完成的过程

### 一、前言

#### 1.1、名词解释

- **协议栈**
  - 解释：**计算机「网络控制软件」**
  - 作用：将「应用信息」打包并加上「目的地地址」等「**控制信息**」
  - 用快递类比理解：
    - 将快递打包然后再写上发件人和收件人信息
    - 当然还有其他功能，如发生通信错误时重新发包、调节发送效率等
- **网卡**
  - 解释：负责「以太网」或「无线网络」通信的**「硬件」**
  - 作用：将应用信息转换为电信号通过网络发出去
- **Socket 库**
  - 解释：**Socket 库**是用于调用网络功能的「**程序组件集合**」，是操作系统内置的网络库
  - 作用：**Socket 库**中包含很多用于发送和接受数据的程序组件
- **套接字**
  - 解释：**套接字只是个概念没有实体**，若一定要赋予它一个实体，那协议栈中存放的控制信息就是套接字
  - 作用：协议栈内部中存在一块内存空间，记录了用于控制通信操作的控制信息
    - 比如：通信对象的IP地址、端口号、通信操作的进行状态等
- **描述符**
  - 作用：应用程序通过**「描述符」**这一类似于号码牌的东西来识别套接字
- **端口号**
  - 作用：识别应用程序的**「套接字」**的，客户端和服务端之间用来识别对方套接字的机制

#### 1.2、类比理解

- **包(Packet)**：类似于快递中的概念，**「包」**相当于**「快递包裹」**，而**「路由器」**和**「交换机」**则相当于快递公司的**「分拣处理区」**
  - 包的「**头部**」存有目的地等「**控制信息**」，通过许多交换机和路由器的接力，就可以根据这些控制信息进行分拣，然后将它们一步一步地搬运到目的地

- **网络**: 搬运网络包（数字信息）的机制加上「浏览器」、「服务器」这些网络应用程序就构成了「网络」的全貌
- **IP地址**：相当于现实中的XX号XX室一样，**「IP 地址」**就是网络中的**「地址」**
  - ”号“对应的是网络号
  - ”室“对应的是主机号

- **子网掩码**：**「IP 地址」**是32比特的数字，按照8比特一组分为四组，再用十进制表示，包含了网络号和主机号，**「子网掩码」**是表示网络号和主机号的边界

### 二、浏览器解析 URL 并请求 HTML 的过程

1. ##### 解析 URL 生成 HTTP 请求信息
   1. **HTTP 协议**定义了客户端和服务端交互的信息「内容」和「步骤」
      - **HTTP **请求消息中包含的内容是“对什么”和“进行怎么样的操作”两个部分
        - “对什么”部分是URI
        - “进行怎么样的操作”是方法
   2. **浏览器**虽然可以解析 **URL** 生成 **HTTP** 请求消息，但浏览器本身是**不具备**将消息发送到网络中的功能的，因此需要委托**操作系统**实现
      - 在委托**操作系统**发送消息时，必须要提供服务端的**IP地址**，所以在根据 **URL** 生成请求消息之后，下一步骤就是获取服务端**IP地址**
   
2. ##### DNS 域名解析

   1. 浏览器调用 **Socket 库**中的 **DNS解析器**查询 **IP地址**
      - 查询 **IP 地址**其实也是一次网络通信，是 **Socket 库**和 **DNS 服务器**的通信
      - ==**DNS 服务器**的 **IP 地址**已经配置在系统里面了==，传输层的协议使用的是 **UDP 协议**而不是 **TCP 协议**（为什么是UDP？后面再补充）
      - 查询到 **IP 地址**之后，**Scoket 库**会将 **IP 地址**写入到**浏览器**提供的内存中去，服务端的 **IP 地址**是存在浏览器中的
        - **IP 地址**通常会缓存几分钟到几小时
        - 后续过程，**==客户端只和目标服务器通信，DNS 不再参与==**
      - 示例：
        - 在浏览器中输入网址，比如 `https://example.com`
        - 系统通过 **DNS** 查询，将 `example.com` 解析为 **IP 地址**（比如 `93.184.216.34`）
        - ==这一步**只是纯粹将域名转成 IP 地址**，与 **HTTPS/TLS** 没有任何关系==
      
      > 本地 `hosts` 文件是操作系统中一个用来做**域名到 IP 地址映射**的静态文件，位于不同系统中的路径一般是：
      >
      > - **Windows**：`C:\Windows\System32\drivers\etc\hosts`
      > - **Linux/macOS**：`/etc/hosts`
      >
      > **作用与原理**
      >
      > 1. **优先级高于 DNS 查询**：
      >    - 操作系统在进行域名解析时，首先会查找 `hosts` 文件，如果文件中存在对应的域名映射记录，就直接返回对应的 IP 地址，**不再向 DNS 服务器发起查询**
      > 2. **跳过 DNS 解析**：
      >    - 由于 `hosts` 文件中的记录是本地静态配置的，因此能直接跳过外部 **DNS 解析**过程，加快解析速度，并且可用于调试或覆盖某些域名解析结果
      >
      > **举例说明**
      >
      > 假设 `hosts` 文件中有一条：
      >
      > ```lua
      > 192.168.1.100  mytest.local
      > ```
      >
      > 当访问 `mytest.local` 时，系统会直接将它解析成 `192.168.1.100`，不再发送 **DNS** 请求
      >
      > 应用场景
      >
      > - **本地开发调试**：将开发服务器的域名映射到本地或内网 **IP**
      > - **屏蔽网站**：将某些广告或恶意网站域名映射到 `127.0.0.1`
      > - **绕过 DNS 污染**：临时手动指定正确 **IP 地址**

3. ##### 委托协议栈发送消息（其实就是建立TCP连接，根据IP地址和默认80端口，和服务器建立TCP连接）

   知道了 **IP 地址**之后就可以委托**操作系统**内部的**协议栈**向这个目标 **IP 地址**发送消息了

   - 首先，客户端应用程序传递 **IP 地址**和端口给系统协议栈，**协议栈**中的 **tcp 模块**会将这些信息写入**头部**，**tcp 模块**又委托 **ip 模块**进行消息传递 
   
   - 当消息传递到服务端之后 <!--服务端的服务进程是默认打开且待连接状态-->

     - 服务端的 **tcp 模块**会根据客户端传递过来的**端口号**找到对应的**套接字 **<!--协议栈中内存保存的控制信息-->

     - 并且对应**套接字**会写入客户端的 **IP 地址**并修改连接状态为「正在连接」 <!--默认是未连接-->
   
     - 操作完成后服务端会返回**响应**给客户端，在返回头部中写入信息 <!--ACK，用来告诉客户端收到请求的信息了）-->
   
       > 浏览器（或客户端）在 **TCP** 建立后，会发起 **TLS** 握手；
       >
       > 服务器在 **TLS** 握手响应（**Server Hello**）阶段，**通过 TLS 协议发送证书链（包括服务器证书和中间证书）**；
       >
       > 这部分数据属于**加密层（TLS 层）**的数据，**发生在 HTTP 请求之前**；
   
   - 当客户端的 **tcp 模块**收到**响应信息**后会根据**响应头**判断是否连接成功
   
     - 连接成功的话会将服务端的 **ip** 和端口等信息写入到自己的套接字中
   
     - 并修改连接状态为连接完毕
   
     - 并再次发送信息 <!--还是只有头部信息，没有具体的数据--> 给服务端，通知服务端自己收到了刚才的响应信息
   
       > 客户端 **HTTPS 证书**验证是在 **TLS 握手后半段**完成的，未通过就会直接断开连接，**HTTP** 根本不会发送
       >
       > 系统（如 **Linux/macOS**）和某些软件（如 **Chrome**）会维护各自的**根证书信任库**
       >
       > **绝大多数情况下，客户端的系统/运行时会自动验证证书**，这一机制是内置的
       >
       > 常见情形如下：
       >
       > | 客户端类型                   | 是否自动验证证书       | 证书验证逻辑依赖于                        |
       > | ---------------------------- | ---------------------- | ----------------------------------------- |
       > | 浏览器（Chrome、Firefox 等） | ✅ 自动验证             | 浏览器内置的证书信任库                    |
       > | curl 等命令行工具            | ✅ 自动验证（默认）     | 系统的 CA 信任列表（如 `/etc/ssl/certs`） |
       > | Node.js、Python 等程序       | 默认验证，但可配置关闭 | 使用对应语言的 TLS 实现                   |
   
   
   <!--其实以上的过程就是TCP的三次握手，按照自己的理解去写的，有点拉胯，有单独的TCP协议笔记，比较详细-->
   
   > **「三次握手」**的语义化理解就是：
   >
   > - 第一次握手：客户端向服务端发送消息说：**我要建立连接**（`SYN：1, seq:j`）
   > - 第二次握手：服务端向客户端发送消息说：**同意进行连接**（`SYN：1,ACK:1,ack:j+1,seq:x`）
   > - 第三次握手：客户端向服务端发送消息说：**连接成功了可以通信了**（`ACK:1, ack:x+1`）
   >
   > 其实做的事情主要是交换 ack 和 `seq`，要保证后面通信的时候的数据的完整性
   >
   > 
   >
   > **「四次挥手」**的语义化理解就是：
   >
   > - 第一次挥手：客户端向服务端发送消息说：**我要断开连接了**（`FIN：M`）
   > - 第二次挥手：服务端向客户端发送消息说：**收到了**（`ack: M+1`）
   > - 第三次挥手：服务端向客户端发送消息说：**我也要断开连接了**（`FIN：N`）
   > -  第四次挥手：客户端向服务端发送消息说：**收到了**（`ACK：1，ack:k+1`）
   
   ### 三、浏览器解析 HTML 的过程
   
   1. **HTML 文档的加载与解析**
         - 当浏览器请求一个 **HTML** 页面时，它会先接收到 **HTML** 文档并开始==逐行解析==
         - 这意味着 **HTML** 文档解析和其他资源（如 **CSS** 和 **JavaScript** 文件）的加载可以==并行进行==，而不是等待整个 **HTML** 文档下载完成后才开始其他操作 <!--整个 HTML 文档指的是 HTML、CSS、JS 全部-->
   
   
   2. **CSSOM** 树的构建
   
         - 在解析 **HTML** 文档的过程中
   
           - 当浏览器遇到 `<style>` 标签，会==立即开始解析== **内联样式**
           - 当浏览器遇到 `<link>` 标签时，会==立即开始下载并解析== **CSS 文件**
         
         - 浏览器在解析 **CSS** 时会==继续解析== **HTML**，但会==阻塞渲染==（即不会立即显示页面），直到所有的 **CSS** 文件加载并解析完成
         
           <!--浏览器一边解析HTML，一边解析CSS-->
         
           <!--因为 CSS 文件可能会影响页面的布局和样式，浏览器需要等它们加载完成后才能正确渲染页面-->
         
         - 随着每个 **CSS 文件**或**内联样式**的解析完成，浏览器会逐步将这些解析结果加入到 **CSSOM** 树中，逐步构建 **CSSOM** 树
   
   
   3. **JavaScript** 文件的加载与执行
      
         - 当浏览器遇到 `<script>` 标签（用于加载或内联 **JavaScript**）时，行为取决于脚本的类型和属性：
           - 默认情况下：浏览器会==暂停 **HTML** 文档的解析==，==等待 **JavaScript** 文件加载完成并执行==，这可能会==阻塞页面的渲染==，直到脚本执行完毕
           
           - `async` 属性：浏览器会==继续解析== **HTML**，同时==异步加载== **JavaScript** 文件，一旦文件==加载完成==，浏览器会==立即暂停解析并执行该脚本==
           
           - `defer` 属性：浏览器会==继续解析== **HTML**，直到==文档解析完成才会执行== **defer** 脚本，这种方式==不会阻塞==页面的渲染，并且多个 **defer** 脚本会按照它们在 **HTML** 中的顺序执行
           
             <!--脚本会在文档解析完成后，触发 DOMContentLoaded 事件前执行-->
   
   
   4. **DOM** 树的构建
      - 在解析 **HTML** 的过程中，浏览器逐步构建 **DOM** 树 <!--是在解析 HTML 的同时便开始构建 DOM 树了-->
      - 如果遇到阻塞的 **JavaScript**（即没有 `async` 或 `defer` 属性的 `<script>` 标签），**DOM** 构建会暂停，直到脚本执行完毕
   5. **Render** 树的构建
   
      - **Render** 树是在 **DOM** 树和 **CSSOM** 树构建完成后生成的
      - 浏览器将 **DOM** 树中的每个可视节点（即具有视觉表现的节点）与相应的 **CSS** 样式结合，生成 **Render** 树
   6. **DOMContentLoaded** 事件
   
      - **触发时机**: `DOMContentLoaded`事件在 **HTML文档被完全加载和解析** 完成后触发，此时，**DOM **树已经完全构建完成，但外部资源（如图片、样式表、框架等）可能还没有完全加载。
      - **具体阶段**: 该事件发生在浏览器构建完**DOM ** 树和**CSSOM** 树 之后，**渲染树（Render Tree）已经生成**，但还没有完成布局和绘制
   7. **布局**、**绘制**、**合成和显示**
   8. **Load** 事件
      - 当所有资源（包括图片、**CSS**、**JavaScript**等）都已加载完毕，浏览器会触发 **load** 事件，这表示页面及其所有依赖资源已经完全加载并准备就绪
   
   
   **总结**
   
   - **HTML** 文档：逐行解析并构建 **DOM** 树
   - **CSS**：**CSS** 的加载和解析会阻塞页面的渲染
   - **JavaScript**：如果是默认加载，**JavaScript** 的加载和执行会阻塞 **DOM** 的构建和页面的渲染，如果使用 `defer` 或 `async`，则不会阻塞
   - **DOMContentLoaded** 事件：**Render** 树构建完成时触发
   - **Load** 事件：页面及所有资源加载完成时触发
   
   







