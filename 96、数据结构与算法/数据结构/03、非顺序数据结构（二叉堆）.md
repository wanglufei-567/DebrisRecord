## 非顺序数据结构（二叉堆）

### 一、二叉堆的基本概念

**二叉堆**（**Binary Heap**）是一种**完全二叉树**（**complete binary tree**），常用于实现「**优先队列**」（**Priority Queue**）

有以下两种特性：

- 结构特性
  - 必须是完全二叉树（除了最底层叶节点，其余层节点都填满，底层节点从左往右依次排列）
- 堆特性
  - 二叉堆不是**最小堆（Min Heap）**就是**最大堆（Max Heap)**
    - **最小堆**
      - 每个节点的值 **小于等于** 其左右子节点的值
      - 堆顶（根节点）是**最小值**
    - **最大堆**
      - 每个节点的值 **大于等于** 其左右子节点的值
      - 堆顶是**最大值**

<img src="https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/min_heap_and_max_heap.png" alt="小顶堆与大顶堆" style="zoom:50%;" />

#### 2.1、二叉堆实现方式

二叉堆是一种完全二叉树，适合使用「**顺序存储结构**」来实现，即使用**数组**实现，这样就不用显式地建立树结构，利用节点之间的索引关系来维护父子节点关系

- 对于一个索引为 `i` 的节点：
  - 父节点索引为：`(i - 1) / 2`
  - 左子节点索引为：`2 * i + 1`
  - 右子节点索引为：`2 * i + 2`

这种实现方式具备高效的空间利用率和操作性能

[![堆的表示与存储](https://raw.githubusercontent.com/wanglufei561/picture_repo/master/assets/representation_of_heap.png)](https://www.hello-algo.com/chapter_heap/heap.assets/representation_of_heap.png)

#### 2.2、二叉堆为何适用于实现优先级队列

1. **快速获取最高优先级** <!--最主要的优势-->
   
   - 在二叉堆中，**最高优先级**的元素永远在**堆顶**
   - 获取最高优先级元素，只需要 O(1) 时间，非常快
   
2. **高效维护顺序** <!--很重要的特点-->
   
   - 插入新元素时，自动上浮到正确位置
   
   - 删除元素时，自动下沉到正确位置
   
     <!--这些操作都只需要 O(log n) 的时间-->
   
3. **节省空间**
   - 用数组就能实现，不需要额外的指针
   - 内存使用非常紧凑

4. **使用灵活**
   
   - 可以轻松实现最大堆和最小堆
   - 通过比较函数可以自定义优先级规则

就像是一个自动排序的数组，每次都能快速找到最重要的那个元素，非常适合需要频繁获取最高优先级任务的场景

### 二、二叉堆的实现

先实现一个**最小堆（Min Heap）**

```javascript
const Compare = {
  LESS_THAN: -1,
  BIGGER_THAN: 1,
}

// 比较函数
function defaultCompare(a, b) {
  if (a === b) {
    return 0
  }
  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THANz
}

/**
 * 最小堆
 * 最小堆的根节点是最小的元素
 */
class MinHeap {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn
    this.heap = []
  }
  
  // 获取左子节点的索引
  getLeftIndex(index) {
    return 2 * index + 1
  }

  // 获取右子节点的索引
  getRightIndex(index) {
    return 2 * index + 2
  }

  // 获取父节点的索引
  getParentIndex(index) {
    return Math.floor((index - 1) / 2)
  }
  
  size() {
    return this.heap.length
  }

  isEmpty() {
    return this.size() === 0
  }

  findMinimum() {
    return this.isEmpty() ? undefined : this.heap[0]
  }
}
```

#### 2.1、元素入堆

插入新节点时，先将其插入到数组末尾，让后在将其上浮到正确位置

```javascript
class MinHeap {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn
    this.heap = []
  }
  
  //...
  
  // 插入元素
  insert(value) {
    if (value !== null) {
      this.heap.push(value)
      // 上移操作, 将新插入的元素上移到合适的位置，从最后一个元素开始往上移动
      this.siftUp(this.heap.length - 1)
      return true // 插入成功
    }
    return false // 插入失败
  }

  // 交换位置
  swap(index1, index2) {
    const temp = this.heap[index1]
    this.heap[index1] = this.heap[index2]
    this.heap[index2] = temp
  }

  // 上移操作
  siftUp(index) {
    // 先获取父节点的索引
    let parent = this.getParentIndex(index)
    // 如果当前节点大于父节点，则交换位置
    while (
      index > 0 &&
      this.compareFn(this.heap[index], this.heap[parent]) === Compare.BIGGER_THAN
    ) {
      // 交换位置
      this.swap(parent, index)
      index = parent
      parent = this.getParentIndex(index)
    }
  }
  
 }
```

这段实现的精髓在于上移操作

```javascript
  // 上移操作
  siftUp(index) {
    // 先获取父节点的索引
    let parent = this.getParentIndex(index)
    // 如果当前节点大于父节点，则交换位置
    while (
      index > 0 &&
      this.compareFn(this.heap[index], this.heap[parent]) === Compare.BIGGER_THAN
    ) {
      // 交换位置
      this.swap(parent, index)
      index = parent
      parent = this.getParentIndex(index)
    }
  }
```

在数组末尾插入节点之后，需要使其和父节点进行比较，若是小于父节点，则二者交换位置，之后再继续往上进行比较直到当前节点大于父节点或者插入的节点被移动至根节点

**示例：**

假设当前堆为：

```markdown
      2
     / \
    5   3
   /
  7
```

数组表示：[2, 5, 3, 7]

现在插入元素 1：

- 步骤1：先把 1 放到数组末尾
  - 数组结果：[2, 5, 3, 7, 1]

- 步骤2：上浮，与父节点比较并交换

  - 1 和 5 交换 → [2, 1, 3, 7, 5]

  - 1 和 2 交换 → [1, 2, 3, 7, 5]

最终堆结构：

```markdown
      1
     / \
    2   3
   / \
  7   5
```

#### 2.2、堆顶元素出堆

堆顶元素是根节点，将其移走之后，其他节点在数组中的索引都会变化，使得后序的堆化变得难以处理，因此采用末尾元素填充到堆顶，再将其下沉到正确位置上

```javascript
class MinHeap {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn
    this.heap = []
  }
  
  //...
  /**
   * 移除最小值
   * 先移除堆顶元素，然后进行下移操作，将最后一个元素移到根节点
   * 然后进行下移操作，将根节点下移到合适的位置，从而满足堆的性质
   */
  extract() {
    if (this.isEmpty()) {
      return undefined
    }
    if (this.size() === 1) {
      return this.heap.shift()
    }
    const removedValue = this.heap[0]
    // 将最后一个元素移到根节点
    this.heap[0] = this.heap.pop()
    // 下移操作, 将根节点下移到合适的位置，从根节点开始往下移动
    this.siftDown(0)
    return removedValue
  }

  /**
   * 下移操作
   * 将根节点下移到合适的位置，从而满足堆的性质
   *
   * 下移过程：
   * 1. 从当前节点开始，比较当前节点与其左右子节点的值
   * 2. 找到三个节点中值最小的节点（对于最小堆）
   * 3. 如果最小值不是当前节点，则将当前节点与最小值节点交换位置
   * 4. 递归地对交换后的位置继续执行下移操作
   * 5. 重复此过程直到当前节点比其所有子节点都小，或者到达叶子节点
   *
   * @param {number} index 当前节点的索引
   */
  siftDown(index) {
    // element 用于记录当前节点、左子节点、右子节点中值最小的节点索引
    // 初始化为当前节点索引，后续会根据比较结果更新为最小值节点的索引
    let element = index
    // 获取左子节点的索引
    const left = this.getLeftIndex(index)
    // 获取右子节点的索引
    const right = this.getRightIndex(index)
    // 获取堆的大小
    const size = this.size()
    // 如果左子节点存在，并且左子节点的值小于当前 element 指向的节点值，则更新 element 为左子节点索引
    if (
      left < size &&
      this.compareFn(this.heap[element], this.heap[left]) === Compare.BIGGER_THAN
    ) {
      element = left
    }
    // 如果右子节点存在，并且右子节点的值小于当前 element 指向的节点值，则更新 element 为右子节点索引
    // 注意：这里比较的是右子节点与当前 element（可能是原节点或左子节点）的值
    if (
      right < size &&
      this.compareFn(this.heap[element], this.heap[right]) === Compare.BIGGER_THAN
    ) {
      element = right
    }
    if (element !== index) {
      this.swap(element, index)
      this.siftDown(element)
    }
  }
}
```

**示例：**

现在堆为：

```markdown
      1
     / \
    2   3
   / \
  7   5
```

数组表示：[1, 2, 3, 7, 5]

- 步骤1：移除堆顶 1，把最后一个元素 5 移到堆顶
  - 数组结果：[5, 2, 3, 7]

- 步骤2：下沉，与子节点比较并交换

  - 5 和 2 交换 → [2, 5, 3, 7]

  - 5 已经比子节点都小，结束

最终堆结构：

```markdown
      2
     / \
    5   3
   /
  7
```

### 2.3、最大堆

最大堆的实现可以直接继承最小堆，只需要将对比方法替换即可

```javascript
function reverseCompare(compareFn) {
  return (a, b) => compareFn(b, a)
}

/**
 * 最大堆
 * 最大堆的根节点是最大的元素
 *
 * 最大堆继承自最小堆
 * 只需要重写 compareFn 函数
 */
class MaxHeap extends MinHeap {
  constructor(compareFn = defaultCompare) {
    super(compareFn)
    this.compareFn = reverseCompare(compareFn)
  }
}
```

