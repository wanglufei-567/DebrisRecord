## 滑动窗口算法

### 一、前言

#### 1.1、概述

**「滑动窗口」**（**Sliding Window**）是一种高效处理数组或字符串**「连续区间问题」**的算法技巧，通过维护一个**「动态窗口」**来快速求解满足条件的连续子数组或子串

**特性：**

- **连续性**：窗口内的元素是**「连续的子区间」**
- **双指针驱动**：通常用 `left` 和 `right` 控制窗口边界
- **动态更新**：扩张与收缩窗口时，窗口状态能在 **O(1)** 时间内更新
- **常见复杂度**：**O(n)**，适合大规模数据处理

**适用场景：**

- **固定长度**的区间统计（求和、求平均等）
- **可变长度**的条件匹配（如无重复字符、最小覆盖子串）

**核心思想：**

1. **两个指针** `left`、`right` 表示窗口边界
2. **右指针右移** 扩展窗口
3. 当窗口不满足条件时，**左指针右移** 收缩窗口
4. 每次窗口调整后更新结果

#### 1.2、算法模板与应用

**通用模板：**

```js
function slidingWindow(arr, conditionCheck, updateResult) {
  let left = 0;
  let windowState = {}; // 用于维护窗口状态（计数、和、Set、Map等）

  for (let right = 0; right < arr.length; right++) {
    // 1. 加入新元素（扩展窗口）
    addElementToWindow(windowState, arr[right]);

    // 2. 当窗口不满住条件时，左指针右移，收缩窗口
    while (!conditionCheck(windowState)) {
      removeElementFromWindow(windowState, arr[left]);
      left++;
    }

    // 3. 每次窗口调整后，更新结果
    updateResult(windowState, left, right);
  }
}
```

> 核心是：**扩张 + 收缩 + 更新状态** 三步循环
>
> **收缩** 和 **更新状态** 的顺序取决于窗口长度是否固定
>
> - 固定窗口长度
>   - 先更新状态，再收缩窗口
>   - 窗口长度满足条件时，窗口就已经有效了
> - 非固定窗口长度
>   - 先收缩窗口，再更新状态
>   - 需要先保证窗口有效
>
> 通用模板中一般是，先收缩窗口，在更新状态，因为大多数复杂题都是非固定窗口
>
> **三个灵魂问题：**<!--‼️很重要-->
>
> 1. 什么时候应该扩大窗口？
> 2. 什么时候应该缩小窗口？
> 3. 什么时候得到一个合法的答案？

**具体使用：**

**描述：**给定一个整数数组 `nums` 和整数 `k`，找出长度恰好为 `k` 的连续子数组的最大和

**示例：**

```markdown
输入：[1, 2, 3, 4, 5], 2
输出：9 (4+5)
```

**题解：**

```javascript
function maxSumSubarray(nums, k) {
  // 定义左指针
  let left = 0;
  // 创建一个窗口状态对象，用于维护窗口内的状态，sum 用于记录窗口内的和，size 用于记录窗口内的元素个数
  let windowState = { sum: 0, size: 0 };
  let maxSum = -Infinity;

  // 添加元素到窗口
  function addElementToWindow(state, value) {
    state.sum += value;
    state.size++;
  }

  // 移除元素从窗口
  function removeElementFromWindow(state, value) {
    state.sum -= value;
    state.size--;
  }

  // 检查窗口是否满足条件
  function conditionCheck(state) {
    // 窗口大小不能超过 k
    return state.size <= k;
  }

  // 更新结果
  function updateResult(state) {
    // 当窗口大小刚好为 k 时更新最大值
    if (state.size === k) {
      maxSum = Math.max(maxSum, state.sum);
    }
  }

  // 遍历数组，右指针右移
  for (let right = 0; right < nums.length; right++) {
    // 1. 加入新元素（扩展窗口）
    addElementToWindow(windowState, nums[right]);

    // 2. 当窗口不满足条件时，左指针右移，收缩窗口
    while (!conditionCheck(windowState)) {
      removeElementFromWindow(windowState, nums[left]);
      left++;
    }

    // 3. 每次窗口调整后，更新结果
    updateResult(windowState, left, right);
  }

  return maxSum;
}

// 示例
console.log(maxSumSubarray([1, 2, 3, 4, 5], 2)); // 输出 9 (4+5)

```

**解析：**

- 先创建一个**窗口状态对象**和一个**最大数变量**
  - **窗口状态对象**：记录窗口内所有元素的和和元素个数
  - **最大数变量**：记录最大和

- **扩展窗口**
  - 遍历数组，右指针右移，将新元素添加到窗口中
  - 并更新窗口状态，元素和增加，元素个数增加 1

- **收缩窗口**
  - 右指针一直往右移动，当窗口内的元素个数超过 k 时，则左指针右移，移除最左元素，使窗口内的元素个数维持在 k 个
  - 更新窗口状态，元素和减少，元素个数减少 1

- **更新结果**
  - 如果窗口大小刚好为 k，则更新最大和，并记录当前窗口内的和

- 最后返回**最大和**


### 二、经典问题

#### 2.1、最小覆盖子串

**描述:**

给定字符串 `s` 和字符串 `t`，返回 `s` 中包含 `t` 所有字符的最小子串。如果不存在这样的子串，返回空字符串 `""`

- 子串中的字符顺序不要求与 `t` 中一致，但必须全部包含
- 如果有多个长度相同的最小子串，返回任意一个即可

**示例:**

```markdown
输入: s = "ADOBECODEBANC", t = "ABC"
输出: "BANC"
```

**题解:**

```js
function minWindow(s, t) {
  // 创建一个窗口对象，用于维护窗口内的状态
  const window = new Map();
  // need 用于记录窗口内每个字符的个数
  const need = new Map();
  for (let c of t) need.set(c, (need.get(c) || 0) + 1);
  // 需要满足条件的字符种类数，即 t 中字符的种类数，重复的字符只算一个
  let needCount = need.size;
  // 记录最小子串的长度
  let minLen = Infinity
  // 记录最小子串的起始位置
  let start = 0

  // 左指针
  let left = 0

  // 遍历字符串 s，右指针右移
  for (let right = 0; right < s.length; right++) {
    let c = s[right];
    if (need.has(c)) {
      // 1. 扩展窗口
      window.set(c, (window.get(c) || 0) + 1);
      // 如果当前窗口内指定字符的个数与需要的个数相同，则说明当前窗口内该字符已符合条件，则需要匹配的目标字符个数减 1
      if (window.get(c) === need.get(c)) needCount--;
    }

    // 2. 满足条件时，更新最小子串的长度
    while (needCount === 0) {
      if (right - left + 1 < minLen) {
        minLen = right - left + 1;
        start = left;
      }
      // 3. 收缩窗口
      let lc = s[left];
      if (need.has(lc)) {
        // 这里很关键，只有在当前窗口内指定字符的个数等于需要的个数时，收缩窗口才会使窗口内该字符不符合条件
        // 大于时，就算收缩，还是符合条件
        // 小于时，之前就应该已经给 needCount 加 1 了，不能再次加 1 ，否则 needCount 就会失效
        if (window.get(lc) === need.get(lc)) needCount++;
        window.set(lc, window.get(lc) - 1);
      }
      left++;
    }
  }
  return minLen === Infinity ? "" : s.substring(start, start + minLen);
}

// 示例
console.log(minWindow("ADOBECODEBANC", "ABC")); // 输出 "BANC"
```

#### 2.2、无重复字符的最长子串

**描述:**

给定一个字符串 `s`，找出其中不包含重复字符的 **最长子串** 的长度

**示例:**

```markdown
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**题解:**

套用模板的实现

```js
function lengthOfLongestSubstring(s) {
  // 创建一个窗口对象，用于维护窗口内的状态
  const window = new Map();
  // 记录最长子串的长度
  let maxLen = 0;
  // 左指针
  let left = 0;

  // 遍历字符串 s，右指针右移
  for (let right = 0; right < s.length; right++) {
      // 1. 扩展窗口
      window.set(s[right], (window.get(s[right]) || 0) + 1);

      // 2. 当窗口条件不满足时，收缩窗口
      while (window.get(s[right]) > 1) {
        window.set(s[left], window.get(s[left]) - 1);
        left++;
      }
      // 3. 更新结果，记录最长子串的长度
      maxLen = Math.max(maxLen, right - left + 1);

  }

  return maxLen;
}

// 示例
console.log(lengthOfLongestSubstring("abcabcbb")); // 输出 3 ("abc")
```

更简洁的实现

```js
function lengthOfLongestSubstring(s) {
  const window = new Set();
  let maxLen = 0;
  let left = 0;

  for (let right = 0; right < s.length; right++) {
    // 收缩窗口直到没有重复
    while (window.has(s[right])) {
      window.delete(s[left]);
      left++;
    }
    // 扩展窗口
    window.add(s[right]);
    // 更新结果
    maxLen = Math.max(maxLen, right - left + 1);
  }

  return maxLen;
}
```

#### 2.3、将 x 减到 0 的最小操作数

**描述:**

给定一个整数数组 `nums` 和一个整数 `x`。每一次操作时，移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值

如果可以将 `x` 恰好减到 `0`，返回 最小操作数 ；否则，返回 `-1` 。

**示例:**

```markdown
输入: nums = [1,1,4,2,3], x = 5
输出: 2
解释: 最佳解决方案是移除后两个元素，将 x 减到 0。
```

**思路：**
这道题若是采用递归算法穷举的思路，会很复杂且效率低下，因为需要考虑所有可能的组合，时间复杂度为 O(2^n)

有一个很巧妙的思路是：将原问题（<!--从两端移除元素，使和为 x-->）转化为一个逆向的问题（<!--保留中间元素，使和为 total - x-->），也就是找到当前数组中和为 total - x 的**最长子数组**，最后返回原数组长度减去该子数组长度，即为最小操作数

这样便可以通过滑动窗口的算法来解决这个问题 <!--思维转换巧妙： 化繁为简，将复杂的两端操作转为简单的中间查找-->

**题解:**

```js
var minOperations = function(nums, x) {
    // 核心思想：逆向思维
    // 从两端移除元素使和为x，等价于在中间找一个子数组使和为(total - x)

    const total = nums.reduce((sum, num) => sum + num, 0);
    const target = total - x;

    // 如果target < 0，说明x比总和还大，无解
    if (target < 0) return -1;

    // 如果target = 0，说明要移除所有元素
    if (target === 0) return nums.length;

    // 使用滑动窗口找最长的子数组，使其和等于target
    let left = 0;
    let currentSum = 0;
    let maxLength = -1;

    for (let right = 0; right < nums.length; right++) {
        // 扩大窗口
        currentSum += nums[right];

        // 收缩窗口，直到和不超过target
        while (currentSum > target && left <= right) {
            currentSum -= nums[left];
            left++;
        }

        // 如果找到和为target的子数组，更新最大长度
        if (currentSum === target) {
            maxLength = Math.max(maxLength, right - left + 1);
        }
    }

    // 如果找不到符合条件的子数组，返回-1
    // 否则返回需要移除的元素个数
    return maxLength === -1 ? -1 : nums.length - maxLength;
};

// 示例
console.log(minOperations([1,1,4,2,3], 5)); // 输出 2

```

**解析：**

```markdown
示例： nums = [1,1,4,2,3], x = 5
```

执行过程

```markdown
步骤1: total = 11, target = 11 - 5 = 6
步骤2: 用滑动窗口找和为6的最长子数组

窗口移动过程：
right=0: [1] sum=1 < 6
right=1: [1,1] sum=2 < 6
right=2: [1,1,4] sum=6 = 6 ✓ maxLength=3
right=3: [1,1,4,2] sum=8 > 6, 收缩左边界
        [1,4,2] sum=7 > 6, 继续收缩
        [4,2] sum=6 = 6 ✓ maxLength=2
right=4: [4,2,3] sum=9 > 6, 收缩
        [2,3] sum=5 < 6

最长子数组长度 = 3
最小操作数 = 5 - 3 = 2 ✓
```

#### 2.4、存在重复元素 III

**描述:**

给定一个整数数组 `nums` 和两个整数 `indexDiff` 和 `valueDiff`。请判断是否存在两个不同下标 `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= valueDiff`，同时又满足 `abs(i - j) <= indexDiff`。

**示例:**

```markdown
输入: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0
输出: true
解释: 存在两个不同下标 i = 0 和 j = 3，满足 nums[i] = 1 和 nums[j] = 1。
同时满足 abs(i - j) <= 3 和 abs(nums[i] - nums[j]) <= 0。
```

**题解 1：桶解法 + 滑动窗口**

> **“桶解法”（Bucket Method）**并不是一种标准的独立算法，它是一种**常用的技巧/思路**
>
> **核心思想**：将数值空间划分成若干个固定大小的区间（桶），利用桶编号快速判断数值差是否在某个范围内
>
> **核心步骤**：
>
> 1. 将数值空间划分成固定大小的桶（每个桶的长度 = `差值上限 + 1`，保证桶内任意两个数差 ≤ 上限）
> 2. 把每个数映射到对应桶编号
> 3. 对每个新数：
>    - 检查当前桶 → 若已有元素，直接满足差值要求
>    - 检查相邻桶 → 可能满足差值要求
> 4. 如果有额外的约束（如下标差 ≤ k），可以用滑动窗口配合删除超出范围的桶
>
> **关键点**：
>
> - 桶编号通常用 `Math.floor(num / size)`
> - 桶大小 = `差值上限 + 1`
> - 确保窗口内的桶个数 ≤ 滑动窗口长度约束
>
> **示例：**
>
> - 问题描述：给定数组 `nums` 和差值上限 `t`，判断数组中是否存在两个数 `nums[i]` 和 `nums[j]`，使得
>
>   ```markdown
>   |nums[i] - nums[j]| ≤ t
>   ```
>
> - 题解：
>
>   ```javascript
>   function containsNearbyValue(nums, t) {
>     if (t < 0) return false;
>  
>     const buckets = new Map();
>     const size = t + 1; // 桶大小
>  
>     const getBucketId = (num) => Math.floor(num / size);
>  
>     for (const x of nums) {
>       const id = getBucketId(x);
>  
>       // 同桶：必定差值 ≤ t
>       if (buckets.has(id)) return true;
>  
>       // 相邻桶：差值可能 ≤ t
>       if (buckets.has(id - 1) && Math.abs(x - buckets.get(id - 1)) <= t) return true;
>       if (buckets.has(id + 1) && Math.abs(x - buckets.get(id + 1)) <= t) return true;
>  
>       // 放入桶
>       buckets.set(id, x);
>     }
>  
>     return false;
>   }
>  
>   // 结果打印
>   const nums = [1, 5, 9, 1];
>   const t = 3;
>   console.log(containsNearbyValue(nums, t)); // 输出 true
>   ```

桶解法本质是维护一系列的差值倍数的区间，同桶：必定差值 ≤ t，相邻桶：差值可能 ≤ t，结合滑动窗口算法，便可以解决此题👇

```javascript
/**
 * @param {number[]} nums
 * @param {number} indexDiff
 * @param {number} valueDiff
 * @return {boolean}
 */
var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {
  // 边界条件，若是索引差和值差小于0，则返回 false
  if(indexDiff < 0 || valueDiff < 0) return false

  // 维护一个窗口对象，该对象是一个“桶”对象，索引是桶的id，值是桶内的元素
  const buckets = new Map()
  // 桶的大小，因为桶内元素的差值不能超过 valueDiff，所以桶的大小为 valueDiff + 1
  const size = valueDiff + 1

  // 获取桶的id，因为桶内元素的差值不能超过 valueDiff，所以桶的id为 num / size 的向下取整
  const getBucketId = (num) => Math.floor(num/size)

  // 遍历 nums
  for(let right = 0; right < nums.length; right++) {
    // 当前元素
    const x = nums[right]
    // 获取桶的id
    const id = getBucketId(x)

    // 每一个桶里的元素差值必然小于等于 valueDiff，相邻桶里的元素差值可能小于等于 valueDiff

    // 若窗口对象中存在当前元素对应的桶，则说明之前有一个元素和当前元素的差值小于等于 valueDiff，
    // 并且往窗口对象中新增了它的桶，因此证明了存在满足条件的元素
    if(buckets.has(id)) return true

    // 和相邻的桶进行比较，若满足条件，则返回 true
    // 为何相邻桶的元素只有一个，因为若是有两个元素属于同一个桶，上一步就已经返回 true 了
    if(buckets.has(id - 1) && Math.abs(buckets.get(id - 1) - x) <= valueDiff) return true
    if(buckets.has(id + 1) && Math.abs(buckets.get(id + 1) - x) <= valueDiff) return true

    // 1.拓展窗口，将当前元素插入到窗口对象中，也就是将当前元素所属于的桶插入到窗口对象中
    buckets.set(id, x)

    // 2.收缩窗口，若窗口大小超过 indexDiff + 1，则需要移除窗口最左边的元素
    while(buckets.size > indexDiff) {
      // 获取窗口最左边的元素的桶的id
      const leftId = getBucketId(nums[right - indexDiff])
      buckets.delete(leftId)
    }
  }
  return false
}
```

**解析：**

- 首先维护一个窗口对象，该对象是一个“桶”对象，索引是桶的id，值是桶内的元素
- 桶的大小为 `valueDiff + 1`，因为桶内元素的差值不能超过 `valueDiff`，所以桶的大小为 `valueDiff + 1`
- 相同桶：必定差值 `≤ valueDiff`，相邻桶：差值可能 `≤ valueDiff`
- 窗口对象中只能最多只能同时存在 `indexDiff` 个桶，当达到上限时，需要将窗口最左边的元素对应的桶删除

**题解二：二分查找有序数组 + 滑动窗口**

和上面的解法类似，将窗口中元素添加到有序数组中，数组 `length` 上限为 `indexDiff` ，比较当前值和左右相邻值的差值是否符合要求

具体题解👇

```javascript
/**
 * @param {number[]} nums
 * @param {number} indexDiff
 * @param {number} valueDiff
 * @return {boolean}
 */
var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {
  // 为何一个窗口对象，其是一个有序数组
  const window = [];

  // 遍历 nums
  for(let i = 0; i < nums.length; i++) {
    const x = nums[i]

    // 二分查找获得插入位置, lowerBound，找到第一个 >= x 的位
    let left = 0, right = window.length
    while(left < right) {
      const mid = left + Math.floor((right - left) / 2)

      if(window[mid] >= x) {
        right = mid
      } else {
        left = mid + 1
      }
    }

    // 因为维护了一个有序数组，若是当前值和左右相邻值的差值都大于valueDiff的话，那说明和剩余的值的差值也一定大于valueDiff
    // 所以只需要比较当前值和左右相邻值即可，若满足条件，则返回 true

    // 和右边的值进行比较，若满足条件，则返回 true
    if(left < window.length && Math.abs(window[left] - x) <= valueDiff ) return true
    // 和左边的值进行比较，若满足条件，则返回 true
    if(left > 0 && Math.abs(window[left - 1] - x) <= valueDiff) return true

    // 1.拓展窗口，将当前值插入到有序数组中
    window.splice(left, 0, x)

    // 2.收缩窗口，若窗口大小超过 indexDiff + 1，则需要移除窗口最左边的元素
    if(window.length > indexDiff) {
      const idx = window.indexOf(nums[i - indexDiff])
      window.splice(idx, 1)
    }
  }

  return false
};
```


### 三、核心思想解读

**本质总结**

- **双指针控制窗口**：`left` 收缩，`right` 扩展
- **状态维护**：用变量/数据结构记录当前窗口信息
- **条件驱动移动**：根据题目条件决定收缩或扩展窗口
- **结果实时更新**：每次窗口变化时更新最优结果
- **避免重复计算**：通过增量更新，省去每次全量扫描
